---
title: 项目
date: 2022-03-21 08:52:35
permalink: /pages/c2c415/
sidebar: auto
categories:
  - 随笔
tags:
  - 
---

技术点学习：**在学习每一个技术点的时候，都要注意一些问题：是什么？为了解决什么问题？如何实现的，有没有更深的原理？如何使用？使用的时候需要注意什么？有哪些应用的场景？有什么不足？这些不足能否避免？**

项目准备：**理清项目中用到的技术、遇到的难点有哪些、又是怎么解决的、对项目做过哪些性能优化、做过的亮点有哪些**。

着重准备 **项目中遇到的难点有哪些、又是怎么解决的、对项目做过哪些性能优化、做过的亮点有哪些、把一个项目的关键模块回顾并吃透**

## 登录流程的优化

项目中存在登录时长太久问题。项目在登录的时候，就需要获取到依赖数据，比如菜单配置，商品信息等等。因为要确保已经从服务获取到数据，所以用上了async,await。在没有优化之前，采用的做法是一个方法，一个await，然后一个日志，总共有十来个接口。这样如果其中一个接口卡住了，就会导致登录时长很久。优化的方案是利用把接口错误日志放在具体接口里，然后用Promise.all来替换一个个await。这里还有一个难点，就是对业务很熟，因为接口之前存在依赖问题。

## 确实刷新的时候，以及拿到了依赖数据

背景：项目中用到了websocket，刷新的时候，会重写链接，那么如何确保在获取数据之前，已经获取相关的依赖。

方案：刷新的时候是需要获取依赖数据，再请求页面对应的数据，而路由跳转页面，则是直接请求接口数据。在具体页面的时候，我们不应该你是刷新，还是路由跳转，只关系，请求数据即可。所以，处理方法是定义initData公共函数，这个函数接受一个回调函数，在这个回调函数内部请求数据。接下来就是处理回调函数的执行顺序，这里会定义一个变量isLoadComplete，来控制是否加载完成，默认是false。

处理页面刷新，监听load事件和EventBus来解决，initData内容会订阅事件，订阅的时候的回调函数内容，当isLoadComplete为true的时候，执行callback回调。触发更新，监听load事件，先把isLoadComplete设置为false，当依赖数据请求完成的时候，把isLoadComplete设置为true，并且发布事件，触发callback执行。

如果是第一次启动，则是利用路由钩子，登录之前设置为false，登录成功设置为true，initData函数内部，如果isLoadComplete为true的时候，就会触发callback执行。

最好在组件卸载的时候，取消订阅事件。

```js
let isLoadComplete = false;

// 未缓存页初始化数据
export const initData = (callback: Function): void => {
    // 刷新整个页面时候，需要等数据加载数据
    const cb = () => {
        if (isLoadComplete) {
            callback && callback();
        }
    };
    Bus.$on('loadComplete', cb);
    if (isLoadComplete) {
        callback && callback();
    }
    onUnmounted(() => {
        Bus.$off('loadComplete', cb);
    });
};

// 页面刷新
window.addEventListener('load', () => {
  setLoadComplete(false);
  globalDataRefresh().then(() => {
    setLoadComplete(true);
    eventBus.$emit('loadComplete');
  })
})

// 路由钩子
router.beforeEach(() => {
  if(getLoadIsComplete()) {
    setLoadComplete(false)
    login().then(() => {
      setLoadComplete(true)
    })
  }
})
```

## 封装表格通用逻辑

背景：项目中有很多需要表格来展示数据的页面，例如报表。

封装各个逻辑

- 获取列表数据：
  - 控制loading
  - 浮动失真问题。默认2位，超过6为小数就自动截取。

- 右键逻辑
  - 右键组件要包裹表格组件，
    - 简化逻辑，只需要传入按钮数据即可。
    - 解决bug，元素点击错误。
  - 过滤表头，内容会定位右键位置
- 控制弹出组件逻辑
  - 组件id，与动态组件名对用
  - 弹窗组件统一emite一个cancel事件，并接受一个参数，关闭的时候，表示是否刷新数据
  - 遇到问题：打开的页面数据是旧的，控制
- 表格事件
  - 定义一个变量，接受表示选中的那条数据
  - 点击事件，接受选择数据，缓存key，打开折叠面板，如果有回调，则会执行回调函数
  - 右键事件，接受选中数据，如果有回调，则会执行回调函数

结果：引入相关组件，只需按照参数传递就可以快速实现表格页面功能，这样就提高开发效率。

## 行情按需订阅

- 订阅池子Map，只暴露出添加订阅和删除订阅方法。
  - 添加订阅
    - 每次添加订阅的时候，就先去主动连接行情，主动连接行情内部已经处理好了，如果已经链接上了，不会再去重新连接。
    - 然后订阅池子里添加数据，添加完后把池子里的数据都拿出来，在去重后就开始商品订阅
  - 删除订阅
    - 先判断是否存在uuid，删除后如果还有数据，则合并去重池子map里的数据，重新订阅商品。如果没有数据，就断开行情链路的连接

实现行情按需订阅
  - 接受一个必填参数，列表数据，和三个可选参数，codeKey，行高，selector
  - 第一次启动的是利用watchEffect这个api，自动执行行情订阅。并且监听scroll事件，内部加入防抖，然后判断滚动方向，根据行高，计算出可视区域的行数，为了更好的体验，会在加两条数据，然后计算出，滚动条位置与表格数据对应的索引位置。

## 主题色

方案：css 变量，
切换主题： document.documentElement.setAttribute('theme', value)
持久化：localStorage 缓存当前主题

## 封装protobuf请求方法

背景：需要自己组装数据，手动调用长连接发送方法。

封装好后，安装模板填入数据即可。

- 组装数据
  - 需要传入funcode，protobufName，接口对应的参数，可选的protoHead参数
  - proto有两条链路，统一查询和单独某一条数据查询。
    - 单独查询 
      - 先构建header，然后再构建具体内容。
      - 先把proto报文转换成Map键值对，然后变量接口对应的参数，往报文里填充数据。
      - 好处，不需要手动构建报文了，另外组装的时候处理好了id大小写混乱的问题
    - 统一查询
      - 存在加密信息处理的情况
      - 存在坑：组装报文的时候，accountid取名不一样，需要枚举处理。
  - 解析报文
    - 管理端错误：RetCode -1
    - 银行业务错误：RetCode null
