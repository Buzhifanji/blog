---
title: vue3进阶笔记之vuex
date: 2022-04-18 10:35:03
permalink: /pages/18eeef/
categories:
  - 前端
  - vue
tags:
  - Javascript
  - vue
---

理解vuex的作用，以及实现原理。

## vuex 的用途

### vuex 解决了什么问题。

现在不管是vue、angular或者react，都是采用组件化开发，单项数据流。

这里就会带来一个新的问题，组件之间如何处理共享的数据。如果只是父子组件，可以通过prop和emit来来传递，但是深层次组件采用层层传递就会特别麻烦。

vue和react处理方案都是引入了**状态管理**，angular中有service，它本身就解决了数据共享问题。

vuex是vue中的状态管理一种具体实现。

### vuex的雏形

vuex是处理组件之间的共享数据一种实现方案，如果让你来处理组件间共享数据问题，那么你会如何实现？

解决这个问题常见的思路就是：专门定义一个全局变量，任何组件需要数据的时候都从这个变量中获取。

从设计模式角度来说，引入一个单例来解决数据共享。

```js
window._store = {}
```

但这样就会产生一个问题，window._store 并不是响应式的，如果在 Vue 项目中直接使用，那么就无法自动更新页面。

所以我们需要用 ref 和 reactive 去把数据包裹成响应式数据，并且提供统一的操作方法，这其实就是数据管理框架 Vuex 的雏形了。

## 实现一个min-vuex

### 数据操作

首先 vuex 是个单例，我们用一个class来实现。

```js
class Store {}
```

使用 _state 存储数据，使用 mutations、actions 来存储数据修改的函数

```js
import { reactive } from "vue";
class Store {
    constructor(option) {
        this._state = reactive({
            data: option.state(),
        }); // 转变成响应式数据
        this._mutations = option.mutations || {};
        this._actions = option.actions || {}
    }
}
```

完善数据存储操作

```js
class Store {
  constructor(option) {
    this._state = reactive({
      data: option.state(),
    });
    this._mutations = option.mutations || {};
    this._actions = option.actions || {}
  }
  get state() { // 读取 state 的时候直接获取响应式数据 _state.data
    return this._state.data;
  }
  commit = (type, payload) => { // 更改数据方法，执行 _mutations 里存储的方法
    const entry = this._mutations[type];
    entry && entry(this.state, payload);
  };
  dispatch = (type, payload) => { // 与 _mutations 逻辑一样
    const action = this._actions[type]
    action && action(this, payload)
  }
}
```

### 插件安装

我们通过依赖注入：[provide、inject ](16.vue3进阶笔记之provide、inject.md)来处理数据共享。

使用的时候，inject store

```js
import { inject } from "vue";

const STORE_KEY = "__store__";

function useStore() { // 使用的时候，注入store
  return inject(STORE_KEY);
}
```
安装插件的时候，provide store

```js
class Store {
    
  // main.js 入口处 app.use(store)的时候，会执行这个函数
  install(app) {
    app.provide(STORE_KEY, this);
  }
}
```
### 使用

暴露一个 createStore 去创建 Store 的实例

```js
// 创建 store 实例
function createStore(option) {
  return new Store(option);
}
```

创建实例

```js
// import { createStore } from 'vuex'
import { createStore } from './gvuex'
const store = createStore({
    state() {
        return {}
    },
    mutations: {},
    actions: {},
})
export default store
```
最终我们使用 store 的方式，在项目入口文件 src/main.js 中使用 app.use(store) 注册

### 完整代码

```js
import { inject, reactive } from "vue";

const STORE_KEY = "__store__";

function useStore() {
  return inject(STORE_KEY);
}

// 创建 store 实例
function createStore(option) {
  return new Store(option);
}

class Store {
  constructor(option) {
    this._state = reactive({
      data: option.state(),
    });
    this._mutations = option.mutations || {};
    this._actions = option.actions || {}
  }
  get state() {
    return this._state.data;
  }
  commit = (type, payload) => {
    const entry = this._mutations[type];
    entry && entry(this.state, payload);
  };
  dispatch = (type, payload) => {
    console.log('_actions', this._actions);
    const action = this._actions[type]
    action && action(this, payload)
  }
  // main.js 入口处 app.use(store)的时候，会执行这个函数
  install(app) {
    app.provide(STORE_KEY, this);
  }
}

export { createStore, useStore };
```

## vuex的思考

vuex的用途：**集中式**管理组件数据，包括存储、修改操作。vuex类似与管家，有一定的约束力。
举个生活中例子，公司越大，规则制度越多，这是为什么呢？因为人越多，需要制度来约束，这样方便管理，提高公司运作效率。而小公司不需要，小公司制度多，反而会影响公司的运作。

什么时候该使用vuex呢？
**如果是数据只是组件内部使用，就使用ref。
如果数据需要跨组件，跨页面共享的时候，就使用vuex**
