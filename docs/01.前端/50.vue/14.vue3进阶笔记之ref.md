---
title: vue3进阶笔记之ref
date: 2022-04-16 10:13:00
permalink: /pages/ecd654/
categories:
  - 前端
  - vue
tags:
 - Javascript
 - vue 
---

vue3 声明相应数据有两个API：reactive、ref。

[vue3进阶笔记之reactive](12.vue3进阶笔记之reactive.md)模拟了reactive的实现。本文接下来介绍ref的实现。

## why

有了reactive，为什么还要设计一个refAPI？

js数据分为基本数据类型和引用数据类型。引用数据类型共享的引用地址，而基本类型不是。

基本数据类型例子

```js
let a = '1'
let b = a
a = '2'
console.log(b) // 1  b 并没有改变
```

引用数据类型例子

```js
let objA = { name: 'a'}
let ojbB = objA
objA.name = 'b'
console.log(ojbB.name) // b ojbB的name属性变更该了
```
想要数据是响应式的，对于基本数据类型，不能共享引用地址，那该怎么办？

vue3处理办法就是把基本数据类型封装成引用数据类型，这样就可以共享了。

## ref 源码实现

```ts
function ref(value?: unknown) {
  return createRef(value)
}
// shallow 是浅代理
function createRef(rawValue: unknown, shallow = false) {
    if (isRef(rawValue)) {
        return rawValue
    }
    return new RefImpl(rawValue, shallow)
}
```
重点关注 RefImpl 这个类的实现。

```ts
class RefImpl<T> {
  private _value: T
  private _rawValue: T

  public dep?: Dep = undefined // 存储依赖数据
  public readonly __v_isRef = true

  constructor(value: T, public readonly _shallow = false) {
    this._rawValue = _shallow ? value : toRaw(value)
    this._value = _shallow ? value : convert(value) // 如果是对象，就会调用reactive 实现查看下面
  }

  get value() {
    trackRefValue(this) // 收集依赖
    return this._value
  }

  set value(newVal) {
    newVal = this._shallow ? newVal : toRaw(newVal)
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal
      this._value = this._shallow ? newVal : convert(newVal) // 如果是对象，就会调用reactive 实现查看下面
      triggerRefValue(this, newVal) // 更新依赖
    }
  }
}

const convert = <T extends unknown>(val: T): T =>
    isObject(val) ? reactive(val) : val
```
到这里我们知道了。ref包裹的数据存放在value属性上。当读取value的时候，收集依赖，更改value的时候，更新依赖，这里与reactive的逻辑是一样的。

如果不是浅代理，对于引用数据类型，ref内部会调用reactive。说明ref既可以用于基本数据类型，也可以用引用数据类型。