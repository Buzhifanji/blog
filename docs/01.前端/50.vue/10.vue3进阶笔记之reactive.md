---
title: vue3进阶笔记之reactive、effect
date: 2022-04-09 12:26:30
permalink: /pages/1c753e/
categories:
  - 前端
  - vue
tags:
  - Javascript
  - vue
---

本文的目的：写一个min版的reactive和effect，弄清楚vue3响应式是如何工作的

reactive 函数接受一个对象作为参数，并返回一个代理对象。详细用法参考官方文档：[reactive](https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive)  

## 感知存取

平常我们是这样获取和修改对象属性的：

```js
// 定义一个 obj 对象
const obj = {age: 20}
// 修改 obj 的 age 属性
obj.age = 22
// 访问 对象属性
console.log(obj.age)
```

我们可以直接访问和修改对象属性，但是如果我们想感知到这些操作该怎么办？也就是说，访问的时候，告诉我你访问了；修改的时候，告诉我你修改了。

为了实现感知对象操作功能，我们需要: [Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy), [Reflect](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect) 这两个API。

```js
const obj = {age: 22}
new Proxy(obj, {
    get(target, key, receiver) {
        console.log('访问!!!');
        return Reflect.get(target, key, receiver)
    },
    set(target, key, value, receiver) {
        const result = Reflect.set(target, key, value, receiver)
        console.log('修改！！！');
        return result
    }
    
})
// 获取对象属性
console.log(obj.age)

// 修改对象属性
obj.age = 30
```
Proxy 第二个参数是个对象，这个对象包含了get和set函数。

在get函数里我们可以感知到获取对象属性的操作，在set函数里我们可以感知到对象修改属性的操作。

## 依赖数据


非常好，接下来，我们可以在get的时候，收集依赖，set的时候，触发依赖更新。

## 响应式思想

我们先来看看下面的代码

```js
let x = 0;
let y = 0

function change() {
    y = x * 2
}
x = 2
change() // y = 4

x = 4
change() // y = 8
```
y和x的关系是： y是x的2倍。当x变更的时候，通过调用 change 函数，y也会变化。

我们是手动调用的，而响应式是值，当x变更的时候，会自动调用 change 函数。

把依赖关系封装成一个函数，当依赖变更的时候，自动调用这个函数，这就是响应式思想。

## 依赖数据



```js
function effect(fn, options) {
    // 创建依赖数据
    const _effect = new ReactiveEffect(fn)
    // 延迟执行，computer 的时候会用上
    if (!options || !options.lazy) {
        _effect.run()
    }
    // 手动绑定this
    const runner = _effect.run.bind(_effect)
    runner.effect = _effect
    return runner
}
```

```js
let activeEffect = undefined // 当前 effect
let shouldTrack = false // 是否可以收集依赖

class ReactiveEffect {
    deps = [] // 存储 响应式收集
    active = true // 控制是否收集响应式依赖

    constructor(fn, scheduler) {
        this.fn = fn
        this.scheduler = scheduler // 手动调度
    }

    run() { // 执行 相适应依赖收集
        if (!this.active) {
            return this.fn()
        }
        activeEffect = this
        shouldTrack = true
        const result = this.fn()
        shouldTrack = false
        return result
    }

    stop() { // 停止
        if (this.active) {
            this.deps.forEach(dep => {
                dep.delete(this)
            })
            this.active = false
        }
    }
}
```

## 收集依赖

当读取对象属性的时候，就进行依赖收集。

```js
const targetMap = new WeakMap() // 存储依赖数据
// 收集依赖。
function track(target, key) {
    let depsMap = targetMap.get(target)
    if (!depsMap) {
        // 如果没有目标对象 target 的依赖，就声明一个空的 Map
        targetMap.set(target, (depsMap = new Map()))
    }
    // 根据找到对应的 依赖
    let dep = depsMap.get(key)
    if (!dep) {
        // 如果 没有 key 对应的依赖，就声明一个空的 Set
        depsMap.set(key, dep = new Set())
    }
    
    // 进入依赖收集程序
    trackEffects(dep)
}
```
这里利用了WeakMap、Map、Set三种数据结构来存储依赖。

```js
function trackEffects(dep) {
    if(!dep.has(activeEffect)) { // 防止重复收集
        dep.add(activeEffect) // 收集 reactive 对象的依赖
        activeEffect.deps.push(dep) // 收集 effect 包裹的依赖
    }
}
```

## 触发依赖

```js
function trigger(target, key) {
    const depsMap = targetMap.get(target)
    if (!depsMap) {
        // 没有找到，就不触发依赖
        return
    }
    const dep = depsMap.get(key)
    // 找到 依赖后，遍历执行
    for (const effect of dep) {
        if (effect.scheduler) { // 手动调度
            effect.scheduler()
        } else {
            effect.run()
        }
    }
}
```

## reactive

```js
function reactive(target) {
    if (!isObject(target)) {
        // 如果不是对象数据类型，就直接返回本身
        console.warn(`value cannot be made reactive: ${String(target)}`)
        return target
    }

    return new Proxy(target, {
        get(target, key, receiver) {
            // 收集依赖
            track(target, key)
            return Reflect.get(target, key, receiver)
        },
        set(target, key, value, receiver) {
            const result = Reflect.set(target, key, value, receiver)
            // 触发依赖
            trigger(target, key)
            return result
        }
    })
}
```

测试代码

```js
const obj = {
    name: 'test',
    age: 90
}
const res = reactive(obj)
const runner = effect(() => {
    console.log(res.name)
    console.log(res.age)
})
res.name = '111' // 会触发 effect
res.age = 200 // 会触发 effect
stop(runner) // 停止收集
res.name = '33' // effect 不会被执行
```
完整代码：[reactive-effect](https://codepen.io/buzhifanji/pen/oNpdraj?editors=1111)