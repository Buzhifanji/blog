---
title: vue3进阶笔记之provide、inject
date: 2022-04-16 10:51:36
permalink: /pages/3c450a/
categories:
  - 前端
  - vue
tags:
 - Javascript
 - vue
---

本文主要vue3中弄清楚依赖注入是如何实现的。

## provide 源码

```ts
export function provide<T>(key: InjectionKey<T> | string | number, value: T) {
    if (!currentInstance) {
        if (__DEV__) {
            warn(`provide() can only be used inside setup().`)
        }
    } else {
        // currentInstance 是当前组件示例
        let provides = currentInstance.provides
        // 父组件的provides： 当前组件实例 没有的话，就去父组件的 provides
        // 为什么是从当前组件里开始获取 父组件的 provides？
        const parentProvides =
            currentInstance.parent && currentInstance.parent.provides
        if (parentProvides === provides) {
            // 通过 Object.create 指定 parentProvides 为 provides的原型
            provides = currentInstance.provides = Object.create(parentProvides)
        }
        // 处理 好 provides 后，进行赋值操作
        provides[key as string] = value
    }
}
```
源码虽然简短，但是理解起来确实不简单。

### 组件是如何创建provides

currentInstance 是当前组件示例，接下来看看组件实例

```ts
  const instance: ComponentInternalInstance = {
    uid: uid++,
    vnode,
    type,
    parent,
    ...,
    provides: parent ? parent.provides : Object.create(appContext.provides), // 此处很重要
    ...
}
const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext
const emptyAppContext = {
    ...,
    provides: Object.create(null),
}
```
每当创建一个组件的时候，就会先判断是否有父组件，如果有父组件就去父组件的provides，如果没有父组件，provides就是空对象。

这里就清楚了为什么parentProvides是先从当前组件组件实例中获取。

## inject 源码实现

```ts
function inject(
  key: InjectionKey<any> | string,
  defaultValue?: unknown, // 默认值，存在找到key 对应的值的情况
  treatDefaultAsFactory = false
) {
  // fallback to `currentRenderingInstance` so that this can be called in
  // a functional component
  const instance = currentInstance || currentRenderingInstance
  if (instance) {
    // #2400
    // to support `app.use` plugins,
    // fallback to appContext's `provides` if the intance is at root
    const provides =
      instance.parent == null
        ? instance.vnode.appContext && instance.vnode.appContext.provides
        : instance.parent.provides // 取父组件实例的 provides

    if (provides && (key as string | symbol) in provides) {
      // 查找 key，原型链是自动查看，没有自身没有就会向原型中查找。
      return provides[key as string]
    } else if (arguments.length > 1) {
        // provides中不存在可以 key，就去默认值
        // 默认值 支持函数
      return treatDefaultAsFactory && isFunction(defaultValue)
        ? defaultValue.call(instance.proxy)
        : defaultValue
    } else if (__DEV__) {
      warn(`injection "${String(key)}" not found.`)
    }
  } else if (__DEV__) {
    warn(`inject() can only be used inside setup() or functional components.`)
  }
}
```

inject 先从父组件里获取provides，然后判断provides中是否存在对应的key，如果存在就返回key对应的属性。没有就去传入的默认值。

## 总结

vue3在每个组件创建的时候，都会取父组件的provides，如果没有就定义初始化一个的对象。

当组件provide数据的时候，就会指定父组件的provides为原型，然后添加数据。

当组件inject的时候，就会通过原型链查找数据。

因为每个组件都缓存了父组件的provides，所以不需要通过自己手动遍历查找。

另外，存在查找的时候，寻找不到对应的数据。所以为了处理这种情况。vue提供了默认值参数，inject的时候，如果没有找到就去第一个参数作为默认值。

同时第个参数支持函数写法，第三个参数设置传入true，第二个参数为函数类型。

vue3 的依赖注入巧妙的使用了原型链，通过创建组件的时候，缓存父组件的provides，到达provides向下传递。

取值则是常规操作，找到key就返回属性，没有找到就默认值。