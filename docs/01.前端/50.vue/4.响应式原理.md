---
title: 响应式原理
date: 2022-03-08 03:11:45
permalink: /pages/c51d69/
categories:
  - 前端
  - vue
tags:
  - Javascript 
  - vue
---

简述Vue的响应式原理，用自己的话表述出来，解决面试的时候表达不清楚的问题。

## 定义

响应式是指组件中的data数据发生变化后，视图也会随着发生改变。

vue2 的实现方式是：Object.defineProperty实现数据劫持 + [观察者模式](/pages/73d23b/) ，而Vue3 主要通过Proxy这个API实现。

## vue2 实现原理

### 转换成get、set
   
在vue initState的时候，通过Object.defineProperty这个API，把组件里的data数据转换成getter、setter，同时也会创建Dep来收集该data的Watcher。

### 搜集依赖
   
在组件渲染的时候，会创建一个对应的Watcher，并将Dep.target标识为当前的Watcher。此时，如果视图使用了data中的数据，就会Data触发get方法，然后调用Dep.addSub将Watcher搜集起来。

### 更新依赖

数据更新的时候，就会触发data的set方法，然后调用Dep.notify通知用到该data的Watcher去更新DOM。

## vue2 如何处理数组响应式

Object.defineProperty不能监听数组长度的变化。

因为性能问题，未采用监听数组每个下标的方法，而是重写会影响数组方法。

vue在ininState的时候，会在初始化Observer类的时候会创建一个Dep来收集依赖，并且为每个响应式数据定义一个__ob__的属性。

在遇到处理数组转换成响应式的时候，vue首先通过Object.defineProperty拦截数组原型的push、pop、shift、unshift、splice、slice、reverse这7个方法，然后在这些方法内部调用__ob__.dep.notify方法。

## vue3 实现原理

vue3在setupComponent的时候，会调用composition-api，处理options得到响应式对象，并且会创建一个负责渲染的effect。

在组件渲染的时候，会触发get，调用track方法，然后通过Proxy对象和key形成对应的deps，将负责渲染的effect存入deps中。

数据更新的时候，会触发set，调用trigger方法，然后通过Proxy对象和key找到对应的deps，然后把deps分类成功computedRunners和effect。需要调度的，则会放入调度中；不需要的就会依次执行。

## vue3和vue2响应式原理对比

- vue2采用 Object.defineProperty 来劫持整个对象，vue3采用的是proxy来劫持对整个，这两个api相同之处就是只能劫持对象本身，不能劫持子对象的变化。对于子对象，vue2是通过深度遍历所有属性，而vue3是在对象属性被访问的时候，才会递归执行下一步的reactive。vue3实现了延迟定义子对象响应式的实现，这样做可以较大的提高性能。

- vue3解决了vue2中对属性的添加、删除动作不能监测，对数组基于下标的修改、数组length修改不能监测的问题。

- vue3实现了对Map、Set、WeakMap 和 WeakSet 的支持
  
## 参考资料
- [图解 Vue 响应式原理](https://juejin.cn/post/6857669921166491662#heading-0/)
- [Vue原理解析（七）：全面深入理解响应式原理(下)-数组进阶篇](https://juejin.cn/post/6844903916954451982#heading-5)
- [vue3.0 响应式原理(超详细)](https://juejin.cn/post/6858899262596448270#heading-25)