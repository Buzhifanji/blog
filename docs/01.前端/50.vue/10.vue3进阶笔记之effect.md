---
title: vue3进阶笔记之effect
date: 2022-04-14 14:56:25
permalink: /pages/dac852/
categories:
  - 前端
  - vue
tags:
  - Javascript
  - vue
---
vue3的响应式是基于effect和reactive实现，所以想要理解vue3的响应式原理，就需要清楚effect是如何运作的。

vue3定义了 effect 函数，也实现了用 ReactiveEffect 类来实现 effect 数据结构。

## effect 函数用法

effect 接受两个参数：fn 回调参数，option 可选参数对象。

effect 返回一个函数，并且这个函数拥有effect属性。

### 普通例子

```js
import { effect } from "vue";
let uuid = 0
const name = '次'
const runner = effect(() => {
    uuid++
    console.log(uuid, name)
})
// 代码执行到这时 会打印 1 次

runner() // 会打印 2 次

runner.effect.run() // 会打印 3 次, 调用 runner 和 runner.effect.run 是执行一样的函数

console.log(runner.effect) // 查看函数上effct数据结构，如下图
```
![](https://cdn.jsdelivr.net/gh/Buzhifanji/imgs-store/blog/20220414155712.png)

effect 函数只接受一个函数 fn 参数时候，会立即执行 fn 这个函数，并返回一个 runner 函数，当 调用 runner 时候，会触发 fn 函数。

### lazy 示例

可选参数里的 lazy 是个 Boolean 值。

```Js
import { effect, inject, provide, ref } from "vue";
const name = ref('lazy')
const runner = effect(() => {
    console.log(name.value)
}, { lazy: true})
// 和普通示例不同，执行到这里的时候，并未打印 lazy
runner() // 会打印 lazy
```
当effect 函数接受两个参数，一个参数为函数fn，另外一个可选参数lazy为true时候，fn 函数不会立即执行了，只有执行 runner 才会触发fn函数执行。
当

### scheduler 示例

可选参数里的 scheduler 是个 函数。

```js
import { effect, ref } from "vue";
const name = ref('执行effect')
const scheduler = () => {
  console.log('scheduler执行了！')
}
const runner = effect(() => {
    console.log(name.value)
}, { scheduler})
runner() // 注意 scheduler 函数没有执行
name.value = 'action'
runner() // 此刻才会执行 scheduler 函数
```

effect接受了scheduler可选参数后，函数fn也不会立即执行。effect里的依赖数据发生改变时候，才会触发 scheduler 函数执行。

## effect 函数的实现

只关注重点，省略一些特殊情况处理代码。

```ts
export function effect<T = any>(
  fn: () => T,
  options?: ReactiveEffectOptions
): ReactiveEffectRunner {
  // 实例化 ReactiveEffect,并赋值给_effect,
  const _effect = new ReactiveEffect(fn)
    
  // 合并可选参数，例如 lazy，scheduler
  if (options) { 
    extend(_effect, options)
  }  
    
  // 如果 没有可选参数的时候，就不会执行 run，这也就是 为什么 上面会打印 1次 的原因
  // 获取 lazy 为 true 的时候， 也不会执行 run
  if (!options || !options.lazy) {
    _effect.run()
  }

  // 手动把run函数的中this指向给_effect
  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner
  // 返回函数的 effect 属性
  runner.effect = _effect
  return runner
}
```

## effect 数据结构的实现

```ts
export class ReactiveEffect<T = any> {
  active = true 
  deps: Dep[] = []
  computed?: boolean
  allowRecurse?: boolean
  onStop?: () => void
  constructor(
    public fn: () => T,
    public scheduler: EffectScheduler | null = null,
  ) {
  }
  run() {
      this.fn()
  }
  stop() {}
}

```

目前只关注 effect 的数据结构，只需要了解 run 方法执行的时候 会执行 fn 函数即可。

## 总结

effect 函数只接受一个函数的时候，会立即执行这个函数，并且返回一个函数。
返回的函数执行的时候，会触发参数函数执行。

effect 可以通过 lazy 来控制参数函数是否延迟执行。

effect 可以通过 scheduler 来调度依赖变更的时候，触发 scheduler 函数执行。