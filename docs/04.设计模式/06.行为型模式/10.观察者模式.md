---
title: 🦉观察者与发布订阅模式
date: 2022-03-07 20:54:07
permalink: /pages/73d23b/
categories:
  - 设计模式
  - 行为型模式
tags:
  - 设计模式
  - 行为型模式
---

设计模式就像武功一样，无他，惟手熟尔。

## 😂观察者模式

### 😀定义

**观察者模式**是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。

对象间存在一对多关系。

- 观察者(订阅者) –Watcher
  
  - updata()当事件发生时,具体要做的事情
  
- 发布者 –Dep
  
  - subs数组存储所有的观察者
  
  - addSub()添加观察者
  
  - notify当事件发生,循环所有subs中的观察者的updata方法

- 没有事件中心(没有按事件分类,全部存储在一级数组中)
  
  - 没有事件中心(没有按事件分类,全部存储在一级数组中)
  
  - 发布者和订阅者，则完全不存在耦合

### 😁JS模拟实现

```js
//发布者
class Dep {
  constructor () {
    this.subs = []
  }
  addSub = (sub) => {
    if(sub && sub.updata){
      this.subs.push(sub)
    }
  }
  notify = () => {
    this.subs.forEach((element)=>{
      element.updata()
    })
  }
}

//观察者
class watch {
  updata = () => {
    console.log('观察者')
  }
}

const dep = new Dep()
dep.addSub (new watch())
dep.notify()
```
## 🤣发布订阅

> 在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。

完成订阅发布整个流程需要三个角色：

- 发布者
- 事件中心
- 订阅者
  
### 😃JS代码模拟实现

```js
class Event {
  constructor() {
    // 所有 eventType 监听器回调函数（数组）
    this.listeners = {}
  }
  /**
   * 订阅事件
   * @param {String} eventType 事件类型
   * @param {Function} listener 订阅后发布动作触发的回调函数，参数为发布的数据
   */
  on(eventType, listener) {
    if (!this.listeners[eventType]) {
      this.listeners[eventType] = []
    }
    this.listeners[eventType].push(listener)
  }
  /**
   * 发布事件
   * @param {String} eventType 事件类型
   * @param {Any} data 发布的内容
   */
  emit(eventType, data) {
    const callbacks = this.listeners[eventType]
    if (callbacks) {
      callbacks.forEach((c) => {
        c(data)
      })
    }
  }
}

const event = new Event()
event.on('open', (data) => {
  console.log(data)
})
event.emit('open', { open: true })
```

## 😅区别

一图总结:
<img src="https://cdn.jsdelivr.net/gh/Buzhifanji/imgs-store/blog/subscribe.png"/>

这两者模式，本质并还是一样的，都是对象间存在一对多关系。但发布订阅引入了事件中心，正是这个改进，解决了观察者模式的解解耦问题。

### 😶理解解耦

观察者模式 在添加观察者之前，需要 new watch，也就是说需要知道观察者对象。

而发布订阅者不需要，只需要订阅事件即可。