---
title: 整数
date: 2022-08-03 12:13:50
category:
  - 计算机系统
tag:
  - 读书笔记
  - 计算机系统
---

## 整数的表示

用位来编码整数的两种的不同的方式

- 只能表示非负数
- 能够表示负数、零、正数

### 2.2.1 整型数据类型

- 32位程序上C语言整型数据类型的典型取值范围

| C数据类型      | 最小值                     | 最大值                     |
|----------------|----------------------------|----------------------------|
| [signed] char  | -128                       | 127                        |
| unsigned char  | 0                          | 255                        |
| short          | -32 768                    | 32 767                     |
| unsigned short | 0                          | 65 535                     |
| int            | -2 147 483 648             | 2 147 483 647              |
| unsigned       | 0                          | 4 294 967 295              |
| long           | -2 147 483 648             | 2 147 483 647              |
| unsigned long  | 0                          | 4 294 967 295              |
| int32_t        | -2 147 483 648             | 2 147 483 647              |
| uint32_t       | 0                          | 4 294 967 295              |
| int64_t        | -9 223 372 036 854 775 808 | 9 223 372 036 854 775 807  |
| uint64_t       | 0                          | 18 446 744 073 709 551 615 |

- 64位程序上C语言整型数据类型的典型取值范围

| C数据类型      | 最小值                     | 最大值                     |
|----------------|----------------------------|----------------------------|
| [signed] char  | -128                       | 127                        |
| unsigned char  | 0                          | 255                        |
| short          | -32 768                    | 32 767                     |
| unsigned short | 0                          | 65 535                     |
| int            | -2 147 483 648             | 2 147 483 647              |
| unsigned       | 0                          | 4 294 967 295              |
| long           | -9223 372 036 854 775 808  | 9 223 372 036 854 775 807  |
| unsigned long  | 0                          | 18 446 744 073 709 551 615 |
| int32_t        | -2 147 483 648             | 2 147 483 647              |
| uint32_t       | 0                          | 4 294 967 295              |
| int64_t        | -9 223 372 036 854 775 808 | 9 223 372 036 854 775 807  |
| uint64_t       | 0                          | 18 446 744 073 709 551 615 |

**负数的范围比整数的范围大 1。**

- C语言的整型数据类型的保证的取值范围。C语言标准要求这些数据类型必须至少具有这样的取值范围

| C数据类型      | 最小值                     | 最大值                     |
|----------------|----------------------------|----------------------------|
| [signed] char  | -127                       | 127                        |
| unsigned char  | 0                          | 255                        |
| short          | -32 767                    | 32 767                     |
| unsigned short | 0                          | 65 535                     |
| int            | -32 767                    | 32 767                     |
| unsigned       | 0                          | 65 535                     |
| long           | -2 147 483 647             | 2 147 483 647              |
| unsigned long  | 0                          | 4 294 967 295              |
| int32_t        | -2 147 483 648             | 2 147 483 647              |
| uint32_t       | 0                          | 4 294 967 295              |
| int64_t        | -9 223 372 036 854 775 808 | 9 223 372 036 854 775 807  |
| uint64_t       | 0                          | 18 446 744 073 709 551 615 |

### 2.2.2 无符号数的编码

假设有一个整数数据类型有 w 位，我们可以看将[位向量](2.1信息存储.html#位向量运算)写成 $\overrightarrow{x}$ ，或者写出
$[X_{w-1}, X_{w-2}, \dots, x_0]$，表示向量中的每一位。
把 $\overrightarrow{x}$  看做一个二进制表示的数，就获得了 $\overrightarrow{x}$  的无符号表示。在这个编码中，每个 $x_i$ 都取值 0 或 1。

:::: info 无符号数编码的定义

对向量 $\overrightarrow{x}$  = $[X_{w-1}, X_{w-2}, \dots, x_0]$:

::: center
$B2U_w(\overrightarrow{x})\stackrel{.}{=} \displaystyle\sum_{i=0}^{w-1}x_i2^i$
:::

::::

向量到整数的映射：

$B2U_4([0001]) = 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0 = 0 + 0 + 0 + 1 = 1$

$B2U_4([0101]) = 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 0 + 4 + 0 + 1 = 5$

$B2U_4([1011]) = 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = 8 + 0 + 2 + 1 = 11$

$B2U_4([1111]) = 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = 8 + 4 + 2 + 1 = 15$

w位所能表示的范围：

- 最小位向量 [00...0],也就是整数值0
- 最大位向量 [11...1],也就是整数值$2^w - 1$

### 2.2.3补码编码

补码将最高有效位解释为**负权**。

:::: info 补码编码的定义

对向量 $\overrightarrow{x}$  = $[X_{w-1}, X_{w-2}, \dots, x_0]$:

::: center
$B2T_w(\overrightarrow{x})\stackrel{.}{=}-x_{w-1}2^{w-1} + \displaystyle\sum_{i=0}^{w-2}x_i2^i$
:::

::::

最高有效位 $x_{w-1}$ 也称为*符号位*，它的权重为 $-2^{w-1}$，是无符号表示中权重的负数。符号位设置为 1 时，表示值为负，设置 0 时，表示值为正。

向量到整数的映射：

$B2T_4([0001]) = -0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0 = 0 + 0 + 0 + 1 = 1$

$B2T_4([0101]) = -0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 0 + 4 + 0 + 1 = 5$

$B2T_4([1011]) = -1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = -8 + 0 + 2 + 1 = -5$

$B2T_4([1111]) = -1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = -8 + 4 + 2 + 1 = -1$

w位所能表示的范围：

- 最小位向量 [10...0],也就是整数值$-2^{w - 1}$
- 最大位向量 [01...1],也就是整数值$2^{w - 1} - 1$

补码的特殊性：
- 范围不对称：$|TM_{in}| = |TM_{ax}| + 1$ (原因：一半位的模式表示负数，另一半表示非负数，而0是非负数)
- 最大值两倍大一点：$UM_{ax_w} = 2TM_{ax_w} + 1$ 

### 2.2.4 有符号数和无符号之间的转换

- 补码转为无符号数

:::: info 补码转为无符号数
对满足 $TM_{in_w}\leq x \leq TM_{ax_w}$ 的 x 有：

::: center
$$
T2U_w(x) = \begin{cases}
x + x^w,\quad x < 0 \\
x,\quad x \geq 0
\end{cases}
$$
:::
::::

例子：$T2U_16(-12345) = -12345 + 2^{16} = 53191$

- 无符号数转补码

:::: info 无符号数转补码
对满足 $0\leq u \leq uM_{ax_w}$ 的 u 有：

::: center
$$
U2T_w(u) = \begin{cases}
u,\quad u \leq TM_{ax_w} \\
u - 2^w,\quad u > TM_{ax_w}
\end{cases}
$$
:::
::::

### 2.2.5 扩展整数

一个常见的运算是在不同字长的整数之间转换，同时又保持数值的不变。我们通过扩展来实现从一个较小的数据类型转换到一个较大的类型。
- 扩展无符号数

根据[无符号数](#222-无符号数的编码)的定义，扩展位 0 即可。
- 扩展补码数

如果最高有效位为 0，扩展位 0 即可。

如果最高有效位为 去，扩展扩展位 1。
::: info 例子
下面都是 -5 的补码表示

[1011]

[11011]

[111011]
:::

### 2.2.6 截取数字

上面我们把一个较小的数据类型转换为较大的数据类型，那么较大的数据类型转换为较小的数据就要通过截取数字来实现。

- 截断无符号数
将一个 w 位的无符号数，截断成 k 位，丢弃最高的 w - k 位。截断操作对应取模运算。以十进制数字为例子

$$123 456 \quad mod \quad 10^3$$
$$
1*10^5 + 2*10^4 + 3*10^3 + \underbrace{4*10^2 + 5*10^1 + 6*10^0}_{\text{456}}
$$

- 截断补码数值

有符号数分为两步走：

1. 进去截取k位取模操作（与截断无符号数相同操作）
2. 将取模结果无符号数转换有符号数

## 整数的运算
### 2.3.1 无符号加法
无符号编码是有取值范围的，其它最大值为$2^w$，超过最大范围的时候就溢出了。

:::: info 无符号数加法

对满足 $0 \leq x, y \leq 2^w$ 的 x 和 y 有:

::: center
$x + \frac{u}{w}y = \begin{cases}
x + y,\quad x + y < 2^w  \space正常\\
x + y - 2^w,\quad 2^w \leq x + y < 2^{w+1} \space溢出
\end{cases}$
:::

::::

C 语言判断无符号加法是否溢出
```c
int uadd_ok(unsigned x, unsigned y) {
  unsigned sum = x + y;
  if (sum >= x) {
    return 1;
  } else {
    return 0; // 溢出
  }
}
```
### 2.3.2 补码加法

:::: info 补码加法

对满足 $-2^{w-1} \leq x, y \leq 2^{w-1} - 1$ 的 x 和 y 有:

::: center
$x + \frac{t}{w}y = \begin{cases}
x + y - 2^w,\quad 2^{w-1} \leq x + y  \space正溢出\\
x + y,\quad -2^{w-1} \leq x + y \leq 2^{w-1} \space 正常 \\
x + y + 2^w,\quad x + y < -2^{w-1} \space 负溢出
\end{cases}$
:::

::::

检测补码加法是否溢出

- 正溢出

当两个正数相加的和为负，就正溢出。

::: center
$x \geq0,\space y \geq0$

$x + y < 0 \space 正溢出$
:::
- 负溢出

当两个负数相加的和为正，就负溢出。

::: center
$x \leq0,\space y \leq0$

$x + y > 0 \space 负溢出$
:::
### 2.3.3 补码减法

[加法逆元](https://zh.wikipedia.org/zh-sg/%E5%8A%A0%E6%B3%95%E9%80%86%E5%85%83)也就相反数。

::: center
对于
$x + x^{\lq}  = x^{\lq} + x = 0$
:::

### 2.3.4 无符号乘法
### 2.3.5 补码乘法
### 2.3.6 乘以常数