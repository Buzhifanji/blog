---
title: 判断字符串括号是否合法
date: 2022-03-04 17:01:57
permalink: /pages/7796ac/
categories:
  - leetcode
  - 栈
tags:
  - 算法 
  - 栈
---

<iframe :src="$withBase('/markmap/data-structure/stack/stack.html')" width="100%" height="400" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>

## 题目
</br>

<Badge text="【题目】"/>字符串中只有字符'('和')'。合法字符串需要括号可以配对。比如

输入："()"

输出：true

<Badge type="warning" text="【解释】"/>：()，()()，(())是合法的。)(，()(，(()是非法的。

### 规律

（1）每个左括号'('或者右括号')'都完成**配对**，才是合法的。

（2）配对可以通过**消除法**来消掉合法的括号，如果最后没有任何字符了，那么就是合法字符串。

（3）奇数长度的字符串总是非法的。

### 边界

- 字符串为空

- 字符串只有 1 个或者奇数个

- 字符串是"(((())))"嵌套很多层的是否可以处理

### JS代码实现

```js
function isValid(s) {
  // 处理边界
  if (!s) {
    return false;
  }
  const len = s.length;
  if (len % 2 === 1) {
    // 长度为奇数，不可能是一个有效的合法字符
    return false;
  }
  // 消除法的主要核心逻辑:
  const stack = [];
  const isEmpty = () => stack.length === 0;
  for (let i = 0; i < len; i++) {
    const item = s[i];
    if (item === "(") {
      // 入栈
      stack.push(item);
    } else if (item === ")") {
      if (isEmpty()) {
        // 出栈失败
        return false;
      }
      // 出栈
      stack.pop();
    }
  }

  return isEmpty();
}

// test
console.log(isValid("()()(())"));
console.log(isValid("()()(()"));
```

### 复杂度分析

每个字符只入栈一次，出栈一次，所以时间复杂度为 O(N)，而空间复杂度为 O(N)，因为最差情况下可能会把整个字符串都入栈。

### 深度扩展

栈中元素都相同时，实际上没有必要使用栈，只需要记录栈中元素个数

```js
/*****
 * ** =========== 深度优化 ==========
 * 栈中相邻的内容相同引入计数，这样就可以不用入栈了，减少内存消耗
 * ***********/
function isValid_deep(s) {
  // 处理边界
  if (!s) {
    return false;
  }
  const len = s.length;
  if (len % 2 === 1) {
    // 长度为奇数，不可能是一个有效的合法字符
    return false;
  }
  // 消除法的主要核心逻辑:
  let leftBraceNum = 0; // 记录相邻相同的内容个数
  const isEmpty = () => leftBraceNum === 0;
  for (let i = 0; i < len; i++) {
    const item = s[i];
    if (item === "(") {
      // 如果是'('，那么压栈
      leftBraceNum++;
    } else if (item === ")") {
      // 如果是')'，那么就尝试弹栈
      if (isEmpty()) {
        // 如果弹栈失败，那么返回false
        return false;
      }
      // 出栈
      leftBraceNum--;
    }
  }

  return isEmpty();
}

console.log("==== isValid_deep ====");
console.log(isValid_deep("()()(())"));
console.log(isValid_deep("()()(()"));

```

### 广度优化

栈中只存放了一个维度的信息：左括号'('和右括号')'。如果栈中的内容变得更加丰富一点，就可以得到下面这道扩展题。

[有效括号](20.%20有效的括号.md)

```js
/*****
 * ** =========== 广度优化 ==========
 * 引入不同的元素
 * ***********/
function isValid_width(s) {
  // 处理边界
  if (!s) {
    return false;
  }
  const len = s.length;
  if (len % 2 === 1) {
    // 长度为奇数，不可能是一个有效的合法字符
    return false;
  }
  // 消除法的主要核心逻辑:
  const stack = [];
  const isEmpty = () => stack.length === 0;
  for (let i = 0; i < len; i++) {
    const item = s[i];
    if (item === "(" || item === "{" || item === "[") {
      // 入栈
      stack.push(item);
    } else if (item === ")") {
      // 出栈
      const result = stack.pop();
      if (!result || result !== "(") {
        return false;
      }
    } else if (item === "}") {
      // 出栈
      const result = stack.pop();
      if (!result || result !== "{") {
        return false;
      }
    } else if (item === "]") {
      // 出栈
      const result = stack.pop();
      if (!result || result !== "[") {
        return false;
      }
    }
  }

  return isEmpty();
}

console.log("==== isValid_width ====");
console.log(isValid_width("()()(())({{[]}}[])"));
console.log(isValid_width("()()(()"));
```