---
title:  二叉树的中序遍历
date: 2022-03-20 16:07:14
permalink: /pages/12f998/
categories:
  - 算法
  - 栈
tags:
  - 算法
  - 栈
---

给定一个二叉树的根节点 root ，返回它的 **中序** 遍历。



## 理解二叉树的中序遍历

二叉树的中序遍历的记忆法则是“左根右"，即先遍历左子树节点，再遍历根节点，再遍历右子树节点

例子：

<img src="https://cdn.jsdelivr.net/gh/Buzhifanji/imgs-store/blog/binary-tree-preorder-traversal.png"/>

前序遍历的结果是：【D, B, E, A, F, C, G】

## 解答

### 1.模拟

<iframe :src="$withBase('/markmap/data-structure/stack/binary-tree-preorder-traversal.html')" width="100%" height="400" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>

二叉树中序遍历是“左根右"，那么结果就是：【D, B, E, A, F, C, G】

模拟过程应该是： 
- B -> D -> E 当作整体 B; 
- C -> F -> G当作整体 C;
- A -> B -> C 当作整体 A

先是处理根节点的左子树B，B有子节点，则是处理B的左子树D，D没有子树，所以是 D, B, E

处理完左子树B完后，就则就到了根节点A，然后是根节点右子树C,

C节点有左子树E,则先处理F，然后是C节点，最好是C的右子树G。

### 2.规律

左子树被父树和右子树**消除**掉

### 3.匹配

遇到匹配就应该想到[栈数据结构](1.判断字符串括号是否合法.md)

### 4.边界

根节点为空，直接返回一个空数组

### JS实现

```js
function inorderTraversal(root) {
  const result = []

  // 边界
  if(!root) return result

  const stack = []
  
  while(root || stack.length) {
    // 一直找左节点，直到没有左节点为止
    while(root) {
      stack.push(root)
      root = root.left
    }
    const now = stack.pop()
    result.push(now.val)
    
    root = now.right // 处理右子节点
  }

  return result
}
```

leetcode: [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)