---
title:  二叉树的前序遍历
date: 2022-03-20 14:32:20
permalink: /pages/f79bac/
categories:
  - 算法
  - 栈
tags:
  - 算法
  - 栈
---

给你二叉树的根节点 root ，返回它节点值的 **前序** 遍历。

## 理解二叉树的前序遍历

二叉树的前序遍历的记忆法则是“根左右"，即先遍历根节点，再遍历左子树节点，再遍历右子树节点。

例子：

<img src="https://cdn.jsdelivr.net/gh/Buzhifanji/imgs-store/blog/binary-tree-preorder-traversal.png"/>


前序遍历的结果是：【A, B, D, E, C, F, G】

## 解答

### 1.模拟

<iframe :src="$withBase('/markmap/data-structure/stack/binary-tree-preorder-traversal.html')" width="100%" height="400" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>

二叉树前序遍历是“根左右"，那么结果就是：A -> B -> D -> E -> C -> F -> G

模拟过程应该是： 
- B -> D -> E 当作整体 B; 
- C -> F -> G当作整体 C;
- A -> B -> C 当作整体 A

先是跟节点A，然后是左子树B，B有子节点，继续处理B的子树D、E。

左子树B都处理完后，就处理右子树C的子树F、G。

把每个树当作一个整体，如果有子树，则记录父树结果，并且消除子树。

### 2.规律

子树会**消除**父树

### 3.匹配

遇到匹配就应该想到[栈数据结构](1.判断字符串括号是否合法.md)

### 4.边界

根节点为空，直接返回一个空数组

### JS实现

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function preorderTraversal (root) {
  const result = []

  // 边界
  if(!root) return result

  const stack = []
  stack.push(root)

  while(stack.length) {
    const {val, left, right} = stack.pop()
    if(val) result.push(val)
    if(right) stack.push(right) // 先入 子右树
    if(left) stack.push(left) // 后入 子左数
  }

  return result
}
```
leetcode: [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)