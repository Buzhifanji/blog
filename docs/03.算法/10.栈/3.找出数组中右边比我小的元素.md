---
title: 找出数组中右边比我小的元素
date: 2022-03-07 18:11:52
permalink: /pages/26a51f/
categories:
  - leetcode
  - 栈
tags:
  - 算法
  - 单调栈 
---

<iframe :src="$withBase('/markmap/data-structure/stack/single-stack.html')" width="100%" height="400" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>

## 找出数组中右边比我小的元素
</br>
<Badge text="【题目】"/>一个整数数组 A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。

输入：[5, 2]

输出：[1, -1]

<Badge type="warning" text="【解释】"/>: 因为元素 5 的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。

### 例子

输入： [1, 2, 4, 9, 4, 0, 5]

### 规律

这里我们是照着题意去寻找一个右边比它小的数的下标。可以发现，A[4] = 4 及 A[5] = 0，这两个数字多次被用到。并且：

- A[4] 发现有左边 A[3]，A[3] 就匹配成功；

- 结合 A[5] = 0 的例子，我们发现它会把比它大的数都进行匹配成功，但是 A[3] 除外；

- A[3] 可以认为是匹配成功之后，被 A[4]消除了。
  
**这时可以总结出：一个数总是想与左边比它大的数进行匹配，匹配到了之后，小的数会消除掉大的数。**

### 模拟运行

Step 1. 首先将 A[0] = 1 的下标 0 入栈。

Step 2. 将 A[1] = 2 的下标 1 入栈。满足单调栈。

Step 3. 将 A[2] = 4 的下标 2 入栈。满足单调栈。

Step 4. 将 A[3] = 9 的下标 3 入栈。满足单调栈。

Step 5. 将 A[4] = 4 的下标 4 入栈时，不满足单调性，需要将 A[3] = 9 从栈中弹出去。下标 4 将栈中下标 3 弹出栈，记录 A[3] 右边更小的是 index = 4。

Step 6. 将 A[5] = 0 的下标 5 入栈时，不满足单调性，需要将 A[4] = 4 从栈中弹出去。下标 5 将下标 4 弹出栈，记录 A[4] 右边更小的是 index = 5。A[5] = 0 会将栈中的下标 0, 1, 2 都弹出栈，因此也需要记录相应下标右边比其小的下标为 5，再将 A[5] = 0 的下标 5 放入栈中。

Step 7. 将 A[6] = 5 的下标 6 放入栈中。满足单调性。

Step 8. 此时，再也没有元素要入栈了，那么栈中的元素右边没有比其更小的元素。因此设置为 -1.

### JS代码实现

```js
function findRightSmall(list) {
  const result = [];
  const stack = []; // 单调栈
  const peek = () => stack[stack.length - 1]; // 取栈顶元素
  for (let i = 0; i < list.length; i++) {
    const item = list[i];
    while (stack.length && list[peek()] > item) {
      // 消除的时候，记录一下被谁消除了
      result[peek()] = i;
      // 消除时候，值更大的需要从栈中消失
      stack.pop();
    }
    stack.push(i);
  }
  // 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。
  while (stack.length) {
    result[peek()] = -1;
    stack.pop();
  }
  return result;
}

// test
console.log("=== findRightSmall ====");
console.log(findRightSmall([5, 2]));
console.log(findRightSmall([1, 2, 4, 9, 4, 0, 5]));
```
### 复杂度分析

每个元素只入栈一次，出栈一次，所以时间复杂度为 O(N)，而空间复杂度为 O(N)，因为最差情况可能会把所有的元素都入栈。

## 数组中右边第一个比我大的元素的位置

与 找出数组中右边比我小的元素 相比，只需要在栈弹出的时候，修改为栈顶元素小于当前元素即可。

```js
function findRightBig(list) {
  const result = [];
  const stack = []; // 单调栈
  const peek = () => stack[stack.length - 1]; // 取栈顶元素
  for (let i = 0; i < list.length; i++) {
    const item = list[i];
    while (stack.length && list[peek()] < item) {
      // 消除的时候，记录一下被谁消除了
      result[peek()] = i;
      // 消除时候，值更大的需要从栈中消失
      stack.pop();
    }
    stack.push(i);
  }
  // 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。
  while (stack.length) {
    result[peek()] = -1;
    stack.pop();
  }
  return result;
}

// test
console.log("=== findRightBig ====");
console.log(findRightBig([5, 2]));
console.log(findRightBig([1, 2, 4, 9, 4, 0, 5]));
```

## 数组中元素左边离我最近且比我小的元素的位置



## 数组中元素左边离我最近且比我大的元素的位置