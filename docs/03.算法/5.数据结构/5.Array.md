---
title: Array | 数组
date: 2022-06-17 18:53:06
permalink: /pages/8f6f25/
categories:
  - 算法
  - 数据结构
tags:
  - 算法
  - 数据结构
---

# 序言

如果你有过开发经验，数组对于你来说一定不陌生，因为大部分编程语言都内置了数组这种数据结构。

对于一种数组结构，通常我们都会**时间复杂度**和**空间复杂度**来进行分析，进而来判断这个数组结构使用的是否合理。

那么对于数组，为什么增加和删除的时候时间复杂度为 O(n) 呢，而读取的时候，时间复杂度为 O(1) 。

如果你已经知道这个问题的答案，恭喜你，你已经掌握了数组这个数据结构。

## 高效率的读取

我们是利用下标来读取数组里的数据，比如：

```javascript
const arr = ['a', 'b', 'c']
// 读取
console.log(arr[0])
console.log(arr[1])
```

假设 arr 数组起始地址为 0x00，那么第二个元素的地址为 0x01，第三个元素的地址为 0x03。

在物理结构上，数组是**连续性**的。随机读取某个元素的时候，只需要执行简单的数学运算就知道了。

数组读取的时候效果很高，时间复杂度为 O(1), 因为在数组里可以快速找到任何一个元素。

## 缓慢的修改

数组在创建的时候，大小是固定的，因为指定大小，才能知道分配多少内存空间。

既然大小是固定的，数组不够用的时候，怎么办？对于这个问题，也许你会简单，不够就加呗！
是的，计算机就是这么处理，对于数组内存超了的时候，需要进行**扩容**处理。

每次新增元素的时候，判断内存空间够不够，如果不够，就申请一个更大的内存，然后把之前的元素都移动到新的内存里去。
这就是为什么增加的时候，最坏时间复杂度为 O(n)。

有了扩容，相对于就有**缩容**，不能只增加，不减少，要不然申请了100M内存，但只存1k大小的元素，这不存粹浪费内存空间嘛！

每次在删除元素的时候，就判断内存空间是否过于大，如果太大了，就申请一个更小的内存空间，然后把之前的元素移动到新内存里去。
为了不浪费内存空间，数组删除的时候，最坏时间复杂度为 O(n)。

## 动态数组

上面我们讲到数组长度是固定，增加和删除的还需要考虑内存问题。有没有办法让我们不考虑内存，只进行数组操作。这种数组叫做**动态数组**。但其本质上并改变数组性质，只能自动帮住我们解决了内存问题。是的，你想的没有错，JavaScript里的数组就是动态数组。

## 总结

数组是一块连续的内存空间，在创建的时候就确定了大小。

数组的优点是读取效率高，时间复杂度为 O(1)。

缺点是修改的效率低，时间复杂度为 O(n)。