---
title: 大鱼吃小鱼
date: 2022-03-07 16:50:52
permalink: /pages/0255ab/
categories:
  - leetcode
  - 栈
tags:
  - 算法
---

<iframe :src="$withBase('/markmap/data-structure/stack/stack.html')" width="100%" height="400" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>

## 题目
</br>
<Badge text="【题目】"/> 在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i 条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件:

  1. 所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离；
  2. 当方向相对时，大鱼会吃掉小鱼；
  3. 鱼的大小都不一样。

输入：Size = [4, 2, 5, 3, 1], Dir = [1, 1, 0, 0, 0]

输出：3

请完成以下接口来计算还剩下几条鱼？

### 分析

大鱼吃掉小鱼的时候，可以认为是一种**消除**行为。只不过与括号匹配时的行为不一样：

- 括号匹配是会**同时**把左括号与右括号消除掉；

- 大鱼吃小鱼，**只会把小鱼**消除掉。

### 规律

- 如果两条鱼**相对而游时，那么较小的鱼会被吃掉**；

- **其他情况**没有鱼被吃掉。

### 边界

- 所有的鱼都朝着一个方向游；

- 一条鱼吃掉了其他的所有鱼。

### JS代码实现

#### 栈中存放内容

```js
/***
 * 大鱼吃小鱼
 *
 * 栈中存放内容
 */
function solution(fishSize, fishDirection) {
  // 如果鱼的数量小于等于1，那么直接返回鱼的数量
  const len = fishSize.length;
  if (len <= 1) {
    return len;
  }

  const stack = [],
    left = 0, // 0表示鱼向左游
    right = 1; // 1表示鱼向右游
  let direction = fishDirection[0]; // 栈中鱼的方向，栈中只有一个方法，相反方向的鱼，大鱼会打小鱼吃掉

  for (let i = 0; i < len; i++) {
    // 当前鱼的情况：1，游动的方向；2，大小
    const curFishDirection = fishDirection[i];
    const curFishSize = fishSize[i];
    // 当前的鱼是否被栈中的鱼吃掉了
    let hasEat = false;
    while (stack.length && curFishDirection !== direction) {
      const last = stack[stack.length - 1];
      if (last < curFishSize) {
        stack.pop();
      } else {
        hasEat = true;
        break;
      }
    }

    if (stack.length === 0) {
      direction = curFishDirection;
    }

    if (!hasEat) {
      stack.push(curFishSize);
    }
  }

  return stack.length;
}

// test
console.log("=== solution ====");
console.log(solution([4, 2, 5, 3, 1], [1, 1, 0, 0, 0]));
console.log(solution([4, 2, 5, 3, 1], [0, 1, 0, 0, 0]));
```

#### 栈中存放索引

```js
/***
 * 大鱼吃小鱼
 *
 * 栈中存放索引
 */
function solution_index(fishSize, fishDirection) {
  // 如果鱼的数量小于等于1，那么直接返回鱼的数量
  const len = fishSize.length;
  if (len <= 1) {
    return len;
  }

  const stack = [],
    left = 0, // 0表示鱼向左游
    right = 1; // 1表示鱼向右游
  let direction = fishDirection[0]; // 栈中鱼的方向，栈中只有一个方法，相反方向的鱼，大鱼会打小鱼吃掉

  for (let i = 0; i < len; i++) {
    // 当前鱼的情况：1，游动的方向；2，大小
    const curFishDirection = fishDirection[i];
    const curFishSize = fishSize[i];
    // 当前的鱼是否被栈中的鱼吃掉了
    let hasEat = false;
    while (stack.length && curFishDirection !== direction) {
      const last = stack[stack.length - 1];
      if (fishSize[last] < curFishSize) {
        stack.pop();
      } else {
        hasEat = true;
        break;
      }
    }

    if (stack.length === 0) {
      direction = curFishDirection;
    }

    if (!hasEat) {
      stack.push(i);
    }
  }

  return stack.length;
}

// test
console.log("=== solution_index ====");
console.log(solution_index([4, 2, 5, 3, 1], [1, 1, 0, 0, 0]));
console.log(solution_index([4, 2, 5, 3, 1], [0, 1, 0, 0, 0]));
```

### 复杂度分析

每只鱼只入栈一次，出栈一次，所以时间复杂度 为 O(N)，而空间复杂度为 O(N)，因为最差情况下可能把所有的鱼都入栈。