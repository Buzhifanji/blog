import{_ as n,X as s,Y as a,a1 as t}from"./framework-7f72c1b4.js";const e={},o=t(`<blockquote><p>垃圾回收用于描述<strong>查找</strong>和<strong>删除</strong>那些不再被其他对象引用 (en-US)的对象 处理过程。 换句话说，垃圾回收是删除任何其他对象未使用的对象的过程。 垃圾收集通常缩写为 &quot;<strong>GC</strong>&quot;，是JavaScript中使用的内存管理系统的基本组成部分。</p></blockquote><p>js中的内存管理是自动的,每当我们去创建一个对象的时候会自动去分配内存空间,后面通过判断确认其是否是垃圾。</p><p>需要注意的是，当垃圾回收工作的时候,它会<strong>阻塞js代码的执行</strong>。</p><h2 id="js中的垃圾有哪些" tabindex="-1"><a class="header-anchor" href="#js中的垃圾有哪些" aria-hidden="true">#</a> js中的垃圾有哪些?</h2><p>判断js对象是否为垃圾以下两个方面进行判断：</p><ul><li><strong>对象不再被引用</strong></li><li><strong>对象不能从根上访问到时</strong></li></ul><p>不再被引用，说明使用价值，自然成了垃圾。</p><p>从跟上能访问到的对象称为<strong>可达对象</strong>，不能访问的是<strong>不可达对象</strong>，这里的<code>跟</code>可以理解为全局作用域。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    name <span class="token operator">=</span> <span class="token string">&#39;li&#39;</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is a good boy</span><span class="token template-punctuation string">\`</span></span>
<span class="token punctuation">}</span>
<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 函数调用完成之后 name不再被使用,并且外部无法访问。name成为了垃圾</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="gc算法" tabindex="-1"><a class="header-anchor" href="#gc算法" aria-hidden="true">#</a> GC算法</h2><p>GC是一种机制,查找垃圾,释放,回收,分配空间时所遵循的规则叫GC算法。</p><h3 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数" aria-hidden="true">#</a> 引用计数</h3><p>记录变量对象引用的次数，当增加一次引用是，记录值加一；减少一次引用时，记录值减一。当引用次数为 0 ，就成为了垃圾。</p><p>核心思想：<em>设置引用数,判断当前引用数是否为 0</em></p><p><strong>优点：</strong></p><ul><li>发现垃圾立即回收,减少程序卡顿时间</li></ul><p><strong>缺点：</strong></p><ul><li>需要时刻监听引用数的变化，而且数值需要计算，所以<strong>时间开销大</strong></li><li>对于循环引用的对象的引用数不会为0，所以<strong>无法回收循环引用的对象</strong></li></ul><h3 id="标记清除" tabindex="-1"><a class="header-anchor" href="#标记清除" aria-hidden="true">#</a> 标记清除</h3><p>对所有对象进行两次遍历，第一次遍历将所有<strong>可达对象</strong>标记为活动对象，无法被标记。第二次遍历清楚没有被标记的对象。回收后的空间会放到空闲链表中.完成一次垃圾回收之后清除所有标记</p><p><strong>优点：</strong></p><ul><li>可以回收收循环引用的对象（解决了引用计数的一个缺点）</li></ul><p><strong>缺点：</strong></p><ul><li>容易产生<strong>空间碎片化</strong>.由于垃圾对象在地址上是不连续的,所以回收后的空间也不是连续的,造成后续在使用的时候就要匹配内存大小.</li><li>不能立即回收垃圾对象,因为它要在最后才能清除</li></ul><h3 id="标记整理" tabindex="-1"><a class="header-anchor" href="#标记整理" aria-hidden="true">#</a> 标记整理</h3><p>可以看做是标记清除的增强版,只不过在清除阶段会先执行整理内存空间,移动对象的位置让地址产生连续.</p><p><strong>优点：</strong></p><ul><li>解决了空间碎片化的问题</li></ul><p><strong>缺点：</strong></p><ul><li>不能立即回收垃圾对象</li></ul><h3 id="分代回收" tabindex="-1"><a class="header-anchor" href="#分代回收" aria-hidden="true">#</a> 分代回收</h3>`,31),i=[o];function r(p,l){return s(),a("div",null,i)}const u=n(e,[["render",r],["__file","GC.html.vue"]]);export{u as default};
