(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{351:function(e,t,a){"use strict";a.r(t);var r=a(3),v=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("简述Vue的响应式原理，用自己的话表述出来，解决面试的时候表达不清楚的问题。")]),e._v(" "),t("h2",{attrs:{id:"定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[e._v("#")]),e._v(" 定义")]),e._v(" "),t("p",[e._v("响应式是指组件中的data数据发生变化后，视图也会随着发生改变。")]),e._v(" "),t("p",[e._v("vue2 的实现方式是：Object.defineProperty实现数据劫持 + "),t("RouterLink",{attrs:{to:"/pages/73d23b/"}},[e._v("观察者模式")]),e._v(" ，而Vue3 主要通过Proxy这个API实现。")],1),e._v(" "),t("h2",{attrs:{id:"vue2-实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2-实现原理"}},[e._v("#")]),e._v(" vue2 实现原理")]),e._v(" "),t("h3",{attrs:{id:"转换成get、set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#转换成get、set"}},[e._v("#")]),e._v(" 转换成get、set")]),e._v(" "),t("p",[e._v("在vue initState的时候，通过Object.defineProperty这个API，把组件里的data数据转换成getter、setter，同时也会创建Dep来收集该data的Watcher。")]),e._v(" "),t("h3",{attrs:{id:"搜集依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#搜集依赖"}},[e._v("#")]),e._v(" 搜集依赖")]),e._v(" "),t("p",[e._v("在组件渲染的时候，会创建一个对应的Watcher，并将Dep.target标识为当前的Watcher。此时，如果视图使用了data中的数据，就会Data触发get方法，然后调用Dep.addSub将Watcher搜集起来。")]),e._v(" "),t("h3",{attrs:{id:"更新依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#更新依赖"}},[e._v("#")]),e._v(" 更新依赖")]),e._v(" "),t("p",[e._v("数据更新的时候，就会触发data的set方法，然后调用Dep.notify通知用到该data的Watcher去更新DOM。")]),e._v(" "),t("h2",{attrs:{id:"vue2-如何处理数组响应式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2-如何处理数组响应式"}},[e._v("#")]),e._v(" vue2 如何处理数组响应式")]),e._v(" "),t("p",[e._v("Object.defineProperty不能监听数组长度的变化。")]),e._v(" "),t("p",[e._v("因为性能问题，未采用监听数组每个下标的方法，而是重写会影响数组方法。")]),e._v(" "),t("p",[e._v("vue在ininState的时候，会在初始化Observer类的时候会创建一个Dep来收集依赖，并且为每个响应式数据定义一个__ob__的属性。")]),e._v(" "),t("p",[e._v("在遇到处理数组转换成响应式的时候，vue首先通过Object.defineProperty拦截数组原型的push、pop、shift、unshift、splice、slice、reverse这7个方法，然后在这些方法内部调用__ob__.dep.notify方法。")]),e._v(" "),t("h2",{attrs:{id:"vue3-实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3-实现原理"}},[e._v("#")]),e._v(" vue3 实现原理")]),e._v(" "),t("p",[e._v("vue3在setupComponent的时候，会调用composition-api，处理options得到响应式对象，并且会创建一个负责渲染的effect。")]),e._v(" "),t("p",[e._v("在组件渲染的时候，会触发get，调用track方法，然后通过Proxy对象和key形成对应的deps，将负责渲染的effect存入deps中。")]),e._v(" "),t("p",[e._v("数据更新的时候，会触发set，调用trigger方法，然后通过Proxy对象和key找到对应的deps，然后把deps分类成功computedRunners和effect。需要调度的，则会放入调度中；不需要的就会依次执行。")]),e._v(" "),t("h2",{attrs:{id:"vue3和vue2响应式原理对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3和vue2响应式原理对比"}},[e._v("#")]),e._v(" vue3和vue2响应式原理对比")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("vue2采用 Object.defineProperty 来劫持整个对象，vue3采用的是proxy来劫持对整个，这两个api相同之处就是只能劫持对象本身，不能劫持子对象的变化。对于子对象，vue2是通过深度遍历所有属性，而vue3是在对象属性被访问的时候，才会递归执行下一步的reactive。vue3实现了延迟定义子对象响应式的实现，这样做可以较大的提高性能。")])]),e._v(" "),t("li",[t("p",[e._v("vue3解决了vue2中对属性的添加、删除动作不能监测，对数组基于下标的修改、数组length修改不能监测的问题。")])]),e._v(" "),t("li",[t("p",[e._v("vue3实现了对Map、Set、WeakMap 和 WeakSet 的支持")])])]),e._v(" "),t("h2",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6857669921166491662#heading-0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("图解 Vue 响应式原理"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6844903916954451982#heading-5",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue原理解析（七）：全面深入理解响应式原理(下)-数组进阶篇"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.cn/post/6858899262596448270#heading-25",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue3.0 响应式原理(超详细)"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=v.exports}}]);