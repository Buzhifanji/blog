(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{371:function(t,s,a){"use strict";a.r(s);var n=a(3),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"序言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#序言"}},[t._v("#")]),t._v(" 序言")]),t._v(" "),s("p",[t._v("如果你有过开发经验，数组对于你来说一定不陌生，因为大部分编程语言都内置了数组这种数据结构。")]),t._v(" "),s("p",[t._v("对于一种数组结构，通常我们都会"),s("strong",[t._v("时间复杂度")]),t._v("和"),s("strong",[t._v("空间复杂度")]),t._v("来进行分析，进而来判断这个数组结构使用的是否合理。")]),t._v(" "),s("p",[t._v("那么对于数组，为什么增加和删除的时候时间复杂度为 O(n) 呢，而读取的时候，时间复杂度为 O(1) 。")]),t._v(" "),s("p",[t._v("如果你已经知道这个问题的答案，恭喜你，你已经掌握了数组这个数据结构。")]),t._v(" "),s("h2",{attrs:{id:"高效率的读取"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高效率的读取"}},[t._v("#")]),t._v(" 高效率的读取")]),t._v(" "),s("p",[t._v("我们是利用下标来读取数组里的数据，比如：")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" arr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'a'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'b'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'c'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 读取")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("假设 arr 数组起始地址为 0x00，那么第二个元素的地址为 0x01，第三个元素的地址为 0x03。")]),t._v(" "),s("p",[t._v("在物理结构上，数组是"),s("strong",[t._v("连续性")]),t._v("的。随机读取某个元素的时候，只需要执行简单的数学运算就知道了。")]),t._v(" "),s("p",[t._v("数组读取的时候效果很高，时间复杂度为 O(1), 因为在数组里可以快速找到任何一个元素。")]),t._v(" "),s("h2",{attrs:{id:"飘忽不定的新增"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#飘忽不定的新增"}},[t._v("#")]),t._v(" 飘忽不定的新增")]),t._v(" "),s("p",[t._v("数组在创建的时候，大小是固定的，因为指定大小，才能知道分配多少内存空间。")]),t._v(" "),s("p",[t._v("既然大小是固定的，数组不够用的时候，怎么办？对于这个问题，也许你会简单，不够就加呗！\n是的，计算机就是这么处理，对于数组内存超了的时候，需要进行"),s("strong",[t._v("扩容")]),t._v("处理。")]),t._v(" "),s("p",[t._v("每次新增元素的时候，判断内存空间够不够，如果不够，就申请一个更大的内存，然后把之前的元素都移动到新的内存里去。")]),t._v(" "),s("p",[t._v("当内存足够的时候，往里添加数据即可，反之则要扩容。这就是为什么增加的时候，最坏时间复杂度为 O(n)。")]),t._v(" "),s("h2",{attrs:{id:"缓慢的删除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓慢的删除"}},[t._v("#")]),t._v(" 缓慢的删除")]),t._v(" "),s("p",[t._v("有了扩容，相对于就有"),s("strong",[t._v("缩容")]),t._v("，不能只增加，不减少，要不然申请了100M内存，但只存1k大小的元素，这不存粹浪费内存空间嘛！")]),t._v(" "),s("p",[t._v("每次在删除元素的时候，就判断内存空间是否过于大，如果太大了，就申请一个更小的内存空间，然后把之前的元素移动到新内存里去。")]),t._v(" "),s("p",[t._v("如果内存刚好呢,就需要把删除位置之后的元素往前移。因为如果只是删除元素，那么删除的位置就会空缺，就会带来两个问题：")]),t._v(" "),s("ul",[s("li",[t._v("造成内存空间浪费")]),t._v(" "),s("li",[t._v("读取的数据不对")])]),t._v(" "),s("p",[t._v("为了不浪费内存空间，数组删除的时候，最坏时间复杂度为 O(n)。")]),t._v(" "),s("h2",{attrs:{id:"遍历修改"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遍历修改"}},[t._v("#")]),t._v(" 遍历修改")]),t._v(" "),s("p",[t._v("修改数组中某个元素的时候，需要经过两个步骤。")]),t._v(" "),s("ol",[s("li",[t._v("遍历找到要修改元素的索引。")]),t._v(" "),s("li",[t._v("根据索引获取元素，然后进行替换操作。")])]),t._v(" "),s("p",[t._v("因为需要遍历，所以数组修改的时候，最坏时间复杂度为 O(n)。")]),t._v(" "),s("h2",{attrs:{id:"动态数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态数组"}},[t._v("#")]),t._v(" 动态数组")]),t._v(" "),s("p",[t._v("上面我们讲到数组长度是固定，增加和删除的还需要考虑内存问题。有没有办法让我们不考虑内存，只进行数组操作。这种数组叫做"),s("strong",[t._v("动态数组")]),t._v("。但其本质上并改变数组性质，只能自动帮住我们解决了内存问题。是的，你想的没有错，JavaScript里的数组就是动态数组。")]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[t._v("数组是一块连续的内存空间，在创建的时候就确定了大小。")]),t._v(" "),s("p",[t._v("数组的优点是读取效率高，时间复杂度为 O(1)。")]),t._v(" "),s("p",[t._v("缺点是新增、修改、删除的效率低，时间复杂度为 O(n)。")])])}),[],!1,null,null,null);s.default=r.exports}}]);