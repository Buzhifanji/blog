(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],l=e[1],c=e[2],p=0,d=[];p<s.length;p++)i=s[p],Object.prototype.hasOwnProperty.call(a,i)&&a[i]&&d.push(a[i][0]),a[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(u&&u(e);d.length;)d.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(r=!1)}r&&(o.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},a={1:0},o=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"0deb6d1d",3:"ea22b157",4:"31b33652",5:"04418901",6:"843b2da6",7:"fb468678",8:"59681a3c",9:"e8580a4e",10:"0b4d2184",11:"dc1cb3ea",12:"d967394e",13:"f592cd76",14:"7ee21c21",15:"8c49e5a5",16:"8fe4367d",17:"3119d0a0",18:"6826c8df",19:"6eed6dfb",20:"41b9ece9",21:"9fdccb3d",22:"f190a408",23:"1aeea479",24:"7eee1cf5",25:"aad995ca",26:"1251cac4",27:"c7694e98",28:"eb0d59c9",29:"fb4ffa09",30:"8619e89a",31:"001de709",32:"1cd8c3ef",33:"61b82884",34:"a20f6c78",35:"9fae0923",36:"660d22fd",37:"5e9c0e49",38:"c4c69c62",39:"a011a149",40:"cd501e13",41:"ea684fc4",42:"23287bc5",43:"ad6626d3",44:"e3f37edd",45:"89d4e301",46:"290cc9b8",47:"049e5aed",48:"aae76436",49:"1b75d852",50:"fae1d5c0",51:"308b7568",52:"708d8916",53:"63d6fac3",54:"d8f7d688",55:"719e7989",56:"b3cab739",57:"1b2854ee",58:"f6e9f39e",59:"df97a477",60:"c3087b2a"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",l.name="ChunkLoadError",l.type=r,l.request=o,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/blog/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;o.push([102,0]),t()}([function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var r=t(28),a=Function.prototype,o=a.bind,i=a.call,s=r&&o.bind(i,i);n.exports=r?function(n){return n&&s(n)}:function(n){return n&&function(){return i.apply(n,arguments)}}},function(n,e,t){"use strict";function r(n,e,t,r,a,o,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):a&&(l=s?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var p=c.beforeCreate;c.beforeCreate=p?[].concat(p,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(2),a=t(46),o=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(a(n),e)}},function(n,e,t){var r=t(68),a="object"==typeof self&&self&&self.Object===Object&&self,o=r||a||Function("return this")();n.exports=o},function(n,e,t){var r=t(4);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(0);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(157),a=t(160);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return o})),t.d(e,"j",(function(){return i})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return p})),t.d(e,"f",(function(){return d})),t.d(e,"l",(function(){return f})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return m})),t.d(e,"k",(function(){return g})),t.d(e,"n",(function(){return y})),t.d(e,"a",(function(){return x}));const r=/#.*$/,a=/\.(md|html)$/,o=/\/$/,i=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(a,"")}function l(n){return i.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function p(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",a=s(n);return o.test(a)?n:a+".html"+t}function d(n,e){const t=n.hash,a=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(a&&t!==a)return!1;return s(n.path)===s(e)}function f(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const a=e.split("/");t&&a[a.length-1]||a.pop();const o=n.replace(/^\//,"").split("/");for(let n=0;n<o.length;n++){const e=o[n];".."===e?a.pop():"."!==e&&a.push(e)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:p(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,r){const{pages:a,themeConfig:o}=t,i=r&&o.locales&&o.locales[r]||o;if("auto"===(n.frontmatter.sidebar||i.sidebar||o.sidebar))return v(n);const s=i.sidebar||o.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?v(n):r?r.map(n=>function n(e,t,r,a=1){if("string"==typeof e)return f(t,e,r);if(Array.isArray(e))return Object.assign(f(t,e[0],r),{title:e[1]});{a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const o=e.children||[];return 0===o.length&&e.path?Object.assign(f(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:o.map(e=>n(e,t,r,a+1)),collapsable:!1!==e.collapsable}}}(n,a,t)):[]}return[]}function v(n){const e=m(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function m(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function y(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function b(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return b(e)-b(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(8),a=t(62),o=t(98),i=t(26),s=t(53),l=TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=r?o?function(n,e,t){if(i(n),e=s(e),i(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=u(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(i(n),e=s(e),i(t),a)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(15),a=t(142),o=t(143),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?a(n):o(n)}},function(n,e,t){var r=t(7).Symbol;n.exports=r},function(n,e,t){var r=t(1),a=t(0),o=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(1),a=t(59),o=t(6),i=t(61),s=t(57),l=t(56),c=a("wks"),u=r.Symbol,p=u&&u.for,d=l?u:u&&u.withoutSetter||i;n.exports=function(n){if(!o(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&o(u,n)?c[n]=u[n]:c[n]=l&&p?p(e):d(e)}return c[n]}},function(n,e,t){var r=t(8),a=t(13),o=t(31);n.exports=r?function(n,e,t){return a.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(147),a=t(148),o=t(149),i=t(150),s=t(151);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(70);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(10)(Object,"create");n.exports=r},function(n,e,t){var r=t(169);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(42);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),u=r.speed,p=r.easing;return l.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,a}(n,u,p)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,i=e.querySelector(r.barSelector),l=n?"-100":o(t.status||0),u=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&d(a),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,o=arguments;if(2==o.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:p(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=p(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=p(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n){n.exports=JSON.parse('{"_from":"vuepress-plugin-comment@^0.7.3","_id":"vuepress-plugin-comment@0.7.3","_inBundle":false,"_integrity":"sha512-CvuBST37snmQGzGD5lMxyw0u2eXWKVPjegfuwlI2+CTs2qWarKX16dVHHLR8DVa/yL5UGT3VuoNETH/zEexl8A==","_location":"/vuepress-plugin-comment","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"vuepress-plugin-comment@^0.7.3","name":"vuepress-plugin-comment","escapedName":"vuepress-plugin-comment","rawSpec":"^0.7.3","saveSpec":null,"fetchSpec":"^0.7.3"},"_requiredBy":["#DEV:/"],"_resolved":"https://registry.npmjs.org/vuepress-plugin-comment/-/vuepress-plugin-comment-0.7.3.tgz","_shasum":"2cff36b8f90896a7f88d494d78458398b1510249","_spec":"vuepress-plugin-comment@^0.7.3","_where":"/home/runner/work/blog/blog","author":{"name":"dongyuanxin"},"bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"bundleDependencies":false,"dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"},"deprecated":false,"description":"Comment plugin in vuepress, such as Gitalk, Valine...","homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"license":"MIT","main":"index.js","name":"vuepress-plugin-comment","repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"version":"0.7.3"}')},function(n,e,t){var r=t(9),a=String,o=TypeError;n.exports=function(n){if(r(n))return n;throw o(a(n)+" is not an object")}},function(n,e,t){var r=t(1),a=t(51).f,o=t(18),i=t(110),s=t(34),l=t(64),c=t(122);n.exports=function(n,e){var t,u,p,d,f,h=n.target,v=n.global,m=n.stat;if(t=v?r:m?r[h]||s(h,{}):(r[h]||{}).prototype)for(u in e){if(d=e[u],p=n.dontCallGetSet?(f=a(t,u))&&f.value:t[u],!c(v?u:h+(m?".":"#")+u,n.forced)&&void 0!==p){if(typeof d==typeof p)continue;l(d,p)}(n.sham||p&&p.sham)&&o(d,"sham",!0),i(t,u,d,n)}}},function(n,e,t){var r=t(4);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(44),a=t(52);n.exports=function(n){return r(a(n))}},function(n,e,t){var r=t(28),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(2),a=r({}.toString),o=r("".slice);n.exports=function(n){return o(a(n),8,-1)}},function(n,e,t){var r=t(1),a=t(34),o=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=o},function(n,e,t){var r=t(1),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(141),a=t(12),o=Object.prototype,i=o.hasOwnProperty,s=o.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(10)(t(7),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(161),a=t(168),o=t(170),i=t(171),s=t(172);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(5),a=t(42),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(i.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(14),a=t(12);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(2),a=t(4),o=t(32),i=Object,s=r("".split);n.exports=a((function(){return!i("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?s(n,""):i(n)}:i},function(n,e,t){var r=t(0),a=t(108),o=TypeError;n.exports=function(n){if(r(n))return n;throw o(a(n)+" is not a function")}},function(n,e,t){var r=t(52),a=Object;n.exports=function(n){return a(r(n))}},function(n,e){n.exports={}},function(n,e,t){var r=t(120);n.exports=function(n){return r(n.length)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,o=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),u=Object.prototype.toString,p=Math.max,d=Math.min,f=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function v(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||o.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,o,i,s,l,c=0,u=!1,m=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(e){var t=r,o=a;return r=a=void 0,c=e,i=n.apply(o,t)}function b(n){return c=n,s=setTimeout(k,e),u?y(n):i}function x(n){var t=n-l;return void 0===l||t>=e||t<0||m&&n-c>=o}function k(){var n=f();if(x(n))return _(n);s=setTimeout(k,function(n){var t=e-(n-l);return m?d(t,o-(n-c)):t}(n))}function _(n){return s=void 0,g&&r?y(n):(r=a=void 0,i)}function w(){var n=f(),t=x(n);if(r=arguments,a=this,l=n,t){if(void 0===s)return b(l);if(m)return s=setTimeout(k,e),y(l)}return void 0===s&&(s=setTimeout(k,e)),i}return e=v(e)||0,h(t)&&(u=!!t.leading,o=(m="maxWait"in t)?p(v(t.maxWait)||0,e):o,g="trailing"in t?!!t.trailing:g),w.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=a=s=void 0},w.flush=function(){return void 0===s?i:_(f())},w}},function(n,e,t){var r=t(8),a=t(30),o=t(104),i=t(31),s=t(29),l=t(53),c=t(6),u=t(62),p=Object.getOwnPropertyDescriptor;e.f=r?p:function(n,e){if(n=s(n),e=l(e),u)try{return p(n,e)}catch(n){}if(c(n,e))return i(!a(o.f,n,e),n[e])}},function(n,e){var t=TypeError;n.exports=function(n){if(null==n)throw t("Can't call method on "+n);return n}},function(n,e,t){var r=t(105),a=t(54);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e,t){var r=t(16),a=t(0),o=t(55),i=t(56),s=Object;n.exports=i?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return a(e)&&o(e.prototype,s(n))}},function(n,e,t){var r=t(2);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(57);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(58),a=t(4);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,a,o=t(1),i=t(106),s=o.process,l=o.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(a=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){var r=t(60),a=t(33);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.23.3",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(2),a=0,o=Math.random(),i=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++a+o,36)}},function(n,e,t){var r=t(8),a=t(4),o=t(97);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(2),a=t(0),o=t(33),i=r(Function.toString);a(o.inspectSource)||(o.inspectSource=function(n){return i(n)}),n.exports=o.inspectSource},function(n,e,t){var r=t(6),a=t(115),o=t(51),i=t(13);n.exports=function(n,e,t){for(var s=a(e),l=i.f,c=o.f,u=0;u<s.length;u++){var p=s[u];r(n,p)||t&&r(t,p)||l(n,p,c(e,p))}}},function(n,e,t){var r=t(119);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(2),a=t(26),o=t(129);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),o(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(19),a=t(152),o=t(153),i=t(154),s=t(155),l=t(156);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=o,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(14),a=t(37);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(173),a=t(12);n.exports=function n(e,t,o,i,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,o,i,n,s))}},function(n,e,t){var r=t(75),a=t(176),o=t(76);n.exports=function(n,e,t,i,s,l){var c=1&t,u=n.length,p=e.length;if(u!=p&&!(c&&p>u))return!1;var d=l.get(n),f=l.get(e);if(d&&f)return d==e&&f==n;var h=-1,v=!0,m=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<u;){var g=n[h],y=e[h];if(i)var b=c?i(y,g,h,e,n,l):i(g,y,h,n,e,l);if(void 0!==b){if(b)continue;v=!1;break}if(m){if(!a(e,(function(n,e){if(!o(m,e)&&(g===n||s(g,n,t,i,l)))return m.push(e)}))){v=!1;break}}else if(g!==y&&!s(g,y,t,i,l)){v=!1;break}}return l.delete(n),l.delete(e),v}},function(n,e,t){var r=t(38),a=t(174),o=t(175);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=a,i.prototype.has=o,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(186),a=t(192),o=t(81);n.exports=function(n){return o(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(7),a=t(188),o=e&&!e.nodeType&&e,i=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===o?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||a;n.exports=l}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(189),a=t(190),o=t(191),i=o&&o.isTypedArray,s=i?a(i):r;n.exports=s},function(n,e,t){var r=t(71),a=t(40);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(10)(t(7),"Set");n.exports=r},function(n,e,t){var r=t(37);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(86),a=t(23);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[a(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(5),a=t(41),o=t(203),i=t(206);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:o(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(139),a=t(144),o=t(215),i=t(223),s=t(232),l=t(101),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var o="",i=0,s=0;for(i=a.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(o+=t.substring(s,i)),s=i+1,o+=e}return s!==i?o+t.substring(s,i):o}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(241),a=t(242),o=t(243),i=!1,s=t(244).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),u=/^\uFEFF/;function p(n,t){var a,o,i=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)a=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(o=e.resolveInclude(n,t.filename),r.existsSync(o)&&(a=o)),a||Array.isArray(i)&&i.some((function(t){return o=e.resolveInclude(n,t,!0),r.existsSync(o)}))&&(a=o),!a)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return a}function d(n,t){var r,a=n.filename,o=arguments.length>1;if(n.cache){if(!a)throw new Error("cache option requires a filename");if(r=e.cache.get(a))return r;o||(t=h(a).toString().replace(u,""))}else if(!o){if(!a)throw new Error("Internal EJS error: no file name or template provided");t=h(a).toString().replace(u,"")}return r=e.compile(t,n),n.cache&&e.cache.set(a,r),r}function f(n,t,r){var a;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(a=d(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{a=d(n)(t)}catch(n){return r(n)}r(null,a)}function h(n){return e.fileLoader(n)}function v(n,e,t,r,a){var o=e.split("\n"),i=Math.max(r-3,0),s=Math.min(o.length,r+3),l=a(t),c=o.slice(i,s).map((function(n,e){var t=e+i+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+r+"\n"+c+"\n\n"+n.message,n}function m(n){return n.replace(/;(\s*$)/,"$1")}function g(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||o.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=o.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=a.dirname,o=a.extname,i=(0,a.resolve)(t?e:r(e),n);return o(n)||(i+=".ejs"),i},e.compile=function(n,e){return e&&e.scope&&(i||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),i=!0),e.context||(e.context=e.scope),delete e.scope),new g(n,e).compile()},e.render=function(n,e,t){var r=e||{},a=t||{};return 2==arguments.length&&o.shallowCopyFromList(a,r,l),d(a,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),a=r.shift(),i={filename:a};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?o.shallowCopy(i,r.pop()):(e.settings&&(e.settings.views&&(i.views=e.settings.views),e.settings["view cache"]&&(i.cache=!0),(t=e.settings["view options"])&&o.shallowCopy(i,t)),o.shallowCopyFromList(i,e,c)),i.filename=a):e={},f(i,e,n)},e.Template=g,e.clearCache=function(){e.cache.reset()},g.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},g.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=o.escapeRegExpChars(this.opts.delimiter),t=o.escapeRegExpChars(this.opts.openDelimiter),r=o.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,i="",s="",l=r.escapeFunction;if(!this.source){if(this.generateSource(),i+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(i+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var c="  var __locals = ("+r.localsName+" || {}),\n",u=0;u<r.destructuredLocals.length;u++){var f=r.destructuredLocals[u];u>0&&(c+=",\n  "),c+=f+" = __locals."+f}i+=c+";\n"}!1!==r._with&&(i+="  with ("+r.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=i+this.source+s}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+v.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=r.client?e:function(n){return e.apply(r.context,[n||{},l,function(e,t){var a=o.shallowCopy({},n);return t&&(a=o.shallowCopy(a,t)),function(n,e){var t=o.shallowCopy({},e);return t.filename=p(n,t),d(t)}(e,r)(a)},v])};if(h.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var m=r.filename,g=a.basename(m,a.extname(m));try{Object.defineProperty(h,"name",{value:g,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),a=this.opts.delimiter,i=this.opts.openDelimiter,s=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(l,c){var d,f,v,m,y,b;if(0===l.indexOf(i+a)&&0!==l.indexOf(i+a+a)&&(f=r[c+2])!=a+s&&f!="-"+a+s&&f!="_"+a+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(v=l.match(/^\s*include\s+(\S+)/))&&(d=r[c-1])&&(d==i+a||d==i+a+"-"||d==i+a+"_"))return m=o.shallowCopy({},t.opts),y=function(n,e){var t,r,a=o.shallowCopy({},e);r=h(t=p(n,a)).toString().replace(u,""),a.filename=t;var i=new g(r,a);return i.generateSource(),{source:i.source,filename:t,template:r}}(v[1],m),b=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(y.template)+"\n      , __filename = "+JSON.stringify(y.filename)+";\n      try {\n"+y.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+y.source+"    ; }).call(this)\n",t.source+=b,void t.dependencies.push(e.resolveInclude(v[1],m.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),a=[];r;)0!==(n=r.index)&&(a.push(e.substring(0,n)),e=e.slice(n)),a.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&a.push(e),a},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,a=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=g.modes.EVAL;break;case r+t+"=":this.mode=g.modes.ESCAPED;break;case r+t+"-":this.mode=g.modes.RAW;break;case r+t+"#":this.mode=g.modes.COMMENT;break;case r+t+t:this.mode=g.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+a:this.mode=g.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+a,t+a)+'")\n';break;case t+a:case"-"+t+a:case"_"+t+a:this.mode==g.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case g.modes.EVAL:case g.modes.ESCAPED:case g.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case g.modes.EVAL:this.source+="    ; "+n+"\n";break;case g.modes.ESCAPED:this.source+="    ; __append(escapeFn("+m(n)+"))\n";break;case g.modes.RAW:this.source+="    ; __append("+m(n)+")\n";break;case g.modes.COMMENT:break;case g.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=o.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(235),t(3)),o=Object(a.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=o.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},a=(t(236),t(3)),o=Object(a.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=o.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(1),a=t(9),o=r.document,i=a(o)&&a(o.createElement);n.exports=function(n){return i?o.createElement(n):{}}},function(n,e,t){var r=t(8),a=t(4);n.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(59),a=t(61),o=r("keys");n.exports=function(n){return o[n]||(o[n]=a(n))}},function(n,e,t){var r=t(2),a=t(6),o=t(29),i=t(117).indexOf,s=t(47),l=r([].push);n.exports=function(n,e){var t,r=o(n),c=0,u=[];for(t in r)!a(s,t)&&a(r,t)&&l(u,t);for(;e.length>c;)a(r,t=e[c++])&&(~i(u,t)||l(u,t));return u}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(247)},function(n,e,t){"use strict";var r=t(27),a=t(123).left,o=t(124),i=t(58),s=t(125);r({target:"Array",proto:!0,forced:!o("reduce")||!s&&i>79&&i<83},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,o=a&&!r.call({1:2},1);e.f=o?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(30),a=t(9),o=t(54),i=t(107),s=t(109),l=t(17),c=TypeError,u=l("toPrimitive");n.exports=function(n,e){if(!a(n)||o(n))return n;var t,l=i(n,u);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!a(t)||o(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var r=t(16);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(45);n.exports=function(n,e){var t=n[e];return null==t?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(30),a=t(0),o=t(9),i=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&a(t=n.toString)&&!o(s=r(t,n)))return s;if(a(t=n.valueOf)&&!o(s=r(t,n)))return s;if("string"!==e&&a(t=n.toString)&&!o(s=r(t,n)))return s;throw i("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),a=t(13),o=t(111),i=t(34);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&o(t,c,s),s.global)l?n[e]=t:i(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var r=t(4),a=t(0),o=t(6),i=t(8),s=t(112).CONFIGURABLE,l=t(63),c=t(113),u=c.enforce,p=c.get,d=Object.defineProperty,f=i&&!r((function(){return 8!==d((function(){}),"length",{value:8}).length})),h=String(String).split("String"),v=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||s&&n.name!==e)&&(i?d(n,"name",{value:e,configurable:!0}):n.name=e),f&&t&&o(t,"arity")&&n.length!==t.arity&&d(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?i&&d(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=u(n);return o(r,"source")||(r.source=h.join("string"==typeof e?e:"")),n};Function.prototype.toString=v((function(){return a(this)&&p(this).source||l(this)}),"toString")},function(n,e,t){var r=t(8),a=t(6),o=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,s=a(o,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&i(o,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r,a,o,i=t(114),s=t(1),l=t(2),c=t(9),u=t(18),p=t(6),d=t(33),f=t(99),h=t(47),v=s.TypeError,m=s.WeakMap;if(i||d.state){var g=d.state||(d.state=new m),y=l(g.get),b=l(g.has),x=l(g.set);r=function(n,e){if(b(g,n))throw new v("Object already initialized");return e.facade=n,x(g,n,e),e},a=function(n){return y(g,n)||{}},o=function(n){return b(g,n)}}else{var k=f("state");h[k]=!0,r=function(n,e){if(p(n,k))throw new v("Object already initialized");return e.facade=n,u(n,k,e),e},a=function(n){return p(n,k)?n[k]:{}},o=function(n){return p(n,k)}}n.exports={set:r,get:a,has:o,enforce:function(n){return o(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=a(e)).type!==n)throw v("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(1),a=t(0),o=t(63),i=r.WeakMap;n.exports=a(i)&&/native code/.test(o(i))},function(n,e,t){var r=t(16),a=t(2),o=t(116),i=t(121),s=t(26),l=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=o.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(100),a=t(96).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){var r=t(29),a=t(118),o=t(48),i=function(n){return function(e,t,i){var s,l=r(e),c=o(l),u=a(i,c);if(n&&t!=t){for(;c>u;)if((s=l[u++])!=s)return!0}else for(;c>u;u++)if((n||u in l)&&l[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){var r=t(65),a=Math.max,o=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):o(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(65),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(4),a=t(0),o=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t==u||t!=c&&(a(e)?r(e):!!e)},s=i.normalize=function(n){return String(n).replace(o,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",u=i.POLYFILL="P";n.exports=i},function(n,e,t){var r=t(45),a=t(46),o=t(44),i=t(48),s=TypeError,l=function(n){return function(e,t,l,c){r(t);var u=a(e),p=o(u),d=i(u),f=n?d-1:0,h=n?-1:1;if(l<2)for(;;){if(f in p){c=p[f],f+=h;break}if(f+=h,n?f<0:d<=f)throw s("Reduce of empty array with no initial value")}for(;n?f>=0:d>f;f+=h)f in p&&(c=t(c,p[f],f,u));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(4);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(32),a=t(1);n.exports="process"==r(a.process)},function(n,e,t){var r=t(27),a=t(1),o=t(127),i=t(128),s=a.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return o(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),c("URIError",(function(n){return function(e){return o(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e,t){var r=t(28),a=Function.prototype,o=a.apply,i=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(o):function(){return i.apply(o,arguments)})},function(n,e,t){"use strict";var r=t(16),a=t(6),o=t(18),i=t(55),s=t(66),l=t(64),c=t(130),u=t(131),p=t(132),d=t(136),f=t(137),h=t(138),v=t(8),m=t(60);n.exports=function(n,e,t,g){var y=g?2:1,b=n.split("."),x=b[b.length-1],k=r.apply(null,b);if(k){var _=k.prototype;if(!m&&a(_,"cause")&&delete _.cause,!t)return k;var w=r("Error"),E=e((function(n,e){var t=p(g?e:n,void 0),r=g?new k(n):new k;return void 0!==t&&o(r,"message",t),h&&o(r,"stack",f(r.stack,2)),this&&i(_,this)&&u(r,this,E),arguments.length>y&&d(r,arguments[y]),r}));if(E.prototype=_,"Error"!==x?s?s(E,w):l(E,w,{name:!0}):v&&"stackTraceLimit"in k&&(c(E,k,"stackTraceLimit"),c(E,k,"prepareStackTrace")),l(E,k),!m)try{_.name!==x&&o(_,"name",x),_.constructor=E}catch(n){}return E}}},function(n,e,t){var r=t(0),a=String,o=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw o("Can't set "+a(n)+" as a prototype")}},function(n,e,t){var r=t(13).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(0),a=t(9),o=t(66);n.exports=function(n,e,t){var i,s;return o&&r(i=e.constructor)&&i!==t&&a(s=i.prototype)&&s!==t.prototype&&o(n,s),n}},function(n,e,t){var r=t(133);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(134),a=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var r=t(135),a=t(0),o=t(32),i=t(17)("toStringTag"),s=Object,l="Arguments"==o(function(){return arguments}());n.exports=r?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),i))?t:l?o(e):"Object"==(r=o(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(17)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(9),a=t(18);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var r=t(2),a=Error,o=r("".replace),i=String(a("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(i);n.exports=function(n,e){if(l&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=o(n,s,"");return n}},function(n,e,t){var r=t(4),a=t(31);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(67),a=t(140);n.exports=function n(e,t,o,i,s){var l=-1,c=e.length;for(o||(o=a),s||(s=[]);++l<c;){var u=e[l];t>0&&o(u)?t>1?n(u,t-1,o,i,s):r(s,u):i||(s[s.length]=u)}return s}},function(n,e,t){var r=t(15),a=t(35),o=t(5),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||a(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(14),a=t(12);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(15),a=Object.prototype,o=a.hasOwnProperty,i=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=i.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(145),a=t(201),o=t(43),i=t(5),s=t(212);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?i(n)?a(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(146),a=t(200),o=t(84);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(69),a=t(73);n.exports=function(n,e,t,o){var i=t.length,s=i,l=!o;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var u=(c=t[i])[0],p=n[u],d=c[1];if(l&&c[2]){if(void 0===p&&!(u in n))return!1}else{var f=new r;if(o)var h=o(p,d,u,n,e,f);if(!(void 0===h?a(d,p,3,o,f):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(20),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(20);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(20);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(20);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(19);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(19),a=t(36),o=t(38);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!a||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(71),a=t(158),o=t(37),i=t(72),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,p=c.hasOwnProperty,d=RegExp("^"+u.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||a(n))&&(r(n)?d:s).test(i(n))}},function(n,e,t){var r,a=t(159),o=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(7)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(162),a=t(19),o=t(36);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||a),string:new r}}},function(n,e,t){var r=t(163),a=t(164),o=t(165),i=t(166),s=t(167);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(21);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(21),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(21),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(22);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(22);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(69),a=t(74),o=t(177),i=t(180),s=t(196),l=t(5),c=t(78),u=t(80),p="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,f,h,v){var m=l(n),g=l(e),y=m?"[object Array]":s(n),b=g?"[object Array]":s(e),x=(y="[object Arguments]"==y?p:y)==p,k=(b="[object Arguments]"==b?p:b)==p,_=y==b;if(_&&c(n)){if(!c(e))return!1;m=!0,x=!1}if(_&&!x)return v||(v=new r),m||u(n)?a(n,e,t,f,h,v):o(n,e,y,t,f,h,v);if(!(1&t)){var w=x&&d.call(n,"__wrapped__"),E=k&&d.call(e,"__wrapped__");if(w||E){var j=w?n.value():n,C=E?e.value():e;return v||(v=new r),h(j,C,t,f,v)}}return!!_&&(v||(v=new r),i(n,e,t,f,h,v))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(15),a=t(178),o=t(70),i=t(74),s=t(179),l=t(39),c=r?r.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,p,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!p(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var f=s;case"[object Set]":var h=1&r;if(f||(f=l),n.size!=e.size&&!h)return!1;var v=d.get(n);if(v)return v==e;r|=2,d.set(n,e);var m=i(f(n),f(e),r,c,p,d);return d.delete(n),m;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(7).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(181),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,i,s){var l=1&t,c=r(n),u=c.length;if(u!=r(e).length&&!l)return!1;for(var p=u;p--;){var d=c[p];if(!(l?d in e:a.call(e,d)))return!1}var f=s.get(n),h=s.get(e);if(f&&h)return f==e&&h==n;var v=!0;s.set(n,e),s.set(e,n);for(var m=l;++p<u;){var g=n[d=c[p]],y=e[d];if(o)var b=l?o(y,g,d,e,n,s):o(g,y,d,n,e,s);if(!(void 0===b?g===y||i(g,y,t,o,s):b)){v=!1;break}m||(m="constructor"==d)}if(v&&!m){var x=n.constructor,k=e.constructor;x==k||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof k&&k instanceof k||(v=!1)}return s.delete(n),s.delete(e),v}},function(n,e,t){var r=t(182),a=t(183),o=t(77);n.exports=function(n){return r(n,o,a)}},function(n,e,t){var r=t(67),a=t(5);n.exports=function(n,e,t){var o=e(n);return a(n)?o:r(o,t(n))}},function(n,e,t){var r=t(184),a=t(185),o=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return o.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,o=[];++t<r;){var i=n[t];e(i,t,n)&&(o[a++]=i)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(187),a=t(35),o=t(5),i=t(78),s=t(79),l=t(80),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),u=!t&&a(n),p=!t&&!u&&i(n),d=!t&&!u&&!p&&l(n),f=t||u||p||d,h=f?r(n.length,String):[],v=h.length;for(var m in n)!e&&!c.call(n,m)||f&&("length"==m||p&&("offset"==m||"parent"==m)||d&&("buffer"==m||"byteLength"==m||"byteOffset"==m)||s(m,v))||h.push(m);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(14),a=t(40),o=t(12),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&a(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(68),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,i=o&&o.exports===a&&r.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(49)(n))},function(n,e,t){var r=t(193),a=t(194),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(195)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(197),a=t(36),o=t(198),i=t(82),s=t(199),l=t(14),c=t(72),u=c(r),p=c(a),d=c(o),f=c(i),h=c(s),v=l;(r&&"[object DataView]"!=v(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=v(new a)||o&&"[object Promise]"!=v(o.resolve())||i&&"[object Set]"!=v(new i)||s&&"[object WeakMap]"!=v(new s))&&(v=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case u:return"[object DataView]";case p:return"[object Map]";case d:return"[object Promise]";case f:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=v},function(n,e,t){var r=t(10)(t(7),"DataView");n.exports=r},function(n,e,t){var r=t(10)(t(7),"Promise");n.exports=r},function(n,e,t){var r=t(10)(t(7),"WeakMap");n.exports=r},function(n,e,t){var r=t(83),a=t(77);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var o=e[t],i=n[o];e[t]=[o,i,r(i)]}return e}},function(n,e,t){var r=t(73),a=t(202),o=t(209),i=t(41),s=t(83),l=t(84),c=t(23);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=a(t,n);return void 0===i&&i===e?o(t,n):r(e,i,3)}}},function(n,e,t){var r=t(85);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(204),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(o,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(205);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(38);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],o=t.cache;if(o.has(a))return o.get(a);var i=n.apply(this,r);return t.cache=o.set(a,i)||o,i};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(207);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(15),a=t(208),o=t(5),i=t(42),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return a(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(210),a=t(211);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(86),a=t(35),o=t(5),i=t(79),s=t(40),l=t(23);n.exports=function(n,e,t){for(var c=-1,u=(e=r(e,n)).length,p=!1;++c<u;){var d=l(e[c]);if(!(p=null!=n&&t(n,d)))break;n=n[d]}return p||++c!=u?p:!!(u=null==n?0:n.length)&&s(u)&&i(d,u)&&(o(n)||a(n))}},function(n,e,t){var r=t(213),a=t(214),o=t(41),i=t(23);n.exports=function(n){return o(n)?r(i(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(85);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(43),a=t(216),o=t(218);n.exports=function(n,e){return o(a(n,e,r),n+"")}},function(n,e,t){var r=t(217),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var o=arguments,i=-1,s=a(o.length-e,0),l=Array(s);++i<s;)l[i]=o[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=o[i];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(219),a=t(222)(r);n.exports=a},function(n,e,t){var r=t(220),a=t(221),o=t(43),i=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(10),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),o=16-(a-r);if(r=a,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(75),a=t(224),o=t(229),i=t(76),s=t(230),l=t(39);n.exports=function(n,e,t){var c=-1,u=a,p=n.length,d=!0,f=[],h=f;if(t)d=!1,u=o;else if(p>=200){var v=e?null:s(n);if(v)return l(v);d=!1,u=i,h=new r}else h=e?[]:f;n:for(;++c<p;){var m=n[c],g=e?e(m):m;if(m=t||0!==m?m:0,d&&g==g){for(var y=h.length;y--;)if(h[y]===g)continue n;e&&h.push(g),f.push(m)}else u(h,g,t)||(h!==f&&h.push(g),f.push(m))}return f}},function(n,e,t){var r=t(225);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(226),a=t(227),o=t(228);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,o=t+(r?1:-1);r?o--:++o<a;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(82),a=t(231),o=t(39),i=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(81),a=t(12);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(87)},function(n,e,t){"use strict";t(88)},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(27),a=t(1),o=t(240);r({global:!0},{Reflect:{}}),o(a.Reflect,"Reflect",!0)},function(n,e,t){var r=t(13).f,a=t(6),o=t(17)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!a(n,o)&&r(n,o,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var a=n[r];"."===a?n.splice(r,1):".."===a?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var n="",e=!1,a=arguments.length-1;a>=-1&&!e;a--){var o=a>=0?arguments[a]:process.cwd();if("string"!=typeof o)throw new TypeError("Arguments to path.resolve must be strings");o&&(n=o+"/"+n,e="/"===o.charAt(0))}return(e?"/":"")+(n=t(r(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var o=e.isAbsolute(n),i="/"===a(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!o).join("/"))||o||(n="."),n&&i&&(n+="/"),(o?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var a=r(n.split("/")),o=r(t.split("/")),i=Math.min(a.length,o.length),s=i,l=0;l<i;l++)if(a[l]!==o[l]){s=l;break}var c=[];for(l=s;l<a.length;l++)c.push("..");return(c=c.concat(o.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,a=!0,o=n.length-1;o>=1;--o)if(47===(e=n.charCodeAt(o))){if(!a){r=o;break}}else a=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,a=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!a){t=e+1;break}}else-1===r&&(a=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,a=!0,o=0,i=n.length-1;i>=0;--i){var s=n.charCodeAt(i);if(47!==s)-1===r&&(a=!1,r=i+1),46===s?-1===e?e=i:1!==o&&(o=1):-1!==e&&(o=-1);else if(!a){t=i+1;break}}return-1===e||-1===r||0===o||1===o&&e===r-1&&e===t+1?"":n.slice(e,r)};var a="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var a={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},o=/[&<>'"]/g;function i(n){return a[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(o,i)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var a=t[r];void 0!==e[a]&&(n[a]=e[a])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"_from":"ejs@^2.6.1","_id":"ejs@2.7.4","_inBundle":false,"_integrity":"sha512-7vmuyh5+kuUyJKePhQfRQBhXV5Ce+RnaeeQArKu1EAMpL3WbgMt5WG6uQZpEVvYSSsxMXRKOewtDk9RaTKXRlA==","_location":"/ejs","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"ejs@^2.6.1","name":"ejs","escapedName":"ejs","rawSpec":"^2.6.1","saveSpec":null,"fetchSpec":"^2.6.1"},"_requiredBy":["/vuepress-plugin-comment"],"_resolved":"https://registry.npmjs.org/ejs/-/ejs-2.7.4.tgz","_shasum":"48661287573dcc53e366c7a1ae52c3a120eec9ba","_spec":"ejs@^2.6.1","_where":"/home/runner/work/blog/blog/node_modules/vuepress-plugin-comment","author":{"name":"Matthew Eernisse","email":"mde@fleegix.org","url":"http://fleegix.org"},"bugs":{"url":"https://github.com/mde/ejs/issues"},"bundleDependencies":false,"dependencies":{},"deprecated":false,"description":"Embedded JavaScript templates","devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/mde/ejs","keywords":["template","engine","ejs"],"license":"Apache-2.0","main":"./lib/ejs.js","name":"ejs","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"scripts":{"postinstall":"node ./postinstall.js","test":"mocha"},"version":"2.7.4"}')},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.4
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),a=Array.isArray;function o(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var p=Object.prototype.toString;function d(n){return"[object Object]"===p.call(n)}function f(n){return"[object RegExp]"===p.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function v(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function m(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===p?JSON.stringify(n,null,2):String(n)}function g(n){var e=parseFloat(n);return isNaN(e)?n:e}function y(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}y("slot,component",!0);var b=y("key,ref,slot,slot-scope,is");function x(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var k=Object.prototype.hasOwnProperty;function _(n,e){return k.call(n,e)}function w(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var E=/-(\w)/g,j=w((function(n){return n.replace(E,(function(n,e){return e?e.toUpperCase():""}))})),C=w((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),T=/\B([A-Z])/g,S=w((function(n){return n.replace(T,"-$1").toLowerCase()}));var A=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function I(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function P(n,e){for(var t in e)n[t]=e[t];return n}function O(n){for(var e={},t=0;t<n.length;t++)n[t]&&P(e,n[t]);return e}function B(n,e,t){}var z=function(n,e,t){return!1},D=function(n){return n};function $(n,e){if(n===e)return!0;var t=u(n),r=u(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),o=Array.isArray(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return $(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||o)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return $(n[t],e[t])}))}catch(n){return!1}}function L(n,e){for(var t=0;t<n.length;t++)if($(n[t],e))return t;return-1}function M(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function R(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var U=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:z,isReservedAttr:z,isUnknownElement:z,getTagNamespace:B,parsePlatformTagName:D,mustUseProp:z,async:!0,_lifecycleHooks:N},V=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function q(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function G(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var J=new RegExp("[^".concat(V.source,".$_\\d]"));var H="__proto__"in{},X="undefined"!=typeof window,W=X&&window.navigator.userAgent.toLowerCase(),Z=W&&/msie|trident/.test(W),K=W&&W.indexOf("msie 9.0")>0,Y=W&&W.indexOf("edge/")>0;W&&W.indexOf("android");var Q=W&&/iphone|ipad|ipod|ios/.test(W);W&&/chrome\/\d+/.test(W),W&&/phantomjs/.test(W);var nn,en=W&&W.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(X)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===nn&&(nn=!X&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=X&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,un="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=null;function dn(n){void 0===n&&(n=null),n||pn&&pn._scope.off(),pn=n,n&&n._scope.on()}var fn=B,hn=0,vn=function(){function n(){this.id=hn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){x(this.subs,n)},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.slice();for(var t=0,r=e.length;t<r;t++){e[t].update()}},n}();vn.target=null;var mn=[];function gn(n){mn.push(n),vn.target=n}function yn(){mn.pop(),vn.target=mn[mn.length-1]}var bn=function(){function n(n,e,t,r,a,o,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),xn=function(n){void 0===n&&(n="");var e=new bn;return e.text=n,e.isComment=!0,e};function kn(n){return new bn(void 0,void 0,void 0,String(n))}function _n(n){var e=new bn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var wn=Array.prototype,En=Object.create(wn);function jn(n){return Cn(n,!0),G(n,"__v_isShallow",!0),n}function Cn(n,e){if(!Tn(n)){vt(n,e,on());0}}function Tn(n){return!(!n||!n.__v_isReadonly)}["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];G(En,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var a,o=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&i.observeArray(a),i.dep.notify(),o}))}));function Sn(n){return!(!n||!0!==n.__v_isRef)}function An(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){return function(n){return Sn(n)?n.value:n}(e[t])},set:function(n){var r=e[t];Sn(r)&&!Sn(n)?r.value=n:e[t]=n}})}var In=new cn;function Pn(n){return function n(e,t){var r,o,i=a(e);if(!i&&!u(e)||Object.isFrozen(e)||e instanceof bn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(r=e.length;r--;)n(e[r],t);else for(o=Object.keys(e),r=o.length;r--;)n(e[o[r]],t)}(n,In),In.clear(),n}var On=w((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Bn(n,e){function t(){var n=t.fns;if(!a(n))return We(n,null,arguments,e,"v-on handler");for(var r=n.slice(),o=0;o<r.length;o++)We(r[o],null,arguments,e,"v-on handler")}return t.fns=n,t}function zn(n,e,t,r,a,i){var l,c,u,p;for(l in n)c=n[l],u=e[l],p=On(l),o(c)||(o(u)?(o(c.fns)&&(c=n[l]=Bn(c,i)),s(p.once)&&(c=n[l]=a(p.name,c,p.capture)),t(p.name,c,p.capture,p.passive,p.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)o(n[l])&&r((p=On(l)).name,e[l],p.capture)}function Dn(n,e,t){var r;n instanceof bn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function l(){t.apply(this,arguments),x(r.fns,l)}o(a)?r=Bn([l]):i(a.fns)&&s(a.merged)?(r=a).fns.push(l):r=Bn([a,l]),r.merged=!0,n[e]=r}function $n(n,e,t,r,a){if(i(e)){if(_(e,t))return n[t]=e[t],a||delete e[t],!0;if(_(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function Ln(n){return l(n)?[kn(n)]:a(n)?function n(e,t){var r,c,u,p,d=[];for(r=0;r<e.length;r++)o(c=e[r])||"boolean"==typeof c||(u=d.length-1,p=d[u],a(c)?c.length>0&&(Mn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Mn(p)&&(d[u]=kn(p.text+c[0].text),c.shift()),d.push.apply(d,c)):l(c)?Mn(p)?d[u]=kn(p.text+c):""!==c&&d.push(kn(c)):Mn(c)&&Mn(p)?d[u]=kn(p.text+c.text):(s(e._isVList)&&i(c.tag)&&o(c.key)&&i(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),d.push(c)));return d}(n):void 0}function Mn(n){return i(n)&&i(n.text)&&!1===n.isComment}function Rn(n,e){if(pn){var t=pn._provided,r=pn.$parent&&pn.$parent._provided;r===t&&(t=pn._provided=Object.create(r)),t[n]=e}else 0}function Un(n,e){if(n){for(var t=Object.create(null),r=un?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var o=r[a];if("__ob__"!==o){var i=n[o].from;if(i in e._provided)t[o]=e._provided[i];else if("default"in n[o]){var s=n[o].default;t[o]=c(s)?s.call(e):s}else 0}}return t}}function Nn(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var o=n[r],i=o.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,o.context!==e&&o.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(o);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(Fn)&&delete t[c];return t}function Fn(n){return n.isComment&&!n.asyncFactory||" "===n.text}function Vn(n){return n.isComment&&n.asyncFactory}function qn(n,e,t,a){var o,i=Object.keys(t).length>0,s=e?!!e.$stable:!i,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&a&&a!==r&&l===a.$key&&!i&&!a.$hasNormal)return a;for(var c in o={},e)e[c]&&"$"!==c[0]&&(o[c]=Gn(n,t,c,e[c]))}else o={};for(var u in t)u in o||(o[u]=Jn(t,u));return e&&Object.isExtensible(e)&&(e._normalized=o),G(o,"$stable",s),G(o,"$key",l),G(o,"$hasNormal",i),o}function Gn(n,e,t,r){var o=function(){var e=pn;dn(n);var t=arguments.length?r.apply(null,arguments):r({}),o=(t=t&&"object"==typeof t&&!a(t)?[t]:Ln(t))&&t[0];return dn(e),t&&(!o||1===t.length&&o.isComment&&!Vn(o))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:o,enumerable:!0,configurable:!0}),o}function Jn(n,e){return function(){return n[e]}}function Hn(n,e){var t,r,o,s,l=null;if(a(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(u(n))if(un&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),p=c.next();!p.done;)l.push(e(p.value,l.length)),p=c.next()}else for(o=Object.keys(n),l=new Array(o.length),t=0,r=o.length;t<r;t++)s=o[t],l[t]=e(n[s],s,t);return i(l)||(l=[]),l._isVList=!0,l}function Xn(n,e,t,r){var a,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=P(P({},r),t)),a=o(t)||(c(e)?e():e)):a=this.$slots[n]||(c(e)?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},a):a}function Wn(n){return Tt(this.$options,"filters",n,!0)||D}function Zn(n,e){return a(n)?-1===n.indexOf(e):n!==e}function Kn(n,e,t,r,a){var o=F.keyCodes[e]||t;return a&&r&&!F.keyCodes[e]?Zn(a,r):o?Zn(o,n):r?S(r)!==e:void 0===n}function Yn(n,e,t,r,o){if(t)if(u(t)){a(t)&&(t=O(t));var i=void 0,s=function(a){if("class"===a||"style"===a||b(a))i=n;else{var s=n.attrs&&n.attrs.type;i=r||F.mustUseProp(e,s,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=j(a),c=S(a);l in i||c in i||(i[a]=t[a],o&&((n.on||(n.on={}))["update:".concat(a)]=function(n){t[a]=n}))};for(var l in t)s(l)}else;return n}function Qn(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ee(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ne(n,e,t){return ee(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ee(n,e,t){if(a(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&te(n[r],"".concat(e,"_").concat(r),t);else te(n,e,t)}function te(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function re(n,e){if(e)if(d(e)){var t=n.on=n.on?P({},n.on):{};for(var r in e){var a=t[r],o=e[r];t[r]=a?[].concat(a,o):o}}else;return n}function ae(n,e,t,r){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var i=n[o];a(i)?ae(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return r&&(e.$key=r),e}function oe(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function ie(n,e){return"string"==typeof n?e+n:n}function se(n){n._o=ne,n._n=g,n._s=m,n._l=Hn,n._t=Xn,n._q=$,n._i=L,n._m=Qn,n._f=Wn,n._k=Kn,n._b=Yn,n._v=kn,n._e=xn,n._u=ae,n._g=re,n._d=oe,n._p=ie}function le(n,e,t,o,i){var l,c=this,u=i.options;_(o,"_uid")?(l=Object.create(o))._original=o:(l=o,o=o._original);var p=s(u._compiled),d=!p;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||r,this.injections=Un(u.inject,o),this.slots=function(){return c.$slots||qn(o,n.scopedSlots,c.$slots=Nn(t,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return qn(o,n.scopedSlots,this.slots())}}),p&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=qn(o,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,r){var i=ve(l,n,e,t,r,d);return i&&!a(i)&&(i.fnScopeId=u._scopeId,i.fnContext=o),i}:this._c=function(n,e,t,r){return ve(l,n,e,t,r,d)}}function ce(n,e,t,r,a){var o=_n(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function ue(n,e){for(var t in e)n[j(t)]=e[t]}se(le.prototype);var pe={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;pe.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Se)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,o){0;var i=a.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==r&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l),u=n.$vnode;n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a);n.$options._renderChildren=o;var p=a.data.attrs||r;n._attrsProxy&&ge(n._attrsProxy,p,u.data&&u.data.attrs||r,n)&&(c=!0);if(n.$attrs=p,n.$listeners=t||r,e&&n.$options.props){dt(!1);for(var d=n._props,f=n.$options._propKeys||[],h=0;h<f.length;h++){var v=f[h],m=n.$options.props;d[v]=St(v,m,e,n)}dt(!0),n.$options.propsData=e}t=t||r;var g=n.$options._parentListeners;n.$options._parentListeners=t,Te(n,t,g),c&&(n.$slots=Nn(o,a.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,Oe(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,ze.push(e)):Pe(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,Ie(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);Oe(e,"deactivated")}}(e,!0):e.$destroy())}},de=Object.keys(pe);function fe(n,e,t,l,c){if(!o(n)){var p=t.$options._base;if(u(n)&&(n=p.extend(n)),"function"==typeof n){var d;if(o(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=ke;t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],a=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var p=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},d=M((function(t){n.resolved=_e(t,e),a?r.length=0:p(!0)})),f=M((function(e){i(n.errorComp)&&(n.error=!0,p(!0))})),h=n(d,f);return u(h)&&(v(h)?o(n.resolved)&&h.then(d,f):v(h.component)&&(h.component.then(d,f),i(h.error)&&(n.errorComp=_e(h.error,e)),i(h.loading)&&(n.loadingComp=_e(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,p(!1))}),h.delay||200)),i(h.timeout)&&(c=setTimeout((function(){c=null,o(n.resolved)&&f(null)}),h.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(d=n,p)))return function(n,e,t,r,a){var o=xn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:a},o}(d,e,t,l,c);e=e||{},Ft(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),s=o[r],l=e.model.callback;i(s)?(a(s)?-1===s.indexOf(l):s!==l)&&(o[r]=[l].concat(s)):o[r]=l}(n.options,e);var f=function(n,e,t){var r=e.options.props;if(!o(r)){var a={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in r){var u=S(c);$n(a,l,c,u,!0)||$n(a,s,c,u,!1)}return a}}(e,n);if(s(n.options.functional))return function(n,e,t,o,s){var l=n.options,c={},u=l.props;if(i(u))for(var p in u)c[p]=St(p,u,e||r);else i(t.attrs)&&ue(c,t.attrs),i(t.props)&&ue(c,t.props);var d=new le(t,c,s,o,n),f=l.render.call(null,d._c,d);if(f instanceof bn)return ce(f,t,d.parent,l,d);if(a(f)){for(var h=Ln(f)||[],v=new Array(h.length),m=0;m<h.length;m++)v[m]=ce(h[m],t,d.parent,l,d);return v}}(n,f,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var m=e.slot;e={},m&&(e.slot=m)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<de.length;t++){var r=de[t],a=e[r],o=pe[r];a===o||a&&a._merged||(e[r]=a?he(o,a):o)}}(e);var g=n.options.name||c;return new bn("vue-component-".concat(n.cid).concat(g?"-".concat(g):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:f,listeners:h,tag:c,children:l},d)}}}function he(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function ve(n,e,t,r,p,d){return(a(t)||l(t))&&(p=r,r=t,t=void 0),s(d)&&(p=2),function(n,e,t,r,l){if(i(t)&&i(t.__ob__))return xn();i(t)&&i(t.is)&&(e=t.is);if(!e)return xn();0;a(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Ln(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(a(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var p,d;if("string"==typeof e){var f=void 0;d=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),p=F.isReservedTag(e)?new bn(F.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(f=Tt(n.$options,"components",e))?new bn(e,t,r,void 0,void 0,n):fe(f,t,n,r,e)}else p=fe(e,t,n,r);return a(p)?p:i(p)?(i(d)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var a=0,l=e.children.length;a<l;a++){var c=e.children[a];i(c.tag)&&(o(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(p,d),i(t)&&function(n){u(n.style)&&Pn(n.style);u(n.class)&&Pn(n.class)}(t),p):xn()}(n,e,t,r,p)}function me(n){return{get attrs(){return function(n){if(!n._attrsProxy){var e=n._attrsProxy={};G(e,"_v_attr_proxy",!0),ge(e,n.$attrs,r,n)}return n._attrsProxy}(n)},get slots(){return function(n){n._slotsProxy||be(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:A(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return An(n,e,t)}))}}}function ge(n,e,t,r){var a=!1;for(var o in e)o in n?e[o]!==t[o]&&(a=!0):(a=!0,ye(n,o,r));for(var o in n)o in e||(a=!0,delete n[o]);return a}function ye(n,e,t){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t.$attrs[e]}})}function be(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var xe,ke=null;function _e(n,e){return(n.__esModule||un&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?e.extend(n):n}function we(n){if(a(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||Vn(t)))return t}}function Ee(n,e){xe.$on(n,e)}function je(n,e){xe.$off(n,e)}function Ce(n,e){var t=xe;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Te(n,e,t){xe=n,zn(e,t||{},Ee,je,Ce,n),xe=void 0}var Se=null;function Ae(n){var e=Se;return Se=n,function(){Se=e}}function Ie(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Pe(n,e){if(e){if(n._directInactive=!1,Ie(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Pe(n.$children[t]);Oe(n,"activated")}}function Oe(n,e,t){gn();var r=pn;dn(n);var a=n.$options[e],o="".concat(e," hook");if(a)for(var i=0,s=a.length;i<s;i++)We(a[i],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),dn(r),yn()}var Be=[],ze=[],De={},$e=!1,Le=!1,Me=0;var Re,Ue=0,Ne=Date.now;if(X&&!Z){var Fe=window.performance;Fe&&"function"==typeof Fe.now&&Ne()>document.createEvent("Event").timeStamp&&(Ne=function(){return Fe.now()})}function Ve(){var n,e;for(Ue=Ne(),Le=!0,Be.sort((function(n,e){return n.id-e.id})),Me=0;Me<Be.length;Me++)(n=Be[Me]).before&&n.before(),e=n.id,De[e]=null,n.run();var t=ze.slice(),r=Be.slice();Me=Be.length=ze.length=0,De={},$e=Le=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Pe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&Oe(r,"updated")}}(r),sn&&F.devtools&&sn.emit("flush")}function qe(n){var e=n.id;if(null==De[e]&&(n!==vn.target||!n.noRecurse)){if(De[e]=!0,Le){for(var t=Be.length-1;t>Me&&Be[t].id>n.id;)t--;Be.splice(t+1,0,n)}else Be.push(n);$e||($e=!0,st(Ve))}}var Ge=function(){function n(n){void 0===n&&(n=!1),this.active=!0,this.effects=[],this.cleanups=[],!n&&Re&&(this.parent=Re,this.index=(Re.scopes||(Re.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Re;try{return Re=this,n()}finally{Re=e}}else 0},n.prototype.on=function(){Re=this},n.prototype.off=function(){Re=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.active=!1}},n}();var Je=0,He=function(){function n(n,e,t,r,a){var o,i;o=this,void 0===(i=Re||(n?n._scope:void 0))&&(i=Re),i&&i.active&&i.effects.push(o),(this.vm=n)&&a&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Je,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!J.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=B)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;gn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Xe(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Pn(n),yn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():qe(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');We(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");function Xe(n,e,t){gn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var o=0;o<a.length;o++)try{if(!1===a[o].call(r,n,e,t))return}catch(n){Ze(n,r,"errorCaptured hook")}}Ze(n,e,t)}finally{yn()}}function We(n,e,t,r,a){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&v(o)&&!o._handled&&(o.catch((function(n){return Xe(n,r,a+" (Promise/async)")})),o._handled=!0)}catch(n){Xe(n,r,a)}return o}function Ze(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ke(e,null,"config.errorHandler")}Ke(n,e,t)}function Ke(n,e,t){if(!X||"undefined"==typeof console)throw n;console.error(n)}var Ye,Qe=!1,nt=[],et=!1;function tt(){et=!1;var n=nt.slice(0);nt.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var rt=Promise.resolve();Ye=function(){rt.then(tt),Q&&setTimeout(B)},Qe=!0}else if(Z||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ye="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(tt)}:function(){setTimeout(tt,0)};else{var at=1,ot=new MutationObserver(tt),it=document.createTextNode(String(at));ot.observe(it,{characterData:!0}),Ye=function(){at=(at+1)%2,it.data=String(at)},Qe=!0}function st(n,e){var t;if(nt.push((function(){if(n)try{n.call(e)}catch(n){Xe(n,e,"nextTick")}else t&&t(e)})),et||(et=!0,Ye()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function lt(n){return function(e,t){if(void 0===t&&(t=pn),t)return function(n,e,t){var r=n.$options;r[e]=wt(r[e],t)}(t,n,e)}}lt("beforeMount"),lt("mounted"),lt("beforeUpdate"),lt("updated"),lt("beforeDestroy"),lt("destroyed"),lt("errorCaptured"),lt("activated"),lt("deactivated"),lt("serverPrefetch"),lt("renderTracked"),lt("renderTriggered");var ct=Object.getOwnPropertyNames(En),ut={},pt=!0;function dt(n){pt=n}var ft={notify:B,depend:B,addSub:B,removeSub:B},ht=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?ft:new vn,this.vmCount=0,G(n,"__ob__",this),a(n)){if(!t)if(H)n.__proto__=En;else for(var r=0,o=ct.length;r<o;r++){G(n,s=ct[r],En[s])}e||this.observeArray(n)}else{var i=Object.keys(n);for(r=0;r<i.length;r++){var s;mt(n,s=i[r],ut,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)vt(n[e],!1,this.mock)},n}();function vt(n,e,t){var r;if(!(!u(n)||Sn(n)||n instanceof bn))return _(n,"__ob__")&&n.__ob__ instanceof ht?r=n.__ob__:!pt||!t&&on()||!a(n)&&!d(n)||!Object.isExtensible(n)||n.__v_skip||(r=new ht(n,e,t)),r}function mt(n,e,t,r,o,i){var s=new vn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,u=l&&l.set;c&&!u||t!==ut&&2!==arguments.length||(t=n[e]);var p=!o&&vt(t,!1,i);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return vn.target&&(s.depend(),p&&(p.dep.depend(),a(e)&&bt(e))),Sn(e)&&!o?e.value:e},set:function(e){var r=c?c.call(n):t;if(R(r,e)){if(u)u.call(n,e);else{if(c)return;if(Sn(r)&&!Sn(e))return void(r.value=e);t=e}p=!o&&vt(e,!1,i),s.notify()}}}),s}}function gt(n,e,t){if(!Tn(n)){var r=n.__ob__;return a(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&vt(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(mt(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function yt(n,e){if(a(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Tn(n)||_(n,e)&&(delete n[e],t&&t.dep.notify())}}function bt(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),a(e)&&bt(e)}var xt=F.optionMergeStrategies;function kt(n,e){if(!e)return n;for(var t,r,a,o=un?Reflect.ownKeys(e):Object.keys(e),i=0;i<o.length;i++)"__ob__"!==(t=o[i])&&(r=n[t],a=e[t],_(n,t)?r!==a&&d(r)&&d(a)&&kt(r,a):gt(n,t,a));return n}function _t(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,a=c(n)?n.call(t,t):n;return r?kt(r,a):a}:e?n?function(){return kt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function wt(n,e){var t=e?n?n.concat(e):a(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Et(n,e,t,r){var a=Object.create(n||null);return e?P(a,e):a}xt.data=function(n,e,t){return t?_t(n,e,t):e&&"function"!=typeof e?n:_t(n,e)},N.forEach((function(n){xt[n]=wt})),U.forEach((function(n){xt[n+"s"]=Et})),xt.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var i in P(o,n),e){var s=o[i],l=e[i];s&&!a(s)&&(s=[s]),o[i]=s?s.concat(l):a(l)?l:[l]}return o},xt.props=xt.methods=xt.inject=xt.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return P(a,n),e&&P(a,e),a},xt.provide=_t;var jt=function(n,e){return void 0===e?n:e};function Ct(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,o,i={};if(a(t))for(r=t.length;r--;)"string"==typeof(o=t[r])&&(i[j(o)]={type:null});else if(d(t))for(var s in t)o=t[s],i[j(s)]=d(o)?o:{type:o};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(a(t))for(var o=0;o<t.length;o++)r[t[o]]={from:t[o]};else if(d(t))for(var i in t){var s=t[i];r[i]=d(s)?P({from:i},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Ct(n,e.extends,t)),e.mixins))for(var r=0,o=e.mixins.length;r<o;r++)n=Ct(n,e.mixins[r],t);var i,s={};for(i in n)l(i);for(i in e)_(n,i)||l(i);function l(r){var a=xt[r]||jt;s[r]=a(n[r],e[r],t,r)}return s}function Tt(n,e,t,r){if("string"==typeof t){var a=n[e];if(_(a,t))return a[t];var o=j(t);if(_(a,o))return a[o];var i=C(o);return _(a,i)?a[i]:a[t]||a[o]||a[i]}}function St(n,e,t,r){var a=e[n],o=!_(t,n),i=t[n],s=Ot(Boolean,a.type);if(s>-1)if(o&&!_(a,"default"))i=!1;else if(""===i||i===S(n)){var l=Ot(String,a.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!_(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==It(e.type)?r.call(n):r}(r,a,n);var u=pt;dt(!0),vt(i),dt(u)}return i}var At=/^\s*function (\w+)/;function It(n){var e=n&&n.toString().match(At);return e?e[1]:""}function Pt(n,e){return It(n)===It(e)}function Ot(n,e){if(!a(e))return Pt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Pt(e[t],n))return t;return-1}var Bt={enumerable:!0,configurable:!0,get:B,set:B};function zt(n,e,t){Bt.get=function(){return this[e][t]},Bt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Bt)}function Dt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=jn({}),a=n.$options._propKeys=[];n.$parent&&dt(!1);var o=function(o){a.push(o);var i=St(o,e,t,n);mt(r,o,i),o in n||zt(n,"_props",o)};for(var i in e)o(i);dt(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=me(n);dn(n),gn();var a=We(t,null,[n._props||jn({}),r],n,"setup");if(yn(),dn(),c(a))e.render=a;else if(u(a))if(n._setupState=a,a.__sfc){var o=n._setupProxy={};for(var i in a)"__sfc"!==i&&An(o,a,i)}else for(var i in a)q(i)||An(n,a,i);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?B:A(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;d(e=n._data=c(e)?function(n,e){gn();try{return n.call(e,e)}catch(n){return Xe(n,e,"data()"),{}}finally{yn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var o=t[a];0,r&&_(r,o)||q(o)||zt(n,"_data",o)}var i=vt(e);i&&i.vmCount++}(n);else{var t=vt(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var a in e){var o=e[a],i=c(o)?o:o.get;0,r||(t[a]=new He(n,i||B,B,$t)),a in n||Lt(n,a,o)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(a(r))for(var o=0;o<r.length;o++)Ut(n,t,r[o]);else Ut(n,t,r)}}(n,e.watch)}var $t={lazy:!0};function Lt(n,e,t){var r=!on();c(t)?(Bt.get=r?Mt(e):Rt(t),Bt.set=B):(Bt.get=t.get?r&&!1!==t.cache?Mt(e):Rt(t.get):B,Bt.set=t.set||B),Object.defineProperty(n,e,Bt)}function Mt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),vn.target&&e.depend(),e.value}}function Rt(n){return function(){return n.call(this,this)}}function Ut(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Nt=0;function Ft(n){var e=n.options;if(n.super){var t=Ft(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&P(n.extendOptions,r),(e=n.options=Ct(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Vt(n){this._init(n)}function qt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var o=n.name||t.options.name;var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=Ct(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)zt(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)Lt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,U.forEach((function(n){i[n]=t[n]})),o&&(i.options.components[o]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=P({},i.options),a[r]=i,i}}function Gt(n){return n&&(n.Ctor.options.name||n.tag)}function Jt(n,e){return a(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!f(n)&&n.test(e)}function Ht(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var o in t){var i=t[o];if(i){var s=i.name;s&&!e(s)&&Xt(t,o,r,a)}}}function Xt(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Nt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Ge(!0),n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Ct(Ft(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Te(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=Nn(e._renderChildren,a),n.$scopedSlots=r,n._c=function(e,t,r,a){return ve(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return ve(n,e,t,r,a,!0)};var o=t&&t.data;mt(n,"$attrs",o&&o.attrs||r,null,!0),mt(n,"$listeners",e._parentListeners||r,null,!0)}(e),Oe(e,"beforeCreate"),function(n){var e=Un(n.$options.inject,n);e&&(dt(!1),Object.keys(e).forEach((function(t){mt(n,t,e[t])})),dt(!0))}(e),Dt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!u(t))return;var r=un?Reflect.ownKeys(t):Object.keys(t);dn(n);for(var a=0;a<r.length;a++)Rn(r[a],t[r[a]]);dn()}}(e),Oe(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Vt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=gt,n.prototype.$delete=yt,n.prototype.$watch=function(n,e,t){if(d(e))return Ut(this,n,e,t);(t=t||{}).user=!0;var r=new He(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'.concat(r.expression,'"');gn(),We(e,this,[r.value],this,a),yn()}return function(){r.teardown()}}}(Vt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(a(n))for(var o=0,i=n.length;o<i;o++)r.$on(n[o],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(a(n)){for(var r=0,o=n.length;r<o;r++)t.$off(n[r],e);return t}var i,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((i=s[l])===e||i.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?I(t):t;for(var r=I(arguments,1),a='event handler for "'.concat(n,'"'),o=0,i=t.length;o<i;o++)We(t[o],e,r,e,a)}return e}}(Vt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,o=Ae(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){Oe(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),Oe(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Vt),function(n){se(n.prototype),n.prototype.$nextTick=function(n){return st(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,o=t._parentVnode;o&&(e.$scopedSlots=qn(e.$parent,o.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&be(e._slotsProxy,e.$scopedSlots)),e.$vnode=o;try{dn(e),ke=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Xe(t,e,"render"),n=e._vnode}finally{ke=null,dn()}return a(n)&&1===n.length&&(n=n[0]),n instanceof bn||(n=xn()),n.parent=o,n}}(Vt);var Wt=[String,RegExp,Array],Zt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Wt,exclude:Wt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,o=t.componentInstance,i=t.componentOptions;n[r]={name:Gt(i),tag:a,componentInstance:o},e.push(r),this.max&&e.length>parseInt(this.max)&&Xt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Xt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Ht(n,(function(n){return Jt(e,n)}))})),this.$watch("exclude",(function(e){Ht(n,(function(n){return!Jt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=we(n),t=e&&e.componentOptions;if(t){var r=Gt(t),a=this.include,o=this.exclude;if(a&&(!r||!Jt(a,r))||o&&r&&Jt(o,r))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,x(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:fn,extend:P,mergeOptions:Ct,defineReactive:mt},n.set=gt,n.delete=yt,n.nextTick=st,n.observable=function(n){return vt(n),n},n.options=Object.create(null),U.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,P(n.options.components,Zt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=I(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Ct(this.options,n),this}}(n),qt(n),function(n){U.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Vt),Object.defineProperty(Vt.prototype,"$isServer",{get:on}),Object.defineProperty(Vt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Vt,"FunctionalRenderContext",{value:le}),Vt.version="2.7.4";var Kt=y("style,class"),Yt=y("input,textarea,option,select,progress"),Qt=y("contenteditable,draggable,spellcheck"),nr=y("events,caret,typing,plaintext-only"),er=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),tr="http://www.w3.org/1999/xlink",rr=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},ar=function(n){return rr(n)?n.slice(6,n.length):""},or=function(n){return null==n||!1===n};function ir(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=sr(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=sr(e,t.data));return function(n,e){if(i(n)||i(e))return lr(n,cr(e));return""}(e.staticClass,e.class)}function sr(n,e){return{staticClass:lr(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function lr(n,e){return n?e?n+" "+e:n:e||""}function cr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)i(e=cr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):u(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ur={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},pr=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),dr=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),fr=function(n){return pr(n)||dr(n)};var hr=Object.create(null);var vr=y("text,number,password,search,email,tel,url");var mr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ur[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),gr={create:function(n,e){yr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(yr(n,!0),yr(e))},destroy:function(n){yr(n,!0)}};function yr(n,e){var t=n.data.ref;if(i(t)){var r=n.context,o=n.componentInstance||n.elm,s=e?null:o,l=e?void 0:o;if(c(t))We(t,r,[s],r,"template ref function");else{var u=n.data.refInFor,p="string"==typeof t||"number"==typeof t,d=Sn(t),f=r.$refs;if(p||d)if(u){var h=p?f[t]:t.value;e?a(h)&&x(h,o):a(h)?h.includes(o)||h.push(o):p?(f[t]=[o],br(r,t,f[t])):t.value=[o]}else if(p){if(e&&f[t]!==o)return;f[t]=l,br(r,t,s)}else if(d){if(e&&t.value!==o)return;t.value=s}else 0}}}function br(n,e,t){var r=n._setupState;r&&_(r,e)&&(Sn(r[e])?r[e].value=t:r[e]=t)}var xr=new bn("",{},[]),kr=["create","activate","update","remove","destroy"];function _r(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,a=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===a||vr(r)&&vr(a)}(n,e)||s(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function wr(n,e,t){var r,a,o={};for(r=e;r<=t;++r)i(a=n[r].key)&&(o[a]=r);return o}var Er={create:jr,update:jr,destroy:function(n){jr(n,xr)}};function jr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,o=n===xr,i=e===xr,s=Tr(n.data.directives,n.context),l=Tr(e.data.directives,e.context),c=[],u=[];for(t in l)r=s[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,Ar(a,"update",e,n),a.def&&a.def.componentUpdated&&u.push(a)):(Ar(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var p=function(){for(var t=0;t<c.length;t++)Ar(c[t],"inserted",e,n)};o?Dn(e,"insert",p):p()}u.length&&Dn(e,"postpatch",(function(){for(var t=0;t<u.length;t++)Ar(u[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||Ar(s[t],"unbind",n,n,i)}(n,e)}var Cr=Object.create(null);function Tr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=Cr),a[Sr(r)]=r,e._setupState&&e._setupState.__sfc&&(r.def=r.def||Tt(e,"_setupState","v-"+r.name)),r.def=r.def||Tt(e.$options,"directives",r.name);return a}function Sr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Ar(n,e,t,r,a){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,a)}catch(r){Xe(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Ir=[gr,Er];function Pr(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var r,a,l=e.elm,c=n.data.attrs||{},u=e.data.attrs||{};for(r in(i(u.__ob__)||s(u._v_attr_proxy))&&(u=e.data.attrs=P({},u)),u)a=u[r],c[r]!==a&&Or(l,r,a,e.data.pre);for(r in(Z||Y)&&u.value!==c.value&&Or(l,"value",u.value),c)o(u[r])&&(rr(r)?l.removeAttributeNS(tr,ar(r)):Qt(r)||l.removeAttribute(r))}}function Or(n,e,t,r){r||n.tagName.indexOf("-")>-1?Br(n,e,t):er(e)?or(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Qt(e)?n.setAttribute(e,function(n,e){return or(e)||"false"===e?"false":"contenteditable"===n&&nr(e)?e:"true"}(e,t)):rr(e)?or(t)?n.removeAttributeNS(tr,ar(e)):n.setAttributeNS(tr,e,t):Br(n,e,t)}function Br(n,e,t){if(or(t))n.removeAttribute(e);else{if(Z&&!K&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var zr={create:Pr,update:Pr};function Dr(n,e){var t=e.elm,r=e.data,a=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(a)||o(a.staticClass)&&o(a.class)))){var s=ir(e),l=t._transitionClasses;i(l)&&(s=lr(s,cr(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var $r,Lr={create:Dr,update:Dr};function Mr(n,e,t){var r=$r;return function a(){var o=e.apply(null,arguments);null!==o&&Nr(n,a,t,r)}}var Rr=Qe&&!(en&&Number(en[1])<=53);function Ur(n,e,t,r){if(Rr){var a=Ue,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}$r.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Nr(n,e,t,r){(r||$r).removeEventListener(n,e._wrapper||e,t)}function Fr(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},r=n.data.on||{};$r=e.elm||n.elm,function(n){if(i(n.__r)){var e=Z?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),zn(t,r,Ur,Nr,Mr,e.context),$r=void 0}}var Vr,qr={create:Fr,update:Fr,destroy:function(n){return Fr(n,xr)}};function Gr(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,r,a=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(i(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=P({},c)),l)t in c||(a[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var u=o(r)?"":String(r);Jr(a,u)&&(a.value=u)}else if("innerHTML"===t&&dr(a.tagName)&&o(a.innerHTML)){(Vr=Vr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var p=Vr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;p.firstChild;)a.appendChild(p.firstChild)}else if(r!==l[t])try{a[t]=r}catch(n){}}}}function Jr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return g(t)!==g(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Hr={create:Gr,update:Gr},Xr=w((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Wr(n){var e=Zr(n.style);return n.staticStyle?P(n.staticStyle,e):e}function Zr(n){return Array.isArray(n)?O(n):"string"==typeof n?Xr(n):n}var Kr,Yr=/^--/,Qr=/\s*!important$/,na=function(n,e,t){if(Yr.test(e))n.style.setProperty(e,t);else if(Qr.test(t))n.style.setProperty(S(e),t.replace(Qr,""),"important");else{var r=ta(e);if(Array.isArray(t))for(var a=0,o=t.length;a<o;a++)n.style[r]=t[a];else n.style[r]=t}},ea=["Webkit","Moz","ms"],ta=w((function(n){if(Kr=Kr||document.createElement("div").style,"filter"!==(n=j(n))&&n in Kr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ea.length;t++){var r=ea[t]+e;if(r in Kr)return r}}));function ra(n,e){var t=e.data,r=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(r.staticStyle)&&o(r.style))){var a,s,l=e.elm,c=r.staticStyle,u=r.normalizedStyle||r.style||{},p=c||u,d=Zr(e.data.style)||{};e.data.normalizedStyle=i(d.__ob__)?P({},d):d;var f=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Wr(a.data))&&P(r,t);(t=Wr(n.data))&&P(r,t);for(var o=n;o=o.parent;)o.data&&(t=Wr(o.data))&&P(r,t);return r}(e,!0);for(s in p)o(f[s])&&na(l,s,"");for(s in f)(a=f[s])!==p[s]&&na(l,s,null==a?"":a)}}var aa={create:ra,update:ra},oa=/\s+/;function ia(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(oa).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function sa(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(oa).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function la(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&P(e,ca(n.name||"v")),P(e,n),e}return"string"==typeof n?ca(n):void 0}}var ca=w((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),ua=X&&!K,pa="transition",da="transitionend",fa="animation",ha="animationend";ua&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(pa="WebkitTransition",da="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(fa="WebkitAnimation",ha="webkitAnimationEnd"));var va=X?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function ma(n){va((function(){va(n)}))}function ga(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ia(n,e))}function ya(n,e){n._transitionClasses&&x(n._transitionClasses,e),sa(n,e)}function ba(n,e,t){var r=ka(n,e),a=r.type,o=r.timeout,i=r.propCount;if(!a)return t();var s="transition"===a?da:ha,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),o+1),n.addEventListener(s,u)}var xa=/\b(transform|all)(,|$)/;function ka(n,e){var t,r=window.getComputedStyle(n),a=(r[pa+"Delay"]||"").split(", "),o=(r[pa+"Duration"]||"").split(", "),i=_a(a,o),s=(r[fa+"Delay"]||"").split(", "),l=(r[fa+"Duration"]||"").split(", "),c=_a(s,l),u=0,p=0;return"transition"===e?i>0&&(t="transition",u=i,p=o.length):"animation"===e?c>0&&(t="animation",u=c,p=l.length):p=(t=(u=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:u,propCount:p,hasTransform:"transition"===t&&xa.test(r[pa+"Property"])}}function _a(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return wa(e)+wa(n[t])})))}function wa(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ea(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=la(n.data.transition);if(!o(r)&&!i(t._enterCb)&&1===t.nodeType){for(var a=r.css,s=r.type,l=r.enterClass,p=r.enterToClass,d=r.enterActiveClass,f=r.appearClass,h=r.appearToClass,v=r.appearActiveClass,m=r.beforeEnter,y=r.enter,b=r.afterEnter,x=r.enterCancelled,k=r.beforeAppear,_=r.appear,w=r.afterAppear,E=r.appearCancelled,j=r.duration,C=Se,T=Se.$vnode;T&&T.parent;)C=T.context,T=T.parent;var S=!C._isMounted||!n.isRootInsert;if(!S||_||""===_){var A=S&&f?f:l,I=S&&v?v:d,P=S&&h?h:p,O=S&&k||m,B=S&&c(_)?_:y,z=S&&w||b,D=S&&E||x,$=g(u(j)?j.enter:j);0;var L=!1!==a&&!K,R=Ta(B),U=t._enterCb=M((function(){L&&(ya(t,P),ya(t,I)),U.cancelled?(L&&ya(t,A),D&&D(t)):z&&z(t),t._enterCb=null}));n.data.show||Dn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),B&&B(t,U)})),O&&O(t),L&&(ga(t,A),ga(t,I),ma((function(){ya(t,A),U.cancelled||(ga(t,P),R||(Ca($)?setTimeout(U,$):ba(t,s,U)))}))),n.data.show&&(e&&e(),B&&B(t,U)),L||R||U()}}}function ja(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=la(n.data.transition);if(o(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var a=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,p=r.leaveActiveClass,d=r.beforeLeave,f=r.leave,h=r.afterLeave,v=r.leaveCancelled,m=r.delayLeave,y=r.duration,b=!1!==a&&!K,x=Ta(f),k=g(u(y)?y.leave:y);0;var _=t._leaveCb=M((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),b&&(ya(t,c),ya(t,p)),_.cancelled?(b&&ya(t,l),v&&v(t)):(e(),h&&h(t)),t._leaveCb=null}));m?m(w):w()}function w(){_.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),b&&(ga(t,l),ga(t,p),ma((function(){ya(t,l),_.cancelled||(ga(t,c),x||(Ca(k)?setTimeout(_,k):ba(t,s,_)))}))),f&&f(t,_),b||x||_())}}function Ca(n){return"number"==typeof n&&!isNaN(n)}function Ta(n){if(o(n))return!1;var e=n.fns;return i(e)?Ta(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Sa(n,e){!0!==e.data.show&&Ea(e)}var Aa=function(n){var e,t,r={},c=n.modules,u=n.nodeOps;for(e=0;e<kr.length;++e)for(r[kr[e]]=[],t=0;t<c.length;++t)i(c[t][kr[e]])&&r[kr[e]].push(c[t][kr[e]]);function p(n){var e=u.parentNode(n);i(e)&&u.removeChild(e,n)}function d(n,e,t,a,o,l,c){if(i(n.elm)&&i(l)&&(n=l[c]=_n(n)),n.isRootInsert=!o,!function(n,e,t,a){var o=n.data;if(i(o)){var l=i(n.componentInstance)&&o.keepAlive;if(i(o=o.hook)&&i(o=o.init)&&o(n,!1),i(n.componentInstance))return f(n,e),h(t,n.elm,a),s(l)&&function(n,e,t,a){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(o=s.data)&&i(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](xr,s);e.push(s);break}h(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var p=n.data,d=n.children,m=n.tag;i(m)?(n.elm=n.ns?u.createElementNS(n.ns,m):u.createElement(m,n),b(n),v(n,d,e),i(p)&&g(n,e),h(t,n.elm,a)):s(n.isComment)?(n.elm=u.createComment(n.text),h(t,n.elm,a)):(n.elm=u.createTextNode(n.text),h(t,n.elm,a))}}function f(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,m(n)?(g(n,e),b(n)):(yr(n),e.push(n))}function h(n,e,t){i(n)&&(i(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function v(n,e,t){if(a(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function m(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function g(n,t){for(var a=0;a<r.create.length;++a)r.create[a](xr,n);i(e=n.data.hook)&&(i(e.create)&&e.create(xr,n),i(e.insert)&&t.push(n))}function b(n){var e;if(i(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;i(e=Se)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function x(n,e,t,r,a,o){for(;r<=a;++r)d(t[r],o,n,e,!1,t,r)}function k(n){var e,t,a=n.data;if(i(a))for(i(e=a.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)k(n.children[t])}function _(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(w(r),k(r)):p(r.elm))}}function w(n,e){if(i(e)||i(n.data)){var t,a=r.remove.length+1;for(i(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&p(n)}return t.listeners=e,t}(n.elm,a),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&w(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else p(n.elm)}function E(n,e,t,r){for(var a=t;a<r;a++){var o=e[a];if(i(o)&&_r(n,o))return a}}function j(n,e,t,a,l,c){if(n!==e){i(e.elm)&&i(a)&&(e=a[l]=_n(e));var p=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?S(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var f,h=e.data;i(h)&&i(f=h.hook)&&i(f=f.prepatch)&&f(n,e);var v=n.children,g=e.children;if(i(h)&&m(e)){for(f=0;f<r.update.length;++f)r.update[f](n,e);i(f=h.hook)&&i(f=f.update)&&f(n,e)}o(e.text)?i(v)&&i(g)?v!==g&&function(n,e,t,r,a){var s,l,c,p=0,f=0,h=e.length-1,v=e[0],m=e[h],g=t.length-1,y=t[0],b=t[g],k=!a;for(0;p<=h&&f<=g;)o(v)?v=e[++p]:o(m)?m=e[--h]:_r(v,y)?(j(v,y,r,t,f),v=e[++p],y=t[++f]):_r(m,b)?(j(m,b,r,t,g),m=e[--h],b=t[--g]):_r(v,b)?(j(v,b,r,t,g),k&&u.insertBefore(n,v.elm,u.nextSibling(m.elm)),v=e[++p],b=t[--g]):_r(m,y)?(j(m,y,r,t,f),k&&u.insertBefore(n,m.elm,v.elm),m=e[--h],y=t[++f]):(o(s)&&(s=wr(e,p,h)),o(l=i(y.key)?s[y.key]:E(y,e,p,h))?d(y,r,n,v.elm,!1,t,f):_r(c=e[l],y)?(j(c,y,r,t,f),e[l]=void 0,k&&u.insertBefore(n,c.elm,v.elm)):d(y,r,n,v.elm,!1,t,f),y=t[++f]);p>h?x(n,o(t[g+1])?null:t[g+1].elm,t,f,g,r):f>g&&_(e,p,h)}(p,v,g,t,c):i(g)?(i(n.text)&&u.setTextContent(p,""),x(p,null,g,0,g.length-1,t)):i(v)?_(v,0,v.length-1):i(n.text)&&u.setTextContent(p,""):n.text!==e.text&&u.setTextContent(p,e.text),i(h)&&i(f=h.hook)&&i(f=f.postpatch)&&f(n,e)}}}function C(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var T=y("attrs,class,staticClass,staticStyle,key");function S(n,e,t,r){var a,o=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(a=l.hook)&&i(a=a.init)&&a(e,!0),i(a=e.componentInstance)))return f(e,t),!0;if(i(o)){if(i(c))if(n.hasChildNodes())if(i(a=l)&&i(a=a.domProps)&&i(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var u=!0,p=n.firstChild,d=0;d<c.length;d++){if(!p||!S(p,c[d],t,r)){u=!1;break}p=p.nextSibling}if(!u||p)return!1}else v(e,c,t);if(i(l)){var h=!1;for(var m in l)if(!T(m)){h=!0,g(e,t);break}!h&&l.class&&Pn(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!o(e)){var l,c=!1,p=[];if(o(n))c=!0,d(e,p);else{var f=i(n.nodeType);if(!f&&_r(n,e))j(n,e,p,null,null,a);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&S(n,e,p))return C(e,p,!0),n;l=n,n=new bn(u.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,v=u.parentNode(h);if(d(e,p,h._leaveCb?null:v,u.nextSibling(h)),i(e.parent))for(var g=e.parent,y=m(e);g;){for(var b=0;b<r.destroy.length;++b)r.destroy[b](g);if(g.elm=e.elm,y){for(var x=0;x<r.create.length;++x)r.create[x](xr,g);var w=g.data.hook.insert;if(w.merged)for(var E=1;E<w.fns.length;E++)w.fns[E]()}else yr(g);g=g.parent}i(v)?_([n],0,0):i(n.tag)&&k(n)}}return C(e,p,c),e.elm}i(n)&&k(n)}}({nodeOps:mr,modules:[zr,Lr,qr,Hr,aa,X?{create:Sa,activate:Sa,remove:function(n,e){!0!==n.data.show?ja(n,e):e()}}:{}].concat(Ir)});K&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&La(n,"input")}));var Ia={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Dn(t,"postpatch",(function(){Ia.componentUpdated(n,e,t)})):Pa(n,e,t.context),n._vOptions=[].map.call(n.options,za)):("textarea"===t.tag||vr(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Da),n.addEventListener("compositionend",$a),n.addEventListener("change",$a),K&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Pa(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,za);if(a.some((function(n,e){return!$(n,r[e])})))(n.multiple?e.value.some((function(n){return Ba(n,a)})):e.value!==e.oldValue&&Ba(e.value,a))&&La(n,"change")}}};function Pa(n,e,t){Oa(n,e,t),(Z||Y)&&setTimeout((function(){Oa(n,e,t)}),0)}function Oa(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var o,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],a)o=L(r,za(i))>-1,i.selected!==o&&(i.selected=o);else if($(za(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function Ba(n,e){return e.every((function(e){return!$(e,n)}))}function za(n){return"_value"in n?n._value:n.value}function Da(n){n.target.composing=!0}function $a(n){n.target.composing&&(n.target.composing=!1,La(n.target,"input"))}function La(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ma(n){return!n.componentInstance||n.data&&n.data.transition?n:Ma(n.componentInstance._vnode)}var Ra={model:Ia,show:{bind:function(n,e,t){var r=e.value,a=(t=Ma(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,Ea(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Ma(t)).data&&t.data.transition?(t.data.show=!0,r?Ea(t,(function(){n.style.display=n.__vOriginalDisplay})):ja(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},Ua={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Na(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Na(we(e.children)):n}function Fa(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var r in a)e[j(r)]=a[r];return e}function Va(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var qa=function(n){return n.tag||Vn(n)},Ga=function(n){return"show"===n.name},Ja={name:"transition",props:Ua,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(qa)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var o=Na(a);if(!o)return a;if(this._leaving)return Va(n,a);var i="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?i+"comment":i+o.tag:l(o.key)?0===String(o.key).indexOf(i)?o.key:i+o.key:o.key;var s=(o.data||(o.data={})).transition=Fa(this),c=this._vnode,u=Na(c);if(o.data.directives&&o.data.directives.some(Ga)&&(o.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,u)&&!Vn(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var p=u.data.transition=P({},s);if("out-in"===r)return this._leaving=!0,Dn(p,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Va(n,a);if("in-out"===r){if(Vn(o))return c;var d,f=function(){d()};Dn(s,"afterEnter",f),Dn(s,"enterCancelled",f),Dn(p,"delayLeave",(function(n){d=n}))}}return a}}},Ha=P({tag:String,moveClass:String},Ua);function Xa(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Wa(n){n.data.newPos=n.elm.getBoundingClientRect()}function Za(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(r,"px,").concat(a,"px)"),o.transitionDuration="0s"}}delete Ha.mode;var Ka={Transition:Ja,TransitionGroup:{props:Ha,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Ae(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],o=this.children=[],i=Fa(this),s=0;s<a.length;s++){if((u=a[s]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))o.push(u),t[u.key]=u,(u.data||(u.data={})).transition=i;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var u;(u=r[s]).data.transition=i,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?l.push(u):c.push(u)}this.kept=n(e,null,l),this.removed=c}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Xa),n.forEach(Wa),n.forEach(Za),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;ga(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(da,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(da,n),t._moveCb=null,ya(t,e))})}})))},methods:{hasMove:function(n,e){if(!ua)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){sa(t,n)})),ia(t,e),t.style.display="none",this.$el.appendChild(t);var r=ka(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function Ya(n,e){for(var t in e)n[t]=e[t];return n}Vt.config.mustUseProp=function(n,e,t){return"value"===t&&Yt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Vt.config.isReservedTag=fr,Vt.config.isReservedAttr=Kt,Vt.config.getTagNamespace=function(n){return dr(n)?"svg":"math"===n?"math":void 0},Vt.config.isUnknownElement=function(n){if(!X)return!0;if(fr(n))return!1;if(n=n.toLowerCase(),null!=hr[n])return hr[n];var e=document.createElement(n);return n.indexOf("-")>-1?hr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:hr[n]=/HTMLUnknownElement/.test(e.toString())},P(Vt.options.directives,Ra),P(Vt.options.components,Ka),Vt.prototype.__patch__=X?Aa:B,Vt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=xn),Oe(n,"beforeMount"),r=function(){n._update(n._render(),t)},new He(n,r,B,{before:function(){n._isMounted&&!n._isDestroyed&&Oe(n,"beforeUpdate")}},!0),t=!1;var a=n._preWatchers;if(a)for(var o=0;o<a.length;o++)a[o].run();return null==n.$vnode&&(n._isMounted=!0,Oe(n,"mounted")),n}(this,n=n&&X?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},X&&setTimeout((function(){F.devtools&&sn&&sn.emit("init",Vt)}),0);var Qa=/[!'()*]/g,no=function(n){return"%"+n.charCodeAt(0).toString(16)},eo=/%2C/g,to=function(n){return encodeURIComponent(n).replace(Qa,no).replace(eo,",")};function ro(n){try{return decodeURIComponent(n)}catch(n){0}return n}var ao=function(n){return null==n||"object"==typeof n?n:String(n)};function oo(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=ro(t.shift()),a=t.length>0?ro(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function io(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return to(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(to(e)):r.push(to(e)+"="+to(n)))})),r.join("&")}return to(e)+"="+to(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var so=/\/?$/;function lo(n,e,t,r){var a=r&&r.options.stringifyQuery,o=e.query||{};try{o=co(o)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:fo(e,a),matched:n?po(n):[]};return t&&(i.redirectedFrom=fo(t,a)),Object.freeze(i)}function co(n){if(Array.isArray(n))return n.map(co);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=co(n[t]);return e}return n}var uo=lo(null,{path:"/"});function po(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function fo(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||io)(r)+a}function ho(n,e,t){return e===uo?n===e:!!e&&(n.path&&e.path?n.path.replace(so,"")===e.path.replace(so,"")&&(t||n.hash===e.hash&&vo(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&vo(n.query,e.query)&&vo(n.params,e.params))))}function vo(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var o=n[t];if(r[a]!==t)return!1;var i=e[t];return null==o||null==i?o===i:"object"==typeof o&&"object"==typeof i?vo(o,i):String(o)===String(i)}))}function mo(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],o=t.enteredCbs[r];if(a&&o){delete t.enteredCbs[r];for(var i=0;i<o.length;i++)a._isBeingDestroyed||o[i](a)}}}}var go={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,o=e.data;o.routerView=!0;for(var i=a.$createElement,s=t.name,l=a.$route,c=a._routerViewCache||(a._routerViewCache={}),u=0,p=!1;a&&a._routerRoot!==a;){var d=a.$vnode?a.$vnode.data:{};d.routerView&&u++,d.keepAlive&&a._directInactive&&a._inactive&&(p=!0),a=a.$parent}if(o.routerViewDepth=u,p){var f=c[s],h=f&&f.component;return h?(f.configProps&&yo(h,o,f.route,f.configProps),i(h,o,r)):i()}var v=l.matched[u],m=v&&v.components[s];if(!v||!m)return c[s]=null,i();c[s]={component:m},o.registerRouteInstance=function(n,e){var t=v.instances[s];(e&&t!==n||!e&&t===n)&&(v.instances[s]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){v.instances[s]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==v.instances[s]&&(v.instances[s]=n.componentInstance),mo(l)};var g=v.props&&v.props[s];return g&&(Ya(c[s],{route:l,configProps:g}),yo(m,o,l,g)),i(m,o,r)}};function yo(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=Ya({},a);var o=e.attrs=e.attrs||{};for(var i in a)n.props&&i in n.props||(o[i]=a[i],delete a[i])}}function bo(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function xo(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var ko=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},_o=$o,wo=So,Eo=function(n,e){return Io(So(n,e),e)},jo=Io,Co=Do,To=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function So(n,e){for(var t,r=[],a=0,o=0,i="",s=e&&e.delimiter||"/";null!=(t=To.exec(n));){var l=t[0],c=t[1],u=t.index;if(i+=n.slice(o,u),o=u+l.length,c)i+=c[1];else{var p=n[o],d=t[2],f=t[3],h=t[4],v=t[5],m=t[6],g=t[7];i&&(r.push(i),i="");var y=null!=d&&null!=p&&p!==d,b="+"===m||"*"===m,x="?"===m||"*"===m,k=t[2]||s,_=h||v;r.push({name:f||a++,prefix:d||"",delimiter:k,optional:x,repeat:b,partial:y,asterisk:!!g,pattern:_?Oo(_):g?".*":"[^"+Po(k)+"]+?"})}}return o<n.length&&(i+=n.substr(o)),i&&r.push(i),r}function Ao(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Io(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",zo(e)));return function(e,r){for(var a="",o=e||{},i=(r||{}).pretty?Ao:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=o[l.name];if(null==u){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ko(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var p=0;p<u.length;p++){if(c=i(u[p]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===p?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function Po(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Oo(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Bo(n,e){return n.keys=e,n}function zo(n){return n&&n.sensitive?"":"i"}function Do(n,e,t){ko(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,o="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)o+=Po(s);else{var l=Po(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=Po(t.delimiter||"/"),p=o.slice(-u.length)===u;return r||(o=(p?o.slice(0,-u.length):o)+"(?:"+u+"(?=$))?"),o+=a?"$":r&&p?"":"(?="+u+"|$)",Bo(new RegExp("^"+o,zo(t)),e)}function $o(n,e,t){return ko(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Bo(n,e)}(n,e):ko(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push($o(n[a],e,t).source);return Bo(new RegExp("(?:"+r.join("|")+")",zo(t)),e)}(n,e,t):function(n,e,t){return Do(So(n,t),e,t)}(n,e,t)}_o.parse=wo,_o.compile=Eo,_o.tokensToFunction=jo,_o.tokensToRegExp=Co;var Lo=Object.create(null);function Mo(n,e,t){e=e||{};try{var r=Lo[n]||(Lo[n]=_o.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ro(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var o=(a=Ya({},n)).params;return o&&"object"==typeof o&&(a.params=Ya({},o)),a}if(!a.path&&a.params&&e){(a=Ya({},a))._normalized=!0;var i=Ya(Ya({},e.params),a.params);if(e.name)a.name=e.name,a.params=i;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;a.path=Mo(s,i,e.path)}else 0;return a}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),c=e&&e.path||"/",u=l.path?bo(l.path,c,t||a.append):c,p=function(n,e,t){void 0===e&&(e={});var r,a=t||oo;try{r=a(n||"")}catch(n){r={}}for(var o in e){var i=e[o];r[o]=Array.isArray(i)?i.map(ao):ao(i)}return r}(l.query,a.query,r&&r.options.parseQuery),d=a.hash||l.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:u,query:p,hash:d}}var Uo,No=function(){},Fo={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),o=a.location,i=a.route,s=a.href,l={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,p=null==c?"router-link-active":c,d=null==u?"router-link-exact-active":u,f=null==this.activeClass?p:this.activeClass,h=null==this.exactActiveClass?d:this.exactActiveClass,v=i.redirectedFrom?lo(null,Ro(i.redirectedFrom),null,t):i;l[h]=ho(r,v,this.exactPath),l[f]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(so,"/").indexOf(e.path.replace(so,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,v);var m=l[h]?this.ariaCurrentValue:null,g=function(n){Vo(n)&&(e.replace?t.replace(o,No):t.push(o,No))},y={click:Vo};Array.isArray(this.event)?this.event.forEach((function(n){y[n]=g})):y[this.event]=g;var b={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:i,navigate:g,isActive:l[f],isExactActive:l[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)b.on=y,b.attrs={href:s,"aria-current":m};else{var k=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(k){k.isStatic=!1;var _=k.data=Ya({},k.data);for(var w in _.on=_.on||{},_.on){var E=_.on[w];w in y&&(_.on[w]=Array.isArray(E)?E:[E])}for(var j in y)j in _.on?_.on[j].push(y[j]):_.on[j]=g;var C=k.data.attrs=Ya({},k.data.attrs);C.href=s,C["aria-current"]=m}else b.on=y}return n(this.tag,b,this.$slots.default)}};function Vo(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var qo="undefined"!=typeof window;function Go(n,e,t,r,a){var o=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,o,i){var s=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return xo(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var p={path:u,regex:Jo(u,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:i,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var o=i?xo(i+"/"+a.path):void 0;n(e,t,r,a,p,o)}));t[p.path]||(e.push(p.path),t[p.path]=p);if(void 0!==a.alias)for(var d=Array.isArray(a.alias)?a.alias:[a.alias],f=0;f<d.length;++f){0;var h={path:d[f],children:a.children};n(e,t,r,h,o,p.path||"/")}l&&(r[l]||(r[l]=p))}(o,i,s,n,a)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:i,nameMap:s}}function Jo(n,e){return _o(n,[],e)}function Ho(n,e){var t=Go(n),r=t.pathList,a=t.pathMap,o=t.nameMap;function i(n,t,i){var s=Ro(n,t,!1,e),c=s.name;if(c){var u=o[c];if(!u)return l(null,s);var p=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in s.params)&&p.indexOf(d)>-1&&(s.params[d]=t.params[d]);return s.path=Mo(u.path,s.params),l(u,s,i)}if(s.path){s.params={};for(var f=0;f<r.length;f++){var h=r[f],v=a[h];if(Xo(v.regex,s.path,s.params))return l(v,s,i)}}return l(null,s)}function s(n,t){var r=n.redirect,a="function"==typeof r?r(lo(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var s=a,c=s.name,u=s.path,p=t.query,d=t.hash,f=t.params;if(p=s.hasOwnProperty("query")?s.query:p,d=s.hasOwnProperty("hash")?s.hash:d,f=s.hasOwnProperty("params")?s.params:f,c){o[c];return i({_normalized:!0,name:c,query:p,hash:d,params:f},void 0,t)}if(u){var h=function(n,e){return bo(n,e.parent?e.parent.path:"/",!0)}(u,n);return i({_normalized:!0,path:Mo(h,f),query:p,hash:d},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:Mo(t,e.params)});if(r){var a=r.matched,o=a[a.length-1];return e.params=r.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):lo(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;Go([e||n],r,a,o,t),t&&t.alias.length&&Go(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,o,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){Go(n,r,a,o)}}}function Xo(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,o=r.length;a<o;++a){var i=n.keys[a-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[a]?ro(r[a]):r[a])}return!0}var Wo=qo&&window.performance&&window.performance.now?window.performance:Date;function Zo(){return Wo.now().toFixed(3)}var Ko=Zo();function Yo(){return Ko}function Qo(n){return Ko=n}var ni=Object.create(null);function ei(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Ya({},window.history.state);return t.key=Yo(),window.history.replaceState(t,"",e),window.addEventListener("popstate",ai),function(){window.removeEventListener("popstate",ai)}}function ti(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var o=function(){var n=Yo();if(n)return ni[n]}(),i=a.call(n,e,t,r?o:null);i&&("function"==typeof i.then?i.then((function(n){ci(n,o)})).catch((function(n){0})):ci(i,o))}))}}function ri(){var n=Yo();n&&(ni[n]={x:window.pageXOffset,y:window.pageYOffset})}function ai(n){ri(),n.state&&n.state.key&&Qo(n.state.key)}function oi(n){return si(n.x)||si(n.y)}function ii(n){return{x:si(n.x)?n.x:window.pageXOffset,y:si(n.y)?n.y:window.pageYOffset}}function si(n){return"number"==typeof n}var li=/^#\d/;function ci(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=li.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,o={x:si((t=o).x)?t.x:0,y:si(t.y)?t.y:0})}else oi(n)&&(e=ii(n))}else r&&oi(n)&&(e=ii(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ui,pi=qo&&((-1===(ui=window.navigator.userAgent).indexOf("Android 2.")&&-1===ui.indexOf("Android 4.0")||-1===ui.indexOf("Mobile Safari")||-1!==ui.indexOf("Chrome")||-1!==ui.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function di(n,e){ri();var t=window.history;try{if(e){var r=Ya({},t.state);r.key=Yo(),t.replaceState(r,"",n)}else t.pushState({key:Qo(Zo())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function fi(n){di(n,!0)}function hi(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}var vi={redirected:2,aborted:4,cancelled:8,duplicated:16};function mi(n,e){return yi(n,e,vi.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return bi.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function gi(n,e){return yi(n,e,vi.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function yi(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var bi=["params","query","hash"];function xi(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ki(n,e){return xi(n)&&n._isRouter&&(null==e||n.type===e)}function _i(n){return function(e,t,r){var a=!1,o=0,i=null;wi(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,o++;var l,c=Ci((function(e){var a;((a=e).__esModule||ji&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Uo.extend(e),t.components[s]=e,--o<=0&&r()})),u=Ci((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=xi(n)?n:new Error(e),r(i))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var p=l.component;p&&"function"==typeof p.then&&p.then(c,u)}}})),a||r()}}function wi(n,e){return Ei(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ei(n){return Array.prototype.concat.apply([],n)}var ji="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ci(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Ti=function(n,e){this.router=n,this.base=function(n){if(!n)if(qo){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=uo,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Si(n,e,t,r){var a=wi(n,(function(n,r,a,o){var i=function(n,e){"function"!=typeof n&&(n=Uo.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,a,o)})):t(i,r,a,o)}));return Ei(r?a.reverse():a)}function Ai(n,e){if(e)return function(){return n.apply(e,arguments)}}Ti.prototype.listen=function(n){this.cb=n},Ti.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ti.prototype.onError=function(n){this.errorCbs.push(n)},Ti.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,o)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(ki(n,vi.redirected)&&o===uo||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ti.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var o,i,s=function(n){!ki(n)&&xi(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=a.matched.length-1;if(ho(n,a)&&l===c&&n.matched[l]===a.matched[c])return this.ensureURL(),n.hash&&ti(this.router,a,n,!1),s(((i=yi(o=a,n,vi.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",i));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),p=u.updated,d=u.deactivated,f=u.activated,h=[].concat(function(n){return Si(n,"beforeRouteLeave",Ai,!0)}(d),this.router.beforeHooks,function(n){return Si(n,"beforeRouteUpdate",Ai)}(p),f.map((function(n){return n.beforeEnter})),_i(f)),v=function(e,t){if(r.pending!==n)return s(gi(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return yi(n,e,vi.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):xi(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(mi(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};hi(h,v,(function(){hi(function(n){return Si(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,o){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(f).concat(r.router.resolveHooks),v,(function(){if(r.pending!==n)return s(gi(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){mo(n)}))}))}))},Ti.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ti.prototype.setupListeners=function(){},Ti.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=uo,this.pending=null};var Ii=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Pi(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=pi&&t;r&&this.listeners.push(ei());var a=function(){var t=n.current,a=Pi(n.base);n.current===uo&&a===n._startLocation||n.transitionTo(a,(function(n){r&&ti(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){di(xo(r.base+n.fullPath)),ti(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){fi(xo(r.base+n.fullPath)),ti(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Pi(this.base)!==this.current.fullPath){var e=xo(this.base+this.current.fullPath);n?di(e):fi(e)}},e.prototype.getCurrentLocation=function(){return Pi(this.base)},e}(Ti);function Pi(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(xo(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Oi=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Pi(n);if(!/^\/#/.test(e))return window.location.replace(xo(n+"/#"+e)),!0}(this.base)||Bi()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=pi&&e;t&&this.listeners.push(ei());var r=function(){var e=n.current;Bi()&&n.transitionTo(zi(),(function(r){t&&ti(n.router,r,e,!0),pi||Li(r.fullPath)}))},a=pi?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){$i(n.fullPath),ti(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Li(n.fullPath),ti(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;zi()!==e&&(n?$i(e):Li(e))},e.prototype.getCurrentLocation=function(){return zi()},e}(Ti);function Bi(){var n=zi();return"/"===n.charAt(0)||(Li("/"+n),!1)}function zi(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Di(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function $i(n){pi?di(Di(n)):window.location.hash=n}function Li(n){pi?fi(Di(n)):window.location.replace(Di(n))}var Mi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ki(n,vi.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ti),Ri=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ho(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!pi&&!1!==n.fallback,this.fallback&&(e="hash"),qo||(e="abstract"),this.mode=e,e){case"history":this.history=new Ii(this,n.base);break;case"hash":this.history=new Oi(this,n.base,this.fallback);break;case"abstract":this.history=new Mi(this,n.base);break;default:0}},Ui={currentRoute:{configurable:!0}};function Ni(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Ri.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ui.currentRoute.get=function(){return this.history&&this.history.current},Ri.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Ii||t instanceof Oi){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;pi&&a&&"fullPath"in n&&ti(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Ri.prototype.beforeEach=function(n){return Ni(this.beforeHooks,n)},Ri.prototype.beforeResolve=function(n){return Ni(this.resolveHooks,n)},Ri.prototype.afterEach=function(n){return Ni(this.afterHooks,n)},Ri.prototype.onReady=function(n,e){this.history.onReady(n,e)},Ri.prototype.onError=function(n){this.history.onError(n)},Ri.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Ri.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Ri.prototype.go=function(n){this.history.go(n)},Ri.prototype.back=function(){this.go(-1)},Ri.prototype.forward=function(){this.go(1)},Ri.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Ri.prototype.resolve=function(n,e,t){var r=Ro(n,e=e||this.history.current,t,this),a=this.match(r,e),o=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?xo(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:a}},Ri.prototype.getRoutes=function(){return this.matcher.getRoutes()},Ri.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==uo&&this.history.transitionTo(this.history.getCurrentLocation())},Ri.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==uo&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Ri.prototype,Ui),Ri.install=function n(e){if(!n.installed||Uo!==e){n.installed=!0,Uo=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",go),e.component("RouterLink",Fo);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Ri.version="3.5.4",Ri.isNavigationFailure=ki,Ri.NavigationFailureType=vi,Ri.START_LOCATION=uo,qo&&window.Vue&&window.Vue.use(Ri);var Fi=Ri;t(103);t(126);var Vi={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,331)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,330))},qi={"v-6768a9e7":()=>t.e(5).then(t.bind(null,332)),"v-4d529c47":()=>t.e(6).then(t.bind(null,333)),"v-4b554a7a":()=>t.e(7).then(t.bind(null,334)),"v-6acd4cd9":()=>t.e(8).then(t.bind(null,335)),"v-5c0b7536":()=>t.e(9).then(t.bind(null,336)),"v-1f93be54":()=>t.e(10).then(t.bind(null,337)),"v-22b1ec1c":()=>t.e(11).then(t.bind(null,338)),"v-47d17d96":()=>t.e(12).then(t.bind(null,339)),"v-65dbf974":()=>t.e(13).then(t.bind(null,340)),"v-fcfa1de8":()=>t.e(14).then(t.bind(null,341)),"v-5e4c81c5":()=>t.e(15).then(t.bind(null,342)),"v-ec95f9fa":()=>t.e(16).then(t.bind(null,343)),"v-9048fa48":()=>t.e(17).then(t.bind(null,344)),"v-0e8cebc8":()=>t.e(18).then(t.bind(null,345)),"v-c4f49838":()=>t.e(19).then(t.bind(null,346)),"v-1548b5a9":()=>t.e(20).then(t.bind(null,347)),"v-68163d88":()=>t.e(21).then(t.bind(null,348)),"v-591adf23":()=>t.e(22).then(t.bind(null,349)),"v-0feb9fa6":()=>t.e(23).then(t.bind(null,350)),"v-65efea34":()=>t.e(24).then(t.bind(null,351)),"v-1e2c6bdc":()=>t.e(25).then(t.bind(null,352)),"v-c16372ea":()=>t.e(26).then(t.bind(null,353)),"v-05d14a18":()=>t.e(27).then(t.bind(null,354)),"v-cddb19c0":()=>t.e(28).then(t.bind(null,355)),"v-6849e8f8":()=>t.e(29).then(t.bind(null,356)),"v-00e56428":()=>t.e(30).then(t.bind(null,357)),"v-4e647fa2":()=>t.e(31).then(t.bind(null,358)),"v-33194080":()=>t.e(32).then(t.bind(null,359)),"v-7d53ccf6":()=>t.e(33).then(t.bind(null,360)),"v-acb4ec08":()=>t.e(34).then(t.bind(null,361)),"v-c3cad6c0":()=>t.e(35).then(t.bind(null,362)),"v-73d54d6b":()=>t.e(36).then(t.bind(null,363)),"v-707e3d4d":()=>t.e(37).then(t.bind(null,364)),"v-15fef6fe":()=>t.e(38).then(t.bind(null,365)),"v-4ced6830":()=>t.e(39).then(t.bind(null,366)),"v-3f867205":()=>t.e(40).then(t.bind(null,367)),"v-61854e96":()=>t.e(41).then(t.bind(null,368)),"v-ecddd03c":()=>t.e(42).then(t.bind(null,369)),"v-d62bce2e":()=>t.e(43).then(t.bind(null,370)),"v-27bffdd9":()=>t.e(44).then(t.bind(null,371)),"v-f9d0d0b6":()=>t.e(45).then(t.bind(null,372)),"v-64b2788e":()=>t.e(46).then(t.bind(null,373)),"v-228b074f":()=>t.e(47).then(t.bind(null,374)),"v-9671cbb4":()=>t.e(48).then(t.bind(null,375)),"v-71f69e9c":()=>t.e(49).then(t.bind(null,376)),"v-6a00f8d1":()=>t.e(50).then(t.bind(null,377)),"v-53104ef6":()=>t.e(51).then(t.bind(null,378)),"v-1a9d53e5":()=>t.e(52).then(t.bind(null,379)),"v-150b83f6":()=>t.e(53).then(t.bind(null,380)),"v-95c08fd2":()=>t.e(54).then(t.bind(null,381)),"v-77761d97":()=>t.e(55).then(t.bind(null,382)),"v-821f1cb0":()=>t.e(56).then(t.bind(null,383)),"v-a113e2c4":()=>t.e(57).then(t.bind(null,384))};function Gi(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ji=/-(\w)/g,Hi=Gi(n=>n.replace(Ji,(n,e)=>e?e.toUpperCase():"")),Xi=/\B([A-Z])/g,Wi=Gi(n=>n.replace(Xi,"-$1").toLowerCase()),Zi=Gi(n=>n.charAt(0).toUpperCase()+n.slice(1));function Ki(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Zi(Hi(e))):n(Zi(e))||n(Wi(e))}const Yi=Object.assign({},Vi,qi),Qi=n=>Yi[n],ns=n=>qi[n],es=n=>Vi[n],ts=n=>Vt.component(n);function rs(n){return Ki(ns,n)}function as(n){return Ki(es,n)}function os(n){return Ki(Qi,n)}function is(n){return Ki(ts,n)}function ss(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!is(n)&&os(n)){const e=await os(n)();Vt.component(n,e.default)}}))}function ls(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var cs=t(91),us=t.n(cs),ps=t(92),ds=t.n(ps),fs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${ds()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=vs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ms(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return us()([{name:"description",content:this.$description}],n,this.siteMeta,gs)},updateCanonicalLink(){hs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",vs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ms(null,this.currentMetaTags),hs()}};function hs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function vs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ms(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function gs(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ys=t(50),bs={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ys)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],i=e[n+1],s=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(o.hash)){const t=o;if(a===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},xs=t(24),ks=t.n(xs),_s={mounted(){ks.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Vt.component(n.name)||ks.a.start(),t()}),this.$router.afterEach(()=>{ks.a.done(),this.isSidebarOpen=!1})}};t(233),t(234);class ws{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Es={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new ws).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var js={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Cs={},Ts=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Ss=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:js[n]},As=function n(e,t,r){var a=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))a[n]=t[n];else{var e=n.replace("data","");a.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,o=e.children;a.appendChild(n(t,r,o))})),a},Is=function(n,e,t){var r,a=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==a.length||t?a:a[0]},Ps=function(n,e){var t,r,a=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<template>([\s\S]+)<\/template>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:a&&a[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Ts(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),a=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,o=[eval][0](a);return o.template=e,o}(s.js,s.html);var l=Ss("vue");return s.jsLib.unshift(l),s},Os=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<html>([\s\S]+)<\/html>/),o=n.match(/<script>([\s\S]+)<\/script>/),i={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return i.htmlTpl=i.html,i.jsTpl=i.js,i.script=(t=i.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),i},Bs=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function zs(){var n=Is(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Is(n,"vuepress-plugin-demo-block__code"),t=Is(n,"vuepress-plugin-demo-block__display"),r=Is(n,"vuepress-plugin-demo-block__footer"),a=Is(t,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(n.dataset.code),i=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);i=i?JSON.parse(i):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),a=new Function("return ".concat(r))(),o={js:a,css:a.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Bs(n),htmlTpl:Ts("")},i=Ss("react"),s=Ss("reactDOM");return o.jsLib.unshift(i,s),o}(o,i):"vanilla"===s?Os(o,i):Ps(o,i),u=As("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(u),u.addEventListener("click",Ds.bind(null,u,l,e,r)),Ss("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,o=n.cssLib,i=a.concat(o).concat(Ss("cssLib")).concat(Ss("jsLib")).join(",");return As("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:i}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Ss("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,o=n.cssLib,i=JSON.stringify({css:e,html:t,js:r,js_external:a.concat(Ss("jsLib")).join(";"),css_external:o.concat(Ss("cssLib")).join(";"),layout:Ss("codepenLayout"),js_pre_processor:Ss("codepenJsProcessor"),editors:Ss("codepenEditors")});return As("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:i}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==i.horizontal?i.horizontal:Ss("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=e.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(p)}if(c.css&&function(n){if(!Cs[n]){var e=As("style",{innerHTML:n});document.body.appendChild(e),Cs[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),a);else if("vue"===s){var d=(new(Vue.extend(c.script))).$mount();a.appendChild(d.$el)}else"vanilla"===s&&(a.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){zs()}),300)}function Ds(n,e,t,r){var a="1"!==n.dataset.isExpand;t.style.height=a?"".concat(e,"px"):0,a?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=a?"1":"0"}var $s={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},zs()},updated:function(){zs()}},Ls="auto",Ms="zoom-in",Rs="zoom-out",Us="grab",Ns="move";function Fs(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};r?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function Vs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function qs(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Gs(n,e,t){!function(n){var e=Js,t=Hs;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var r=n.style,a={};for(var o in e)t&&(a[o]=r[o]||""),r[o]=e[o];return a}var Js="transition",Hs="transform",Xs="transform",Ws="transitionend";var Zs=function(){},Ks={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Zs,onClose:Zs,onGrab:Zs,onMove:Zs,onRelease:Zs,onBeforeOpen:Zs,onBeforeClose:Zs,onBeforeGrab:Zs,onBeforeRelease:Zs,onImageLoading:Zs,onImageLoaded:Zs},Ys={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),nl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(a)>=o||Math.abs(r)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Qs(n)&&!nl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Qs(n)&&!nl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Qs(n){return 0===n.button}function nl(n){return n.metaKey||n.ctrlKey}var el={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Gs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Fs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Gs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},tl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},rl=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),al=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},ol={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=qs(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Us:Rs,transition:Xs+"\n        "+r+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Gs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Gs(this.el,{transform:"none"})},grab:function(n,e,t){var r=il(),a=r.x-n,o=r.y-e;Gs(this.el,{cursor:Ns,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=il(),a=r.x-n,o=r.y-e;Gs(this.el,{transition:Xs,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Gs(this.el,this.styleClose)},restoreOpenStyle:function(){Gs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=il(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,a=r.customSize,o=r.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":tl(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var i=this.rect.width/2,s=this.rect.height/2,l=il(),c={x:l.x-i,y:l.y-s},u=c.x/i,p=c.y/s,d=o+Math.min(u,p);if(a&&"string"==typeof a){var f=t||this.el.naturalWidth,h=e||this.el.naturalHeight,v=parseFloat(a)*f/(100*this.rect.width),m=parseFloat(a)*h/(100*this.rect.height);if(d>v||d>m)return{x:v,y:m}}return{x:d,y:d}}};function il(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function sl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Fs(n,r,e[r],t)}))}var ll=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ol),this.overlay=Object.create(el),this.handler=Object.create(Ys),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=al({},Ks,e),this.overlay.init(this),this.handler.init(this)}return rl(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Ms,Fs(n,"click",this.handler.click),this.options.preloadImage&&Vs(qs(n)));return this}},{key:"config",value:function(n){return n?(al(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(r),Vs(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Fs(document,"scroll",this.handler.scroll),Fs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Fs(window,"resize",this.handler.resizeWindow);var o=function n(){Fs(r,Ws,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&sl(document,e.handler,!0),t(r)};return Fs(r,Ws,o),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Ls,this.overlay.fadeOut(),this.target.zoomOut(),Fs(document,"scroll",this.handler.scroll,!1),Fs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Fs(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Fs(t,Ws,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&sl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Fs(t,Ws,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var o=function n(){Fs(a,Ws,n,!1),r(a)};return Fs(a,Ws,o),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ns,this.target.move(n,e,t);var a=this.target.el,o=function n(){Fs(a,Ws,n,!1),r(a)};return Fs(a,Ws,o),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Ls,this.target.restoreOpenStyle();var r=function r(){Fs(t,Ws,r,!1),n.lock=!1,n.released=!0,e(t)};return Fs(t,Ws,r),this}}}]),n}();const cl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ul=Number("500");class pl{constructor(){this.instance=new ll(cl)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ul){setTimeout(()=>this.update(n),e)}}var dl=[fs,bs,_s,Es,$s,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new pl,this.$vuepress.zooming.updateDelay()}}],fl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ls("layout",n),Vt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},hl=t(3),vl=Object(hl.a)(fl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(vl,"mixins",dl);const ml=[{name:"v-6768a9e7",path:"/web/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-6768a9e7").then(t)}},{path:"/web/index.html",redirect:"/web/"},{path:"/00.目录页/01.前端.html",redirect:"/web/"},{name:"v-4d529c47",path:"/network/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-4d529c47").then(t)}},{path:"/network/index.html",redirect:"/network/"},{path:"/00.目录页/02.网络.html",redirect:"/network/"},{name:"v-4b554a7a",path:"/leetcode/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-4b554a7a").then(t)}},{path:"/leetcode/index.html",redirect:"/leetcode/"},{path:"/00.目录页/03.算法.html",redirect:"/leetcode/"},{name:"v-6acd4cd9",path:"/design-patterns/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-6acd4cd9").then(t)}},{path:"/design-patterns/index.html",redirect:"/design-patterns/"},{path:"/00.目录页/04.设计模式.html",redirect:"/design-patterns/"},{name:"v-5c0b7536",path:"/npm/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-5c0b7536").then(t)}},{path:"/npm/index.html",redirect:"/npm/"},{path:"/00.目录页/05.npm.html",redirect:"/npm/"},{name:"v-1f93be54",path:"/collection/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-1f93be54").then(t)}},{path:"/collection/index.html",redirect:"/collection/"},{path:"/00.目录页/06.收藏夹.html",redirect:"/collection/"},{name:"v-22b1ec1c",path:"/pages/837e03/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-22b1ec1c").then(t)}},{path:"/pages/837e03/index.html",redirect:"/pages/837e03/"},{path:"/01.前端/10.思维导图/5.前端知识体系.html",redirect:"/pages/837e03/"},{name:"v-47d17d96",path:"/pages/3bb12a/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-47d17d96").then(t)}},{path:"/pages/3bb12a/index.html",redirect:"/pages/3bb12a/"},{path:"/01.前端/20.Javascript/6.手写promise.html",redirect:"/pages/3bb12a/"},{name:"v-65dbf974",path:"/pages/bddf14/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-65dbf974").then(t)}},{path:"/pages/bddf14/index.html",redirect:"/pages/bddf14/"},{path:"/01.前端/20.Javascript/8.事件.html",redirect:"/pages/bddf14/"},{name:"v-fcfa1de8",path:"/pages/7153e7/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-fcfa1de8").then(t)}},{path:"/pages/7153e7/index.html",redirect:"/pages/7153e7/"},{path:"/01.前端/30.Typescript/01.test.html",redirect:"/pages/7153e7/"},{name:"v-5e4c81c5",path:"/pages/c7216e/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-5e4c81c5").then(t)}},{path:"/pages/c7216e/index.html",redirect:"/pages/c7216e/"},{path:"/01.前端/40.工程化/10.vite.html",redirect:"/pages/c7216e/"},{name:"v-ec95f9fa",path:"/pages/e8939e/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-ec95f9fa").then(t)}},{path:"/pages/e8939e/index.html",redirect:"/pages/e8939e/"},{path:"/01.前端/40.工程化/5.webpack.html",redirect:"/pages/e8939e/"},{name:"v-9048fa48",path:"/pages/dac852/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-9048fa48").then(t)}},{path:"/pages/dac852/index.html",redirect:"/pages/dac852/"},{path:"/01.前端/50.vue/10.vue3进阶笔记之effect.html",redirect:"/pages/dac852/"},{name:"v-0e8cebc8",path:"/pages/1c753e/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-0e8cebc8").then(t)}},{path:"/pages/1c753e/index.html",redirect:"/pages/1c753e/"},{path:"/01.前端/50.vue/12.vue3进阶笔记之reactive.html",redirect:"/pages/1c753e/"},{name:"v-c4f49838",path:"/pages/ecd654/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-c4f49838").then(t)}},{path:"/pages/ecd654/index.html",redirect:"/pages/ecd654/"},{path:"/01.前端/50.vue/14.vue3进阶笔记之ref.html",redirect:"/pages/ecd654/"},{name:"v-1548b5a9",path:"/pages/3c450a/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-1548b5a9").then(t)}},{path:"/pages/3c450a/index.html",redirect:"/pages/3c450a/"},{path:"/01.前端/50.vue/16.vue3进阶笔记之provide、inject.html",redirect:"/pages/3c450a/"},{name:"v-68163d88",path:"/pages/18eeef/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-68163d88").then(t)}},{path:"/pages/18eeef/index.html",redirect:"/pages/18eeef/"},{path:"/01.前端/50.vue/18.vue3进阶笔记之vuex.html",redirect:"/pages/18eeef/"},{name:"v-591adf23",path:"/pages/a4bbd1/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-591adf23").then(t)}},{path:"/pages/a4bbd1/index.html",redirect:"/pages/a4bbd1/"},{path:"/01.前端/50.vue/2.Vue 生命周期.html",redirect:"/pages/a4bbd1/"},{name:"v-0feb9fa6",path:"/pages/a72a65/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-0feb9fa6").then(t)}},{path:"/pages/a72a65/index.html",redirect:"/pages/a72a65/"},{path:"/01.前端/50.vue/20.vue3进阶笔记之pinia.html",redirect:"/pages/a72a65/"},{name:"v-65efea34",path:"/pages/c51d69/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-65efea34").then(t)}},{path:"/pages/c51d69/index.html",redirect:"/pages/c51d69/"},{path:"/01.前端/50.vue/4.响应式原理.html",redirect:"/pages/c51d69/"},{name:"v-1e2c6bdc",path:"/pages/329c47/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-1e2c6bdc").then(t)}},{path:"/pages/329c47/index.html",redirect:"/pages/329c47/"},{path:"/01.前端/50.vue/6.Mixin混入原理.html",redirect:"/pages/329c47/"},{name:"v-c16372ea",path:"/pages/c009df/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-c16372ea").then(t)}},{path:"/pages/c009df/index.html",redirect:"/pages/c009df/"},{path:"/01.前端/50.vue/8.模板编译原理.html",redirect:"/pages/c009df/"},{name:"v-05d14a18",path:"/pages/2e07e0/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-05d14a18").then(t)}},{path:"/pages/2e07e0/index.html",redirect:"/pages/2e07e0/"},{path:"/01.前端/70.30-seconds-of-code/10.30SecondsString.html",redirect:"/pages/2e07e0/"},{name:"v-cddb19c0",path:"/pages/908120/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-cddb19c0").then(t)}},{path:"/pages/908120/index.html",redirect:"/pages/908120/"},{path:"/01.前端/70.30-seconds-of-code/15.30SecondsMath.html",redirect:"/pages/908120/"},{name:"v-6849e8f8",path:"/pages/28a623/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-6849e8f8").then(t)}},{path:"/pages/28a623/index.html",redirect:"/pages/28a623/"},{path:"/01.前端/70.30-seconds-of-code/20.30SecondsNode.html",redirect:"/pages/28a623/"},{name:"v-00e56428",path:"/pages/8fb9cb/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-00e56428").then(t)}},{path:"/pages/8fb9cb/index.html",redirect:"/pages/8fb9cb/"},{path:"/01.前端/70.30-seconds-of-code/25.30SecondsBrower.html",redirect:"/pages/8fb9cb/"},{name:"v-4e647fa2",path:"/pages/ee2d60/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-4e647fa2").then(t)}},{path:"/pages/ee2d60/index.html",redirect:"/pages/ee2d60/"},{path:"/01.前端/70.30-seconds-of-code/30.30SecondsDate.html",redirect:"/pages/ee2d60/"},{name:"v-33194080",path:"/pages/14d237/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-33194080").then(t)}},{path:"/pages/14d237/index.html",redirect:"/pages/14d237/"},{path:"/01.前端/70.30-seconds-of-code/5.30SecondsArray.html",redirect:"/pages/14d237/"},{name:"v-7d53ccf6",path:"/pages/4555d4/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-7d53ccf6").then(t)}},{path:"/pages/4555d4/index.html",redirect:"/pages/4555d4/"},{path:"/01.前端/80.浏览器/10.宏观视角上的浏览器/4.Chrome架构.html",redirect:"/pages/4555d4/"},{name:"v-acb4ec08",path:"/pages/c78068/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-acb4ec08").then(t)}},{path:"/pages/c78068/index.html",redirect:"/pages/c78068/"},{path:"/02.网络/20.HTTP/01.test.html",redirect:"/pages/c78068/"},{name:"v-c3cad6c0",path:"/pages/fef14d/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-c3cad6c0").then(t)}},{path:"/pages/fef14d/index.html",redirect:"/pages/fef14d/"},{path:"/02.网络/20.HTTP/10.http缓存.html",redirect:"/pages/fef14d/"},{name:"v-73d54d6b",path:"/pages/87eaf1/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-73d54d6b").then(t)}},{path:"/pages/87eaf1/index.html",redirect:"/pages/87eaf1/"},{path:"/03.算法/0.序言/0.index.html",redirect:"/pages/87eaf1/"},{name:"v-707e3d4d",path:"/pages/7796ac/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-707e3d4d").then(t)}},{path:"/pages/7796ac/index.html",redirect:"/pages/7796ac/"},{path:"/03.算法/10.栈/1.判断字符串括号是否合法.html",redirect:"/pages/7796ac/"},{name:"v-15fef6fe",path:"/pages/f79bac/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-15fef6fe").then(t)}},{path:"/pages/f79bac/index.html",redirect:"/pages/f79bac/"},{path:"/03.算法/10.栈/144. 二叉树的前序遍历.html",redirect:"/pages/f79bac/"},{name:"v-4ced6830",path:"/pages/cc00cd/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-4ced6830").then(t)}},{path:"/pages/cc00cd/index.html",redirect:"/pages/cc00cd/"},{path:"/03.算法/10.栈/145. 二叉树的后序遍历.html",redirect:"/pages/cc00cd/"},{name:"v-3f867205",path:"/pages/0255ab/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-3f867205").then(t)}},{path:"/pages/0255ab/index.html",redirect:"/pages/0255ab/"},{path:"/03.算法/10.栈/2.大鱼吃小鱼.html",redirect:"/pages/0255ab/"},{name:"v-61854e96",path:"/pages/c8d9ba/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-61854e96").then(t)}},{path:"/pages/c8d9ba/index.html",redirect:"/pages/c8d9ba/"},{path:"/03.算法/10.栈/20.有效的括号.html",redirect:"/pages/c8d9ba/"},{name:"v-ecddd03c",path:"/pages/26a51f/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-ecddd03c").then(t)}},{path:"/pages/26a51f/index.html",redirect:"/pages/26a51f/"},{path:"/03.算法/10.栈/3.找出数组中右边比我小的元素.html",redirect:"/pages/26a51f/"},{name:"v-d62bce2e",path:"/pages/12f998/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-d62bce2e").then(t)}},{path:"/pages/12f998/index.html",redirect:"/pages/12f998/"},{path:"/03.算法/10.栈/94. 二叉树的中序遍历.html",redirect:"/pages/12f998/"},{name:"v-27bffdd9",path:"/pages/8f6f25/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-27bffdd9").then(t)}},{path:"/pages/8f6f25/index.html",redirect:"/pages/8f6f25/"},{path:"/03.算法/5.数据结构/5.Array.html",redirect:"/pages/8f6f25/"},{name:"v-f9d0d0b6",path:"/pages/5eb93d/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-f9d0d0b6").then(t)}},{path:"/pages/5eb93d/index.html",redirect:"/pages/5eb93d/"},{path:"/03.算法/7.数据结构笔记/5.数据结构导论.html",redirect:"/pages/5eb93d/"},{name:"v-64b2788e",path:"/pages/73d23b/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-64b2788e").then(t)}},{path:"/pages/73d23b/index.html",redirect:"/pages/73d23b/"},{path:"/04.设计模式/06.行为型模式/10.观察者模式.html",redirect:"/pages/73d23b/"},{name:"v-228b074f",path:"/pages/978afe/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-228b074f").then(t)}},{path:"/pages/978afe/index.html",redirect:"/pages/978afe/"},{path:"/05.npm/10.awesome-micro/10.Array.html",redirect:"/pages/978afe/"},{name:"v-9671cbb4",path:"/pages/e82928/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-9671cbb4").then(t)}},{path:"/pages/e82928/index.html",redirect:"/pages/e82928/"},{path:"/05.npm/60.数学/5.is-number.html",redirect:"/pages/e82928/"},{name:"v-71f69e9c",path:"/pages/d021d1/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-71f69e9c").then(t)}},{path:"/pages/d021d1/index.html",redirect:"/pages/d021d1/"},{path:"/06.收藏夹/05.网站.html",redirect:"/pages/d021d1/"},{name:"v-6a00f8d1",path:"/pages/8a9936/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-6a00f8d1").then(t)}},{path:"/pages/8a9936/index.html",redirect:"/pages/8a9936/"},{path:"/08.计算机系统/05.深入理解计算机系统/01.计算机系统漫游.html",redirect:"/pages/8a9936/"},{name:"v-53104ef6",path:"/archives/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-53104ef6").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-1a9d53e5",path:"/categories/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-1a9d53e5").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-150b83f6",path:"/tags/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-150b83f6").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-95c08fd2",path:"/pages/f2e63f/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-95c08fd2").then(t)}},{path:"/pages/f2e63f/index.html",redirect:"/pages/f2e63f/"},{path:"/_posts/随笔/你知道的越多，不知道的也就越多.html",redirect:"/pages/f2e63f/"},{name:"v-77761d97",path:"/pages/cd8bde/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-77761d97").then(t)}},{path:"/pages/cd8bde/index.html",redirect:"/pages/cd8bde/"},{path:"/_posts/随笔/拥抱生活，拥抱快乐.html",redirect:"/pages/cd8bde/"},{name:"v-821f1cb0",path:"/pages/c2c415/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-821f1cb0").then(t)}},{path:"/pages/c2c415/index.html",redirect:"/pages/c2c415/"},{path:"/_posts/项目.html",redirect:"/pages/c2c415/"},{name:"v-a113e2c4",path:"/",component:vl,beforeEnter:(n,e,t)=>{ss("Layout","v-a113e2c4").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:vl}],gl={title:"",description:"",base:"/blog/",headTags:[["link",{rel:"icon",href:"/blog/img/favicon.ico"}],["meta",{name:"keywords",content:"前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"前端",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.前端",imgUrl:"/img/web.png",description:"JavaScript、ES6、Vue框架等前端技术"}},title:"前端",date:"2020-03-11T21:50:53.000Z",permalink:"/web",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%89%8D%E7%AB%AF.html",relativePath:"00.目录页/01.前端.md",key:"v-6768a9e7",path:"/web/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/03, 19:24:28",lastUpdatedTimestamp:1646306668e3},{title:"网络",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.网络",imgUrl:"/img/ui.png",description:"前端角度记录计算机网络相关技术"}},title:"网络",date:"2020-03-11T21:50:54.000Z",permalink:"/network",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E7%BD%91%E7%BB%9C.html",relativePath:"00.目录页/02.网络.md",key:"v-4d529c47",path:"/network/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/03, 19:24:28",lastUpdatedTimestamp:1646306668e3},{title:"算法",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"03.算法",imgUrl:"/img/other.png",description:"技术文档、教程、技巧、总结等文章"}},title:"算法",date:"2020-03-11T21:50:55.000Z",permalink:"/leetcode",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E7%AE%97%E6%B3%95.html",relativePath:"00.目录页/03.算法.md",key:"v-4b554a7a",path:"/leetcode/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/07, 23:12:50",lastUpdatedTimestamp:164666597e4},{title:"🏛设计模式",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"04.设计模式",imgUrl:"/img/more.png",description:"学习前人总结的代码套路"}},title:"🏛设计模式",date:"2020-03-11T21:50:56.000Z",permalink:"/design-patterns",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",relativePath:"00.目录页/04.设计模式.md",key:"v-6acd4cd9",path:"/design-patterns/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/07, 22:55:33",lastUpdatedTimestamp:1646664933e3},{title:"🏛npm包",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"05.npm",imgUrl:"/img/more.png",description:"阅读npm包，解决信息技术匮乏问题。"}},title:"🏛npm包",date:"2020-03-24T10:50:56.000Z",permalink:"/npm",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.npm.html",relativePath:"00.目录页/05.npm.md",key:"v-5c0b7536",path:"/npm/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/24, 13:59:21",lastUpdatedTimestamp:1648101561e3},{title:"收藏",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"06.收藏夹",imgUrl:"/img/more.png",description:"收藏一些有用的东西。"}},title:"收藏",date:"2022-05-10T16:40:32.000Z",permalink:"/collection",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/06.%E6%94%B6%E8%97%8F%E5%A4%B9.html",relativePath:"00.目录页/06.收藏夹.md",key:"v-1f93be54",path:"/collection/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/10, 17:00:46",lastUpdatedTimestamp:1652173246e3},{title:"前端知识体系",frontmatter:{title:"前端知识体系",date:"2022-03-26T12:12:04.000Z",permalink:"/pages/837e03/",sidebar:!1,categories:["前端","思维导图"],tags:["知识体系"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/10.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/5.%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html",relativePath:"01.前端/10.思维导图/5.前端知识体系.md",key:"v-22b1ec1c",path:"/pages/837e03/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/26, 12:24:02",lastUpdatedTimestamp:1648268642e3},{title:"手写promise",frontmatter:{title:"手写promise",date:"2022-03-08T00:03:45.000Z",permalink:"/pages/3bb12a/",categories:["前端","Javascript"],tags:["Javascript","JS手写系列"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/20.Javascript/6.%E6%89%8B%E5%86%99promise.html",relativePath:"01.前端/20.Javascript/6.手写promise.md",key:"v-47d17d96",path:"/pages/3bb12a/",headers:[{level:2,title:"1.创建一个自己的promse一个类",slug:"_1-创建一个自己的promse一个类",normalizedTitle:"1.创建一个自己的promse一个类",charIndex:57},{level:2,title:"2.promse的三种状态",slug:"_2-promse的三种状态",normalizedTitle:"2.promse的三种状态",charIndex:450},{level:2,title:"3.resolve和reject",slug:"_3-resolve和reject",normalizedTitle:"3.resolve和reject",charIndex:1218},{level:2,title:"4.then方法判断状态",slug:"_4-then方法判断状态",normalizedTitle:"4.then方法判断状态",charIndex:2161},{level:2,title:"5.在promise类中加入异步代码",slug:"_5-在promise类中加入异步代码",normalizedTitle:"5.在promise类中加入异步代码",charIndex:4212},{level:2,title:"6.实现then方法多次使用",slug:"_6-实现then方法多次使用",normalizedTitle:"6.实现then方法多次使用",charIndex:5830},{level:2,title:"7.then实现return一个值的链式调用",slug:"_7-then实现return一个值的链式调用",normalizedTitle:"7.then实现return一个值的链式调用",charIndex:7220},{level:2,title:"8.then实现return新promise时的链式调用",slug:"_8-then实现return新promise时的链式调用",normalizedTitle:"8.then实现return新promise时的链式调用",charIndex:7849},{level:2,title:"9.循环调用异常处理",slug:"_9-循环调用异常处理",normalizedTitle:"9.循环调用异常处理",charIndex:9175},{level:2,title:"10.目前为止全部代码",slug:"_10-目前为止全部代码",normalizedTitle:"10.目前为止全部代码",charIndex:10956},{level:2,title:"11.加入异常处理",slug:"_11-加入异常处理",normalizedTitle:"11.加入异常处理",charIndex:14587},{level:2,title:"12.then参数可选",slug:"_12-then参数可选",normalizedTitle:"12.then参数可选",charIndex:20524},{level:2,title:"13.promise all静态方法",slug:"_13-promise-all静态方法",normalizedTitle:"13.promise all静态方法",charIndex:20928},{level:2,title:"14.promise resolve静态方法",slug:"_14-promise-resolve静态方法",normalizedTitle:"14.promise resolve静态方法",charIndex:22266},{level:2,title:"15.promise finally方法",slug:"_15-promise-finally方法",normalizedTitle:"15.promise finally方法",charIndex:22876},{level:2,title:"16.promise中的catch方法",slug:"_16-promise中的catch方法",normalizedTitle:"16.promise中的catch方法",charIndex:23882},{level:2,title:"17.最终代码",slug:"_17-最终代码",normalizedTitle:"17.最终代码",charIndex:24302}],headersStr:"1.创建一个自己的promse一个类 2.promse的三种状态 3.resolve和reject 4.then方法判断状态 5.在promise类中加入异步代码 6.实现then方法多次使用 7.then实现return一个值的链式调用 8.then实现return新promise时的链式调用 9.循环调用异常处理 10.目前为止全部代码 11.加入异常处理 12.then参数可选 13.promise all静态方法 14.promise resolve静态方法 15.promise finally方法 16.promise中的catch方法 17.最终代码",content:"在理解promise原理之前，最好先理解观察者模式,因为在实现then链式调用的时候，需要这个前置知识。\n\n\n# 1.创建一个自己的promse一个类\n\npromse就是一个类,在执行这个类的时候 需要传递一个执行器 执行器立即执行\n\nclass MyPromise {\n    //1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行\n    constructor (executor) {   \n        //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject\n        executor(this.resolve,this.reject);\n    }\n    \n    resolve = (value) => {}\n    \n    reject = (errInfo) => {}\n}\nmodule.exports = MyPromise\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.promse的三种状态\n\n等待:pending 成功:rejected 失败fulfilled 一旦状态确认就不可更改\n\n//2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled\n//把状态定义成常量的好处是:1.复用性 2.编辑器会有提示,而字符串是没有提示的\nconst PENDING = 'pending';      //等待\nconst FULFILLED = 'fulfilled';  //成功\nconst REJECTED = 'rejected';    //失败\n\nclass MyPromise {\n    constructor (executor) {   \n        //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject\n        executor(this.resolve,this.reject);\n    }\n\n    //resolve和reject之所以定义成箭头函数就是为了让其内部this指向MyPromise\n    resolve = () => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n    }\n\n    reject = () => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n    }\n}\n\nmodule.exports = MyPromise\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 3.resolve和reject\n\nresolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled 调用reject是pending->rejected\n\nconst PENDING = 'pending';      //等待\nconst FULFILLED = 'fulfilled';  //成功\nconst REJECTED = 'rejected';    //失败\n\nclass MyPromise {\n    constructor (executor) {   \n        executor(this.resolve,this.reject);\n    }\n\n    //状态\n    status = PENDING;\n    //成功值\n    value = undefined;\n    //失败原因\n    errInfo = undefined;     \n\n    //3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected\n    resolve = () => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n        //将状态更改为成功\n        this.status = FULFILLED;\n    }\n\n    reject = () => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n        //将状态更改为失败\n        this.status = REJECTED;\n    }\n    \n}\n\nmodule.exports = MyPromise\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 4.then方法判断状态\n\n如果状态成功调用成功的回调 如果状态是失败则调用失败的回调函数\n\n//2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled\n//把状态定义成常量的好处是:1.复用性 2.编辑器会有提示,而字符串是没有提示的\nconst PENDING = 'pending';      //等待\nconst FULFILLED = 'fulfilled';  //成功\nconst REJECTED = 'rejected';    //失败\n\nclass MyPromise {\n    //1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行\n    constructor (executor) {   \n        //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject\n        executor(this.resolve,this.reject);\n    }\n\n    //状态\n    status = PENDING;\n    //成功值\n    value = undefined;\n    //失败原因\n    errInfo = undefined;     \n\n    //3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected\n    //resolve和reject之所以定义成箭头函数就是为了让其内部this指向MyPromise\n    resolve = (value) => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n        //将状态更改为成功\n        this.status = FULFILLED;\n        //保存成功之后的值\n        this.value = value;\n    }\n\n    reject = (errInfo) => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n        //将状态更改为失败\n        this.status = REJECTED;\n        //保存失败之后的值\n        this.errInfo = errInfo;\n    }\n    \n    then (successCallback,failCallback) {\n        //4.then方法内部做的事情就是判断状态,如果状态成功调用成功的回调 如果状态是失败则调用失败的回调函数\n        //5.成功回调参数:this.value 失败回调参数:errInfo\n        if(this.status === FULFILLED) successCallback(this.value);\n        if(this.status === REJECTED) failCallback(this.errInfo);\n    }\n}\n\nmodule.exports = MyPromise\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n代码片段测试,打印 ‘成功’.\n\nnew MyPromise((resolve,reject)=>{\n    resolve('成功')\n    reject('失败')\n}).then((res)=>{\n    console.log(res);\n},(err)=>{\n    console.error(err)\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n加入异步代码测试. 一秒之后无输出. 首先执行器是一个同步代码最先被执行,然后执行then函数,由于状态还是pending,所以无任何输出,一秒之后状态被改变但是then已经执行了.\n\nnew MyPromise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('成功');\n    },1000)\n}).then((res)=>{\n    console.log(res);\n},(err)=>{\n    console.error(err);\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 5.在promise类中加入异步代码\n\nconst PENDING = 'pending';      //等待\nconst FULFILLED = 'fulfilled';  //成功\nconst REJECTED = 'rejected';    //失败\nclass MyPromise {\n    constructor (executor) {   \n        executor(this.resolve,this.reject);\n    }\n    \n    status = PENDING;\n    value = undefined;\n    errInfo = undefined;     \n    successCallback = undefined;\n    failCallback = undefined;\n    resolve = (value) => {\n        if(this.status !== PENDING) return;\n        this.status = FULFILLED;\n        this.value = value;\n        //判断成功回调是否是异步执行\n        this.successCallback && this.successCallback(value);\n    }\n\n    reject = (errInfo) => {\n        if(this.status !== PENDING) return;\n        this.status = REJECTED;\n        this.errInfo = errInfo;\n        //判断失败回调是否是异步执行\n        this.failCallback && this.failCallback(errInfo);        \n    }\n    \n    then (successCallback,failCallback) {\n        if(this.status === FULFILLED) successCallback(this.value);\n        if(this.status === REJECTED) failCallback(this.errInfo);\n        if(this.status === PENDING) {\n        \t\t//在then中加入异步逻辑\n            this.successCallback = successCallback;\n            this.failCallback = failCallback;\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n但如果是多次调用呢,如下\n\npromise.then((res)=>{\n    console.log(res);\n},(err)=>{\n    console.error(err);\n})\n\npromise.then((res)=>{\n    console.log(res);\n},(err)=>{\n    console.error(err);\n})\n\npromise.then((res)=>{\n    console.log(res);\n},(err)=>{\n    console.error(err);\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 6.实现then方法多次使用\n\nconst PENDING = 'pending';      //等待\nconst FULFILLED = 'fulfilled';  //成功\nconst REJECTED = 'rejected';    //失败\n\nclass MyPromise {\n    constructor (executor) {   \n        executor(this.resolve,this.reject);\n    }\n    status = PENDING;\n    value = undefined;\n    errInfo = undefined;     \n    //成功回调\n    successCallback = [];\n    //失败回调\n    failCallback = [];\n    resolve = (value) => {\n        if(this.status !== PENDING) return;\n        this.status = FULFILLED;\n        this.value = value;\n        //判断成功回调是否是异步执行\n        while(this.successCallback.length) this.successCallback.shift()(value);\n    }\n\n    reject = (errInfo) => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n        //将状态更改为失败\n        this.status = REJECTED;\n        //保存失败之后的值\n        this.errInfo = errInfo;\n        //判断失败回调是否是异步执行\n        while(this.failCallback.length)this.failCallback.shift()(errInfo);\n    }\n    \n    then (successCallback,failCallback) {\n        if(this.status === FULFILLED) successCallback(this.value);\n        if(this.status === REJECTED) failCallback(this.errInfo);\n        if(this.status === PENDING) {\n            this.successCallback.push(successCallback);\n            this.failCallback.push(failCallback);\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 7.then实现return一个值的链式调用\n\n后面then方法的回调函数拿到的值是上一个then方法的回调函数的返回值,如下,最后需要打印 '成功’和100.\n\nlet promise = new MyPromise((resolve,reject)=>{\n    resolve('成功');\n}).then((res)=>{\n    console.log(res);\n    return 100\n}).then((res)=>{\n    console.log(res);\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这里主要修改then中的代码,then中要返回一个新的promise对象,而且每次接收的参数要是上次一返回的值,其实then中的第一个参数就是successCallback,要得到它的返回值调用一下它即可.\n\n  then (successCallback,failCallback) {\n      return new MyPromise((resolve,reject)=>{\n          if(this.status === FULFILLED) {\n              const x = successCallback(this.value);\n              resolve(x);\n          }\n      })\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 8.then实现return新promise时的链式调用\n\n如下,最后应该要打印 ‘成功’和’other’\n\nfunction other () {\n    return new MyPromise((resolve,reject)=>{\n        resolve('other');\n    })\n}\nlet promise = new MyPromise((resolve,reject)=>{\n    resolve('成功');\n}).then((res)=>{\n    console.log(res);\n    return other()\n}).then((res)=>{\n    console.log(res);\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这里的x不确定是一个值还是一个promise对象. 需要对他进行判断,如果是promise则需要对它返回的值进行判断,同样成功调用resolve,失败调用reject\n\nthen (successCallback,failCallback) {\n  //8.实现链式调用,每次都返回一个新的实例\n  return new MyPromise((resolve,reject)=>{\n      if(this.status === FULFILLED) {\n          const x = successCallback(this.value);\n          resolvePromise(x,resolve,reject);\n          //resolve(x);\n      }\n      if(this.status === REJECTED) failCallback(this.errInfo);\n      if(this.status === PENDING) {\n          //6.在promise中加入异步代码\n          this.successCallback.push(successCallback);\n          this.failCallback.push(failCallback);\n      }\n  })\n}\n\nfunction resolvePromise (x,resolve,reject) {\n    //如何判断x是不是prmise 就判断它是不是MyPromise的实例\n    if(x instanceof MyPromise){\n        //是promise就需要调用then去查看它对应的状态,成功的调用resolve传递下去,失败调用reject\n        x.then(value=>resolve(value),errInfo=>reject(errInfo))\n    }else{\n        resolve(x);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 9.循环调用异常处理\n\nthen返回的promise对象就是最后所生成的对象,所以在then的成功回调中不能再次返回被声明的promise,不然会出现循环调用的情况,如下\n\nlet other = new Promise((resolve,reject)=>{\n    setTimeout(() => {\n        resolve('other');\n    }, 100);\n})\n\nlet p1 = other.then(value=>{\n    console.log(value)\n    return p1\n})\n\np1.then(value=>{\n    console.log(value)\n},(errInfo)=>{\n    console.log(errInfo.message)\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n具体实现主要是判断CurPromise和CurX是否是同一个promise,如果是就抛出错误,不是的话继续执行\n\nthen (successCallback,failCallback) {\n    const CurPromise = new MyPromise((resolve,reject)=>{\n        if(this.status === FULFILLED) {\n            //这里是为了使用异步执行,因为当前这个执行器是被立即执行的,此时new MyPromise的操作并未完成,故拿不到CurPromise\n            setTimeout(()=>{\n                const CurX = successCallback(this.value);\n                //10.首先.then最后返回的是CurPromise,所以在then的成功回调中不能再次返回被声明的promise,不然会出现循环调用的情况\n                resolvePromise(CurPromise,CurX,resolve,reject);\n            },0)\n        }\n        if(this.status === REJECTED) failCallback(this.errInfo);\n        if(this.status === PENDING) {\n            this.successCallback.push(successCallback);\n            this.failCallback.push(failCallback);\n        }\n    })\n    return CurPromise\n}\nfunction resolvePromise (CurPromise,CurX,resolve,reject) {\n    //判断CurPromise和CurX是否是同一个promise\n    if(CurPromise === CurX){\n        //直接抛错并退出\n        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\n    }\n    //如何判断CurX是不是prmise 就判断它是不是MyPromise的实例\n    if(CurX instanceof MyPromise){\n        //是promise就需要调用then去查看它对应的状态,成功的调用resolve传递下去,失败调用reject\n        CurX.then(value=>resolve(value),errInfo=>reject(errInfo))\n    }else{\n        resolve(CurX);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 10.目前为止全部代码\n\n//2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled\n//把状态定义成常量的好处是:1.复用性 2.编辑器会有提示,而字符串是没有提示的\nconst PENDING = 'pending';      //等待\nconst FULFILLED = 'fulfilled';  //成功\nconst REJECTED = 'rejected';    //失败\n\nclass MyPromise {\n    //1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行\n    constructor (executor) {\n        //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject\n        executor(this.resolve,this.reject);\n    }\n\n    //状态\n    status = PENDING;\n    //成功值\n    value = undefined;\n    //失败原因\n    errInfo = undefined;     \n\n    //成功回调\n    successCallback = [];\n    //失败回调\n    failCallback = [];\n\n    //3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected\n    //resolve和reject之所以定义成箭头函数就是为了让其内部this指向MyPromise\n\n    //传递成功的函数\n    resolve = (value) => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n        //将状态更改为成功\n        this.status = FULFILLED;\n        //保存成功之后的值\n        this.value = value;\n        //判断成功回调是否是异步执行\n        //this.successCallback && this.successCallback(value);\n        while(this.successCallback.length){\n            //7.then方法多次调用,依次执行\n            this.successCallback.shift()(value);\n        }\n    }\n\n    //传递失败对应的函数\n    reject = (errInfo) => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n        //将状态更改为失败\n        this.status = REJECTED;\n        //保存失败之后的值\n        this.errInfo = errInfo;\n        //判断失败回调是否是异步执行\n        // this.failCallback && this.failCallback(errInfo);     \n        while(this.failCallback.length){\n            //then方法多次调用,依次执行\n            this.failCallback.shift()(errInfo);\n        }\n    }\n    \n    //查看状态的函数\n    then (successCallback,failCallback) {\n        //8.实现链式调用,每次都返回一个新的实例\n        const CurPromise = new MyPromise((resolve,reject)=>{\n            //4.then方法内部做的事情就是判断状态,如果状态成功调用成功的回调 如果状态是失败则调用失败的回调函数\n            //5.成功回调参数:this.value 失败回调参数:errInfo\n            if(this.status === FULFILLED) {\n                //这里是为了使用异步执行,因为当前这个执行器是被立即执行的,此时new MyPromise的操作并未完成,故拿不到CurPromise\n                setTimeout(()=>{\n                    const CurX = successCallback(this.value);\n                    //9.这里的CurX不确定是一个值还是一个promise对象. 需要对他进行判断,如果是promise则需要对它返回的值进行判断,同样成功调用resolve,失败调用reject\n                    //resolvePromise(CurX,resolve,reject);\n                    //resolve(CurX);\n                    //10.首先.then最后返回的是CurPromise,所以在then的成功回调中不能再次返回被声明的promise,不然会出现循环调用的情况\n                    resolvePromise(CurPromise,CurX,resolve,reject);\n                },0)\n            }\n            if(this.status === REJECTED) failCallback(this.errInfo);\n            if(this.status === PENDING) {\n                //6.在promise中加入异步代码\n                this.successCallback.push(successCallback);\n                this.failCallback.push(failCallback);\n            }\n        })\n        return CurPromise\n    }\n}\n\nfunction resolvePromise (CurPromise,CurX,resolve,reject) {\n    //判断CurPromise和CurX是否是同一个promise\n    if(CurPromise === CurX){\n        //直接抛错并退出\n        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\n    }\n    //如何判断CurX是不是prmise 就判断它是不是MyPromise的实例\n    if(CurX instanceof MyPromise){\n        //是promise就需要调用then去查看它对应的状态,成功的调用resolve传递下去,失败调用reject\n        CurX.then(value=>resolve(value),errInfo=>reject(errInfo))\n    }else{\n        resolve(CurX);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n\n\n\n# 11.加入异常处理\n\n为了程序的健壮性,需要对代码进行各种异常处理. 如:executor函数,successCallback函数,failCallback函数\n\n//2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled\n//把状态定义成常量的好处是:1.复用性 2.编辑器会有提示,而字符串是没有提示的\nconst PENDING = 'pending';      //等待\nconst FULFILLED = 'fulfilled';  //成功\nconst REJECTED = 'rejected';    //失败\n\nclass MyPromise {\n    //1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行\n    constructor (executor) {\n        try {\n            //异常情况处理\n            //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject\n            executor(this.resolve,this.reject);\n        }catch(err){\n            this.reject(err)\n        }\n    }\n\n    //状态\n    status = PENDING;\n\n    //成功值\n    value = undefined;\n\n    //失败原因\n    errInfo = undefined;     \n\n    //成功回调\n    successCallback = [];\n    \n    //失败回调\n    failCallback = [];\n\n    //3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected\n    //resolve和reject之所以定义成箭头函数就是为了让其内部this指向MyPromise\n\n    //传递成功的函数\n    resolve = (value) => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n        //将状态更改为成功\n        this.status = FULFILLED;\n        //保存成功之后的值\n        this.value = value;\n        //判断成功回调是否是异步执行\n        //this.successCallback && this.successCallback(value);\n        while(this.successCallback.length){\n            //7.then方法多次调用,依次执行\n            // this.successCallback.shift()(value);\n            //参数都已经被收集到数组中的函数调用了,不需要传参;\n            this.successCallback.shift()();\n        }\n    }\n\n    //传递失败对应的函数\n    reject = (errInfo) => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n        //将状态更改为失败\n        this.status = REJECTED;\n        //保存失败之后的值\n        this.errInfo = errInfo;\n        //判断失败回调是否是异步执行\n        // this.failCallback && this.failCallback(errInfo);     \n        while(this.failCallback.length){\n            //then方法多次调用,依次执行\n            // this.failCallback.shift()(errInfo);\n            //参数都已经被收集到数组中的函数调用了,不需要传参;\n            this.failCallback.shift()();\n        }\n    }\n    \n    //查看状态的函数\n    then (successCallback,failCallback) {\n        //8.实现链式调用,每次都返回一个新的实例\n        const CurPromise = new MyPromise((resolve,reject)=>{\n            //4.then方法内部做的事情就是判断状态,如果状态成功调用成功的回调 如果状态是失败则调用失败的回调函数\n            //5.成功回调参数:this.value 失败回调参数:errInfo\n            if(this.status === FULFILLED) {\n                //这里是为了使用异步执行,因为当前这个执行器是被立即执行的,此时new MyPromise的操作并未完成,故拿不到CurPromise\n                setTimeout(()=>{\n                    try {\n                        //异常情况处理\n                        const CurX = successCallback(this.value);\n                        //9.这里的CurX不确定是一个值还是一个promise对象. 需要对他进行判断,如果是promise则需要对它返回的值进行判断,同样成功调用resolve,失败调用reject\n                        //resolvePromise(CurX,resolve,reject);\n                        //resolve(CurX);\n                        //10.首先.then最后返回的是CurPromise,所以在then的成功回调中不能再次返回被声明的promise,不然会出现循环调用的情况\n                        resolvePromise(CurPromise,CurX,resolve,reject);\n                    }catch(err){\n                        reject(err)\n                    }\n                },0)\n            }else if(this.status === REJECTED) {\n                setTimeout(()=>{\n                    try {\n                        //异常情况处理\n                        const CurX = failCallback(this.errInfo);\n                        resolvePromise(CurPromise,CurX,resolve,reject);\n                    }catch(err){\n                        reject(err)\n                    }\n                },0)\n            }else if(this.status === PENDING) {\n                //6.在promise中加入异步代码\n                this.successCallback.push(()=>{\n                    setTimeout(()=>{\n                        try {\n                            //异常情况处理\n                            const CurX = successCallback(this.value);\n                            resolvePromise(CurPromise,CurX,resolve,reject);\n                        }catch(err){\n                            reject(err)\n                        }                    \n                    },0)\n                });\n                this.failCallback.push(()=>{\n                    setTimeout(()=>{\n                        try {\n                            //异常情况处理\n                            const CurX = failCallback(this.errInfo);\n                            resolvePromise(CurPromise,CurX,resolve,reject);\n                        }catch(err){\n                            reject(err)\n                        }                    \n                    },0)\n                });\n            }\n        })\n        return CurPromise\n    }\n}\n\nfunction resolvePromise (CurPromise,CurX,resolve,reject) {\n    //判断CurPromise和CurX是否是同一个promise\n    if(CurPromise === CurX){\n        //直接抛错并退出\n        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\n    }\n    //如何判断CurX是不是prmise 就判断它是不是MyPromise的实例\n    if(CurX instanceof MyPromise){\n        //是promise就需要调用then去查看它对应的状态,成功的调用resolve传递下去,失败调用reject\n        CurX.then(value=>resolve(value),errInfo=>reject(errInfo))\n    }else{\n        resolve(CurX);\n    }\n}\n\nnew MyPromise((resolve,reject)=>{\n    //throw new Error('executor error')\n    setTimeout(()=>{\n        reject('reject');\n    },1000)\n})\n.then(value=>{\n    console.log(value)\n    throw new Error('then error')\n},(errInfo)=>{\n    throw new Error('then error')\n    //return 100\n})\n.then(value=>{\n    console.log(value)\n},(errInfo)=>{\n    console.log('eee')\n    console.log(errInfo.message)\n})\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n\n\n\n# 12.then参数可选\n\n当then没有回调的时候,还是要把值继续延续下去,知道有回调为止.具体主要是通过补充一个函数把值传递下去,如下在then中加入判断:\n\nsuccessCallback = successCallback ? successCallback : value=>value;\nfailCallback = failCallback ? failCallback : errInfo=>{throw errInfo};\n\n\n1\n2\n\n\nnew MyPromise((resolve,reject)=>{\n    reject('resolve');\n})\n.then()\n.then()\n.then(value=>{\n\tconsole.log(value)\n},err=>{\n    console.log(err)\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 13.promise all静态方法\n\n按照数组中的顺序返回对应的值,有一个失败就终止\n\n  function P1 () {\n      return new MyPromise((resolve,reject)=>{\n          setTimeout(()=>{\n              resolve('1111')\n          },1000)\n      })\n  }\n\n  function P2 () {\n      return new MyPromise((resolve,reject)=>{\n          resolve('222')\n      })\n  }\n\n\t//静态方法,可以直接调用\n  MyPromise.all([P1(),P2(),'3','4','5','6']).then((result)=>{\n    console.log(result)\n    // result -> ['1111','222','3','4','5','6'] \n  },(err)=>{\n      console.log(err)\n  })\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n//批量执行\nstatic all (array) {\n    let result = [];\n    let index = 0;\n    return new MyPromise((resolve,rejected)=>{\n        function addData (value,i) {\n            index++;\n            result[i] = value;\n            if(index === array.length){\n                //等待所以的异步操作完成之后,才能输出\n                resolve(result)\n            }\n        }\n        for (let i = 0 ; i< array.length ; i++){\n            if(array[i] instanceof MyPromise){\n                //如果是MyPromise对象那么执行它,最后看它的状态是什么,如果成功那么添加数据,如果失败那么终止操作\n                array[i].then(value=>addData(value,i),(errInfo)=>rejected(errInfo));\n            }else{\n                //普通值,直接添加数据\n                addData(array[i],i)\n            }\n        }\n    })\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 14.promise resolve静态方法\n\n也是一个静态方法,把给定的值转成promise对象,\n\n如果接受的是一个值,那么创建一个promise对象并把该直接传递下去\n\n如果接受的是一个promise对象,那么直接返回该对象\n\nfunction P1 () {\n    return new MyPromise((resolve,reject)=>{\n        resolve('hello')\n    })\n}\n//如果接受的是一个值,那么创建一个promise对象并把该直接传递下去\nMyPromise.resolve(10).then((result)=>{console.log(result)});\n//如果接受的是一个promise对象,那么直接返回该对象\nMyPromise.resolve(P1()).then((result)=>{console.log(result)});\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n//把给定的值转成promise对象\nstatic resolve (val) {\n  if(val instanceof MyPromise) return val;\n  return new MyPromise ((resolve,rejected)=>{\n  \tresolve (val)\n  });\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 15.promise finally方法\n\nfinally不是一个静态方法,它定义在类的原型上\n\n无论当前promise的执行是成功还是失败,finally当中的函数始终都会执行一次\n\n在finally后可以通过链式调用拿到当前的结果\n\nfunction P1 () {\n    return new MyPromise((resolve,reject)=>{\n        resolve('finally')\n    })\n}\n\nfunction P2 () {\n    return new MyPromise((resolve,reject)=>{\n        setTimeout(()=>{\n            resolve('hello')\n        },1000)\n    })\n}\n\nP1().finally((value)=>{\n    console.log(value)\n    return P2()\n}).then(value=>console.log(value),errInfo=>console.log(errInfo));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n//无论成功或失败都执行一次\nfinally(callback){\n    return this.then((value)=>{\n        //把值传递下去\n        // callback(value);\n        // return value\n        //处理异步\n        return MyPromise.resolve(callback(value)).then(value=>value);\n    },(errInfo)=>{\n        //把错误传递下去\n        // callback(errInfo);\n        // throw errInfo;\n        return MyPromise.resolve(callback(value)).then(value=>value,errInfo=>{throw errInfo});\n    })\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 16.promise中的catch方法\n\ncatch处理最终状态为失败的情况,在then中可以不传递失败回调,通过catch去捕获失败的回调,其实就是在catch方法的内部去调用then方法,成功回调传一个undefined,失败回调传递一个函数\n\n\nfunction P1 () {\n    return new MyPromise((resolve,reject)=>{\n        resolve('finally')\n    })\n}\nP1()\n.then(value=>console.log(value))\n.catch(errInfo=>console.log(errInfo))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n//捕获错误的回调\ncatch(failCallBack){\n\treturn this.then(undefined,failCallBack);\n}\n\n\n\n1\n2\n3\n4\n5\n\n\n\n# 17.最终代码\n\n//2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled\n//把状态定义成常量的好处是:1.复用性 2.编辑器会有提示,而字符串是没有提示的\nconst PENDING = 'pending';      //等待\nconst FULFILLED = 'fulfilled';  //成功\nconst REJECTED = 'rejected';    //失败\n\nclass MyPromise {\n    //1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行\n    constructor (executor) {\n        try {\n            //11.异常情况处理\n            //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject\n            executor(this.resolve,this.reject);\n        }catch(err){\n            this.reject(err)\n        }\n    }\n\n    //状态\n    status = PENDING;\n\n    //成功值\n    value = undefined;\n\n    //失败原因\n    errInfo = undefined;     \n\n    //成功回调\n    successCallback = [];\n    \n    //失败回调\n    failCallback = [];\n\n    //3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected\n    //resolve和reject之所以定义成箭头函数就是为了让其内部this指向MyPromise\n\n    //传递成功的函数\n    resolve = (value) => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n        //将状态更改为成功\n        this.status = FULFILLED;\n        //保存成功之后的值\n        this.value = value;\n        //判断成功回调是否是异步执行\n        //this.successCallback && this.successCallback(value);\n        while(this.successCallback.length){\n            //7.then方法多次调用,依次执行\n            // this.successCallback.shift()(value);\n            //参数都已经被收集到数组中的函数调用了,不需要传参;\n            this.successCallback.shift()();\n        }\n    }\n\n    //传递失败对应的函数\n    reject = (errInfo) => {\n        //一旦状态确认就不可更改\n        if(this.status !== PENDING) return;\n        //将状态更改为失败\n        this.status = REJECTED;\n        //保存失败之后的值\n        this.errInfo = errInfo;\n        //判断失败回调是否是异步执行\n        // this.failCallback && this.failCallback(errInfo);     \n        while(this.failCallback.length){\n            //then方法多次调用,依次执行\n            // this.failCallback.shift()(errInfo);\n            //参数都已经被收集到数组中的函数调用了,不需要传参;\n            this.failCallback.shift()();\n        }\n    }\n    \n    //查看状态的函数\n    then (successCallback,failCallback) {\n        //12.当then没有回调的时候,还是要把值继续延续下去,知道有回调为止\n        successCallback = successCallback ? successCallback : value=>value;\n        failCallback = failCallback ? failCallback : errInfo=>{throw errInfo};\n        //8.实现链式调用,每次都返回一个新的实例\n        const CurPromise = new MyPromise((resolve,reject)=>{\n            //4.then方法内部做的事情就是判断状态,如果状态成功调用成功的回调 如果状态是失败则调用失败的回调函数\n            //5.成功回调参数:this.value 失败回调参数:errInfo\n            if(this.status === FULFILLED) {\n                //这里是为了使用异步执行,因为当前这个执行器是被立即执行的,此时new MyPromise的操作并未完成,故拿不到CurPromise\n                setTimeout(()=>{\n                    try {\n                        //异常情况处理\n                        const CurX = successCallback(this.value);\n                        //9.这里的CurX不确定是一个值还是一个promise对象. 需要对他进行判断,如果是promise则需要对它返回的值进行判断,同样成功调用resolve,失败调用reject\n                        //resolvePromise(CurX,resolve,reject);\n                        //resolve(CurX);\n                        //10.首先.then最后返回的是CurPromise,所以在then的成功回调中不能再次返回被声明的promise,不然会出现循环调用的情况\n                        resolvePromise(CurPromise,CurX,resolve,reject);\n                    }catch(err){\n                        reject(err)\n                    }\n                },0)\n            }else if(this.status === REJECTED) {\n                setTimeout(()=>{\n                    try {\n                        //异常情况处理\n                        const CurX = failCallback(this.errInfo);\n                        resolvePromise(CurPromise,CurX,resolve,reject);\n                    }catch(err){\n                        reject(err)\n                    }\n                },0)\n            }else if(this.status === PENDING) {\n                //6.在promise中加入异步代码\n                this.successCallback.push(()=>{\n                    setTimeout(()=>{\n                        try {\n                            //异常情况处理\n                            const CurX = successCallback(this.value);\n                            resolvePromise(CurPromise,CurX,resolve,reject);\n                        }catch(err){\n                            reject(err)\n                        }\n                    },0)\n                });\n                this.failCallback.push(()=>{\n                    setTimeout(()=>{\n                        try {\n                            //异常情况处理\n                            const CurX = failCallback(this.errInfo);\n                            resolvePromise(CurPromise,CurX,resolve,reject);\n                        }catch(err){\n                            reject(err)\n                        }\n                    },0)\n                });\n            }\n        })\n        return CurPromise\n    }\n\n    //批量执行\n    static all (array) {\n        let result = [];\n        let index = 0;\n        return new MyPromise((resolve,rejected)=>{\n            function addData (value,i) {\n                index++;\n                result[i] = value;\n                if(index === array.length){\n                    //等待所以的异步操作完成之后,才能输出\n                    resolve(result)\n                }\n            }\n            for (let i = 0 ; i< array.length ; i++){\n                if(array[i] instanceof MyPromise){\n                    //如果是MyPromise对象那么执行它,最后看它的状态是什么,如果成功那么添加数据,如果失败那么终止操作\n                    array[i].then(value=>addData(value,i),(errInfo)=>rejected(errInfo));\n                }else{\n                    //普通值,直接添加数据\n                    addData(array[i],i)\n                }\n            }\n        })\n    }\n\n    //把给定的值转成promise对象\n    static resolve (val) {\n        if(val instanceof MyPromise) return val;\n        return new MyPromise ((resolve,rejected)=>{\n            resolve (val)\n        });\n    }\n\n    //无论成功或失败都执行一次\n    finally(callback){\n        return this.then((value)=>{\n            //把值传递下去\n            // callback(value);\n            // return value\n            //处理异步\n            return MyPromise.resolve(callback(value)).then(value=>value);\n        },(errInfo)=>{\n            //把错误传递下去\n            // callback(errInfo);\n            // throw errInfo;\n            return MyPromise.resolve(callback(value)).then(value=>value,errInfo=>{throw errInfo});\n        })\n    }\n\n    //捕获错误的回调\n    catch(failCallBack){\n        return this.then(undefined,failCallBack);\n    }\n}\n\nfunction resolvePromise (CurPromise,CurX,resolve,reject) {\n    //判断CurPromise和CurX是否是同一个promise\n    if(CurPromise === CurX){\n        //直接抛错并退出\n        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\n    }\n    //如何判断CurX是不是prmise 就判断它是不是MyPromise的实例\n    if(CurX instanceof MyPromise){\n        //是promise就需要调用then去查看它对应的状态,成功的调用resolve传递下去,失败调用reject\n        CurX.then(value=>resolve(value),errInfo=>reject(errInfo))\n    }else{\n        resolve(CurX);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n",normalizedContent:"在理解promise原理之前，最好先理解观察者模式,因为在实现then链式调用的时候，需要这个前置知识。\n\n\n# 1.创建一个自己的promse一个类\n\npromse就是一个类,在执行这个类的时候 需要传递一个执行器 执行器立即执行\n\nclass mypromise {\n    //1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行\n    constructor (executor) {   \n        //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject\n        executor(this.resolve,this.reject);\n    }\n    \n    resolve = (value) => {}\n    \n    reject = (errinfo) => {}\n}\nmodule.exports = mypromise\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.promse的三种状态\n\n等待:pending 成功:rejected 失败fulfilled 一旦状态确认就不可更改\n\n//2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled\n//把状态定义成常量的好处是:1.复用性 2.编辑器会有提示,而字符串是没有提示的\nconst pending = 'pending';      //等待\nconst fulfilled = 'fulfilled';  //成功\nconst rejected = 'rejected';    //失败\n\nclass mypromise {\n    constructor (executor) {   \n        //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject\n        executor(this.resolve,this.reject);\n    }\n\n    //resolve和reject之所以定义成箭头函数就是为了让其内部this指向mypromise\n    resolve = () => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n    }\n\n    reject = () => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n    }\n}\n\nmodule.exports = mypromise\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 3.resolve和reject\n\nresolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled 调用reject是pending->rejected\n\nconst pending = 'pending';      //等待\nconst fulfilled = 'fulfilled';  //成功\nconst rejected = 'rejected';    //失败\n\nclass mypromise {\n    constructor (executor) {   \n        executor(this.resolve,this.reject);\n    }\n\n    //状态\n    status = pending;\n    //成功值\n    value = undefined;\n    //失败原因\n    errinfo = undefined;     \n\n    //3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected\n    resolve = () => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n        //将状态更改为成功\n        this.status = fulfilled;\n    }\n\n    reject = () => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n        //将状态更改为失败\n        this.status = rejected;\n    }\n    \n}\n\nmodule.exports = mypromise\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 4.then方法判断状态\n\n如果状态成功调用成功的回调 如果状态是失败则调用失败的回调函数\n\n//2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled\n//把状态定义成常量的好处是:1.复用性 2.编辑器会有提示,而字符串是没有提示的\nconst pending = 'pending';      //等待\nconst fulfilled = 'fulfilled';  //成功\nconst rejected = 'rejected';    //失败\n\nclass mypromise {\n    //1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行\n    constructor (executor) {   \n        //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject\n        executor(this.resolve,this.reject);\n    }\n\n    //状态\n    status = pending;\n    //成功值\n    value = undefined;\n    //失败原因\n    errinfo = undefined;     \n\n    //3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected\n    //resolve和reject之所以定义成箭头函数就是为了让其内部this指向mypromise\n    resolve = (value) => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n        //将状态更改为成功\n        this.status = fulfilled;\n        //保存成功之后的值\n        this.value = value;\n    }\n\n    reject = (errinfo) => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n        //将状态更改为失败\n        this.status = rejected;\n        //保存失败之后的值\n        this.errinfo = errinfo;\n    }\n    \n    then (successcallback,failcallback) {\n        //4.then方法内部做的事情就是判断状态,如果状态成功调用成功的回调 如果状态是失败则调用失败的回调函数\n        //5.成功回调参数:this.value 失败回调参数:errinfo\n        if(this.status === fulfilled) successcallback(this.value);\n        if(this.status === rejected) failcallback(this.errinfo);\n    }\n}\n\nmodule.exports = mypromise\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n代码片段测试,打印 ‘成功’.\n\nnew mypromise((resolve,reject)=>{\n    resolve('成功')\n    reject('失败')\n}).then((res)=>{\n    console.log(res);\n},(err)=>{\n    console.error(err)\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n加入异步代码测试. 一秒之后无输出. 首先执行器是一个同步代码最先被执行,然后执行then函数,由于状态还是pending,所以无任何输出,一秒之后状态被改变但是then已经执行了.\n\nnew mypromise((resolve,reject)=>{\n    settimeout(()=>{\n        resolve('成功');\n    },1000)\n}).then((res)=>{\n    console.log(res);\n},(err)=>{\n    console.error(err);\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 5.在promise类中加入异步代码\n\nconst pending = 'pending';      //等待\nconst fulfilled = 'fulfilled';  //成功\nconst rejected = 'rejected';    //失败\nclass mypromise {\n    constructor (executor) {   \n        executor(this.resolve,this.reject);\n    }\n    \n    status = pending;\n    value = undefined;\n    errinfo = undefined;     \n    successcallback = undefined;\n    failcallback = undefined;\n    resolve = (value) => {\n        if(this.status !== pending) return;\n        this.status = fulfilled;\n        this.value = value;\n        //判断成功回调是否是异步执行\n        this.successcallback && this.successcallback(value);\n    }\n\n    reject = (errinfo) => {\n        if(this.status !== pending) return;\n        this.status = rejected;\n        this.errinfo = errinfo;\n        //判断失败回调是否是异步执行\n        this.failcallback && this.failcallback(errinfo);        \n    }\n    \n    then (successcallback,failcallback) {\n        if(this.status === fulfilled) successcallback(this.value);\n        if(this.status === rejected) failcallback(this.errinfo);\n        if(this.status === pending) {\n        \t\t//在then中加入异步逻辑\n            this.successcallback = successcallback;\n            this.failcallback = failcallback;\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n但如果是多次调用呢,如下\n\npromise.then((res)=>{\n    console.log(res);\n},(err)=>{\n    console.error(err);\n})\n\npromise.then((res)=>{\n    console.log(res);\n},(err)=>{\n    console.error(err);\n})\n\npromise.then((res)=>{\n    console.log(res);\n},(err)=>{\n    console.error(err);\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 6.实现then方法多次使用\n\nconst pending = 'pending';      //等待\nconst fulfilled = 'fulfilled';  //成功\nconst rejected = 'rejected';    //失败\n\nclass mypromise {\n    constructor (executor) {   \n        executor(this.resolve,this.reject);\n    }\n    status = pending;\n    value = undefined;\n    errinfo = undefined;     \n    //成功回调\n    successcallback = [];\n    //失败回调\n    failcallback = [];\n    resolve = (value) => {\n        if(this.status !== pending) return;\n        this.status = fulfilled;\n        this.value = value;\n        //判断成功回调是否是异步执行\n        while(this.successcallback.length) this.successcallback.shift()(value);\n    }\n\n    reject = (errinfo) => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n        //将状态更改为失败\n        this.status = rejected;\n        //保存失败之后的值\n        this.errinfo = errinfo;\n        //判断失败回调是否是异步执行\n        while(this.failcallback.length)this.failcallback.shift()(errinfo);\n    }\n    \n    then (successcallback,failcallback) {\n        if(this.status === fulfilled) successcallback(this.value);\n        if(this.status === rejected) failcallback(this.errinfo);\n        if(this.status === pending) {\n            this.successcallback.push(successcallback);\n            this.failcallback.push(failcallback);\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 7.then实现return一个值的链式调用\n\n后面then方法的回调函数拿到的值是上一个then方法的回调函数的返回值,如下,最后需要打印 '成功’和100.\n\nlet promise = new mypromise((resolve,reject)=>{\n    resolve('成功');\n}).then((res)=>{\n    console.log(res);\n    return 100\n}).then((res)=>{\n    console.log(res);\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这里主要修改then中的代码,then中要返回一个新的promise对象,而且每次接收的参数要是上次一返回的值,其实then中的第一个参数就是successcallback,要得到它的返回值调用一下它即可.\n\n  then (successcallback,failcallback) {\n      return new mypromise((resolve,reject)=>{\n          if(this.status === fulfilled) {\n              const x = successcallback(this.value);\n              resolve(x);\n          }\n      })\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 8.then实现return新promise时的链式调用\n\n如下,最后应该要打印 ‘成功’和’other’\n\nfunction other () {\n    return new mypromise((resolve,reject)=>{\n        resolve('other');\n    })\n}\nlet promise = new mypromise((resolve,reject)=>{\n    resolve('成功');\n}).then((res)=>{\n    console.log(res);\n    return other()\n}).then((res)=>{\n    console.log(res);\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这里的x不确定是一个值还是一个promise对象. 需要对他进行判断,如果是promise则需要对它返回的值进行判断,同样成功调用resolve,失败调用reject\n\nthen (successcallback,failcallback) {\n  //8.实现链式调用,每次都返回一个新的实例\n  return new mypromise((resolve,reject)=>{\n      if(this.status === fulfilled) {\n          const x = successcallback(this.value);\n          resolvepromise(x,resolve,reject);\n          //resolve(x);\n      }\n      if(this.status === rejected) failcallback(this.errinfo);\n      if(this.status === pending) {\n          //6.在promise中加入异步代码\n          this.successcallback.push(successcallback);\n          this.failcallback.push(failcallback);\n      }\n  })\n}\n\nfunction resolvepromise (x,resolve,reject) {\n    //如何判断x是不是prmise 就判断它是不是mypromise的实例\n    if(x instanceof mypromise){\n        //是promise就需要调用then去查看它对应的状态,成功的调用resolve传递下去,失败调用reject\n        x.then(value=>resolve(value),errinfo=>reject(errinfo))\n    }else{\n        resolve(x);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 9.循环调用异常处理\n\nthen返回的promise对象就是最后所生成的对象,所以在then的成功回调中不能再次返回被声明的promise,不然会出现循环调用的情况,如下\n\nlet other = new promise((resolve,reject)=>{\n    settimeout(() => {\n        resolve('other');\n    }, 100);\n})\n\nlet p1 = other.then(value=>{\n    console.log(value)\n    return p1\n})\n\np1.then(value=>{\n    console.log(value)\n},(errinfo)=>{\n    console.log(errinfo.message)\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n具体实现主要是判断curpromise和curx是否是同一个promise,如果是就抛出错误,不是的话继续执行\n\nthen (successcallback,failcallback) {\n    const curpromise = new mypromise((resolve,reject)=>{\n        if(this.status === fulfilled) {\n            //这里是为了使用异步执行,因为当前这个执行器是被立即执行的,此时new mypromise的操作并未完成,故拿不到curpromise\n            settimeout(()=>{\n                const curx = successcallback(this.value);\n                //10.首先.then最后返回的是curpromise,所以在then的成功回调中不能再次返回被声明的promise,不然会出现循环调用的情况\n                resolvepromise(curpromise,curx,resolve,reject);\n            },0)\n        }\n        if(this.status === rejected) failcallback(this.errinfo);\n        if(this.status === pending) {\n            this.successcallback.push(successcallback);\n            this.failcallback.push(failcallback);\n        }\n    })\n    return curpromise\n}\nfunction resolvepromise (curpromise,curx,resolve,reject) {\n    //判断curpromise和curx是否是同一个promise\n    if(curpromise === curx){\n        //直接抛错并退出\n        return reject(new typeerror('chaining cycle detected for promise #<promise>'))\n    }\n    //如何判断curx是不是prmise 就判断它是不是mypromise的实例\n    if(curx instanceof mypromise){\n        //是promise就需要调用then去查看它对应的状态,成功的调用resolve传递下去,失败调用reject\n        curx.then(value=>resolve(value),errinfo=>reject(errinfo))\n    }else{\n        resolve(curx);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 10.目前为止全部代码\n\n//2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled\n//把状态定义成常量的好处是:1.复用性 2.编辑器会有提示,而字符串是没有提示的\nconst pending = 'pending';      //等待\nconst fulfilled = 'fulfilled';  //成功\nconst rejected = 'rejected';    //失败\n\nclass mypromise {\n    //1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行\n    constructor (executor) {\n        //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject\n        executor(this.resolve,this.reject);\n    }\n\n    //状态\n    status = pending;\n    //成功值\n    value = undefined;\n    //失败原因\n    errinfo = undefined;     \n\n    //成功回调\n    successcallback = [];\n    //失败回调\n    failcallback = [];\n\n    //3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected\n    //resolve和reject之所以定义成箭头函数就是为了让其内部this指向mypromise\n\n    //传递成功的函数\n    resolve = (value) => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n        //将状态更改为成功\n        this.status = fulfilled;\n        //保存成功之后的值\n        this.value = value;\n        //判断成功回调是否是异步执行\n        //this.successcallback && this.successcallback(value);\n        while(this.successcallback.length){\n            //7.then方法多次调用,依次执行\n            this.successcallback.shift()(value);\n        }\n    }\n\n    //传递失败对应的函数\n    reject = (errinfo) => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n        //将状态更改为失败\n        this.status = rejected;\n        //保存失败之后的值\n        this.errinfo = errinfo;\n        //判断失败回调是否是异步执行\n        // this.failcallback && this.failcallback(errinfo);     \n        while(this.failcallback.length){\n            //then方法多次调用,依次执行\n            this.failcallback.shift()(errinfo);\n        }\n    }\n    \n    //查看状态的函数\n    then (successcallback,failcallback) {\n        //8.实现链式调用,每次都返回一个新的实例\n        const curpromise = new mypromise((resolve,reject)=>{\n            //4.then方法内部做的事情就是判断状态,如果状态成功调用成功的回调 如果状态是失败则调用失败的回调函数\n            //5.成功回调参数:this.value 失败回调参数:errinfo\n            if(this.status === fulfilled) {\n                //这里是为了使用异步执行,因为当前这个执行器是被立即执行的,此时new mypromise的操作并未完成,故拿不到curpromise\n                settimeout(()=>{\n                    const curx = successcallback(this.value);\n                    //9.这里的curx不确定是一个值还是一个promise对象. 需要对他进行判断,如果是promise则需要对它返回的值进行判断,同样成功调用resolve,失败调用reject\n                    //resolvepromise(curx,resolve,reject);\n                    //resolve(curx);\n                    //10.首先.then最后返回的是curpromise,所以在then的成功回调中不能再次返回被声明的promise,不然会出现循环调用的情况\n                    resolvepromise(curpromise,curx,resolve,reject);\n                },0)\n            }\n            if(this.status === rejected) failcallback(this.errinfo);\n            if(this.status === pending) {\n                //6.在promise中加入异步代码\n                this.successcallback.push(successcallback);\n                this.failcallback.push(failcallback);\n            }\n        })\n        return curpromise\n    }\n}\n\nfunction resolvepromise (curpromise,curx,resolve,reject) {\n    //判断curpromise和curx是否是同一个promise\n    if(curpromise === curx){\n        //直接抛错并退出\n        return reject(new typeerror('chaining cycle detected for promise #<promise>'))\n    }\n    //如何判断curx是不是prmise 就判断它是不是mypromise的实例\n    if(curx instanceof mypromise){\n        //是promise就需要调用then去查看它对应的状态,成功的调用resolve传递下去,失败调用reject\n        curx.then(value=>resolve(value),errinfo=>reject(errinfo))\n    }else{\n        resolve(curx);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n\n\n\n# 11.加入异常处理\n\n为了程序的健壮性,需要对代码进行各种异常处理. 如:executor函数,successcallback函数,failcallback函数\n\n//2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled\n//把状态定义成常量的好处是:1.复用性 2.编辑器会有提示,而字符串是没有提示的\nconst pending = 'pending';      //等待\nconst fulfilled = 'fulfilled';  //成功\nconst rejected = 'rejected';    //失败\n\nclass mypromise {\n    //1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行\n    constructor (executor) {\n        try {\n            //异常情况处理\n            //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject\n            executor(this.resolve,this.reject);\n        }catch(err){\n            this.reject(err)\n        }\n    }\n\n    //状态\n    status = pending;\n\n    //成功值\n    value = undefined;\n\n    //失败原因\n    errinfo = undefined;     \n\n    //成功回调\n    successcallback = [];\n    \n    //失败回调\n    failcallback = [];\n\n    //3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected\n    //resolve和reject之所以定义成箭头函数就是为了让其内部this指向mypromise\n\n    //传递成功的函数\n    resolve = (value) => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n        //将状态更改为成功\n        this.status = fulfilled;\n        //保存成功之后的值\n        this.value = value;\n        //判断成功回调是否是异步执行\n        //this.successcallback && this.successcallback(value);\n        while(this.successcallback.length){\n            //7.then方法多次调用,依次执行\n            // this.successcallback.shift()(value);\n            //参数都已经被收集到数组中的函数调用了,不需要传参;\n            this.successcallback.shift()();\n        }\n    }\n\n    //传递失败对应的函数\n    reject = (errinfo) => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n        //将状态更改为失败\n        this.status = rejected;\n        //保存失败之后的值\n        this.errinfo = errinfo;\n        //判断失败回调是否是异步执行\n        // this.failcallback && this.failcallback(errinfo);     \n        while(this.failcallback.length){\n            //then方法多次调用,依次执行\n            // this.failcallback.shift()(errinfo);\n            //参数都已经被收集到数组中的函数调用了,不需要传参;\n            this.failcallback.shift()();\n        }\n    }\n    \n    //查看状态的函数\n    then (successcallback,failcallback) {\n        //8.实现链式调用,每次都返回一个新的实例\n        const curpromise = new mypromise((resolve,reject)=>{\n            //4.then方法内部做的事情就是判断状态,如果状态成功调用成功的回调 如果状态是失败则调用失败的回调函数\n            //5.成功回调参数:this.value 失败回调参数:errinfo\n            if(this.status === fulfilled) {\n                //这里是为了使用异步执行,因为当前这个执行器是被立即执行的,此时new mypromise的操作并未完成,故拿不到curpromise\n                settimeout(()=>{\n                    try {\n                        //异常情况处理\n                        const curx = successcallback(this.value);\n                        //9.这里的curx不确定是一个值还是一个promise对象. 需要对他进行判断,如果是promise则需要对它返回的值进行判断,同样成功调用resolve,失败调用reject\n                        //resolvepromise(curx,resolve,reject);\n                        //resolve(curx);\n                        //10.首先.then最后返回的是curpromise,所以在then的成功回调中不能再次返回被声明的promise,不然会出现循环调用的情况\n                        resolvepromise(curpromise,curx,resolve,reject);\n                    }catch(err){\n                        reject(err)\n                    }\n                },0)\n            }else if(this.status === rejected) {\n                settimeout(()=>{\n                    try {\n                        //异常情况处理\n                        const curx = failcallback(this.errinfo);\n                        resolvepromise(curpromise,curx,resolve,reject);\n                    }catch(err){\n                        reject(err)\n                    }\n                },0)\n            }else if(this.status === pending) {\n                //6.在promise中加入异步代码\n                this.successcallback.push(()=>{\n                    settimeout(()=>{\n                        try {\n                            //异常情况处理\n                            const curx = successcallback(this.value);\n                            resolvepromise(curpromise,curx,resolve,reject);\n                        }catch(err){\n                            reject(err)\n                        }                    \n                    },0)\n                });\n                this.failcallback.push(()=>{\n                    settimeout(()=>{\n                        try {\n                            //异常情况处理\n                            const curx = failcallback(this.errinfo);\n                            resolvepromise(curpromise,curx,resolve,reject);\n                        }catch(err){\n                            reject(err)\n                        }                    \n                    },0)\n                });\n            }\n        })\n        return curpromise\n    }\n}\n\nfunction resolvepromise (curpromise,curx,resolve,reject) {\n    //判断curpromise和curx是否是同一个promise\n    if(curpromise === curx){\n        //直接抛错并退出\n        return reject(new typeerror('chaining cycle detected for promise #<promise>'))\n    }\n    //如何判断curx是不是prmise 就判断它是不是mypromise的实例\n    if(curx instanceof mypromise){\n        //是promise就需要调用then去查看它对应的状态,成功的调用resolve传递下去,失败调用reject\n        curx.then(value=>resolve(value),errinfo=>reject(errinfo))\n    }else{\n        resolve(curx);\n    }\n}\n\nnew mypromise((resolve,reject)=>{\n    //throw new error('executor error')\n    settimeout(()=>{\n        reject('reject');\n    },1000)\n})\n.then(value=>{\n    console.log(value)\n    throw new error('then error')\n},(errinfo)=>{\n    throw new error('then error')\n    //return 100\n})\n.then(value=>{\n    console.log(value)\n},(errinfo)=>{\n    console.log('eee')\n    console.log(errinfo.message)\n})\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n\n\n\n# 12.then参数可选\n\n当then没有回调的时候,还是要把值继续延续下去,知道有回调为止.具体主要是通过补充一个函数把值传递下去,如下在then中加入判断:\n\nsuccesscallback = successcallback ? successcallback : value=>value;\nfailcallback = failcallback ? failcallback : errinfo=>{throw errinfo};\n\n\n1\n2\n\n\nnew mypromise((resolve,reject)=>{\n    reject('resolve');\n})\n.then()\n.then()\n.then(value=>{\n\tconsole.log(value)\n},err=>{\n    console.log(err)\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 13.promise all静态方法\n\n按照数组中的顺序返回对应的值,有一个失败就终止\n\n  function p1 () {\n      return new mypromise((resolve,reject)=>{\n          settimeout(()=>{\n              resolve('1111')\n          },1000)\n      })\n  }\n\n  function p2 () {\n      return new mypromise((resolve,reject)=>{\n          resolve('222')\n      })\n  }\n\n\t//静态方法,可以直接调用\n  mypromise.all([p1(),p2(),'3','4','5','6']).then((result)=>{\n    console.log(result)\n    // result -> ['1111','222','3','4','5','6'] \n  },(err)=>{\n      console.log(err)\n  })\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n//批量执行\nstatic all (array) {\n    let result = [];\n    let index = 0;\n    return new mypromise((resolve,rejected)=>{\n        function adddata (value,i) {\n            index++;\n            result[i] = value;\n            if(index === array.length){\n                //等待所以的异步操作完成之后,才能输出\n                resolve(result)\n            }\n        }\n        for (let i = 0 ; i< array.length ; i++){\n            if(array[i] instanceof mypromise){\n                //如果是mypromise对象那么执行它,最后看它的状态是什么,如果成功那么添加数据,如果失败那么终止操作\n                array[i].then(value=>adddata(value,i),(errinfo)=>rejected(errinfo));\n            }else{\n                //普通值,直接添加数据\n                adddata(array[i],i)\n            }\n        }\n    })\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 14.promise resolve静态方法\n\n也是一个静态方法,把给定的值转成promise对象,\n\n如果接受的是一个值,那么创建一个promise对象并把该直接传递下去\n\n如果接受的是一个promise对象,那么直接返回该对象\n\nfunction p1 () {\n    return new mypromise((resolve,reject)=>{\n        resolve('hello')\n    })\n}\n//如果接受的是一个值,那么创建一个promise对象并把该直接传递下去\nmypromise.resolve(10).then((result)=>{console.log(result)});\n//如果接受的是一个promise对象,那么直接返回该对象\nmypromise.resolve(p1()).then((result)=>{console.log(result)});\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n//把给定的值转成promise对象\nstatic resolve (val) {\n  if(val instanceof mypromise) return val;\n  return new mypromise ((resolve,rejected)=>{\n  \tresolve (val)\n  });\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 15.promise finally方法\n\nfinally不是一个静态方法,它定义在类的原型上\n\n无论当前promise的执行是成功还是失败,finally当中的函数始终都会执行一次\n\n在finally后可以通过链式调用拿到当前的结果\n\nfunction p1 () {\n    return new mypromise((resolve,reject)=>{\n        resolve('finally')\n    })\n}\n\nfunction p2 () {\n    return new mypromise((resolve,reject)=>{\n        settimeout(()=>{\n            resolve('hello')\n        },1000)\n    })\n}\n\np1().finally((value)=>{\n    console.log(value)\n    return p2()\n}).then(value=>console.log(value),errinfo=>console.log(errinfo));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n//无论成功或失败都执行一次\nfinally(callback){\n    return this.then((value)=>{\n        //把值传递下去\n        // callback(value);\n        // return value\n        //处理异步\n        return mypromise.resolve(callback(value)).then(value=>value);\n    },(errinfo)=>{\n        //把错误传递下去\n        // callback(errinfo);\n        // throw errinfo;\n        return mypromise.resolve(callback(value)).then(value=>value,errinfo=>{throw errinfo});\n    })\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 16.promise中的catch方法\n\ncatch处理最终状态为失败的情况,在then中可以不传递失败回调,通过catch去捕获失败的回调,其实就是在catch方法的内部去调用then方法,成功回调传一个undefined,失败回调传递一个函数\n\n\nfunction p1 () {\n    return new mypromise((resolve,reject)=>{\n        resolve('finally')\n    })\n}\np1()\n.then(value=>console.log(value))\n.catch(errinfo=>console.log(errinfo))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n//捕获错误的回调\ncatch(failcallback){\n\treturn this.then(undefined,failcallback);\n}\n\n\n\n1\n2\n3\n4\n5\n\n\n\n# 17.最终代码\n\n//2.promse有三种状态,等待:pending 成功:rejected 失败fulfilled\n//把状态定义成常量的好处是:1.复用性 2.编辑器会有提示,而字符串是没有提示的\nconst pending = 'pending';      //等待\nconst fulfilled = 'fulfilled';  //成功\nconst rejected = 'rejected';    //失败\n\nclass mypromise {\n    //1.promse就是一个类 在执行这个类的时候 需要传递一个执行器 执行器立即执行\n    constructor (executor) {\n        try {\n            //11.异常情况处理\n            //executor:立即执行的执行器,它的两个回调函数分别是resolve,reject\n            executor(this.resolve,this.reject);\n        }catch(err){\n            this.reject(err)\n        }\n    }\n\n    //状态\n    status = pending;\n\n    //成功值\n    value = undefined;\n\n    //失败原因\n    errinfo = undefined;     \n\n    //成功回调\n    successcallback = [];\n    \n    //失败回调\n    failcallback = [];\n\n    //3.resolve和reject分别改变状态为成功和失败 调用resolve是pending->fulfilled  调用reject是pending->rejected\n    //resolve和reject之所以定义成箭头函数就是为了让其内部this指向mypromise\n\n    //传递成功的函数\n    resolve = (value) => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n        //将状态更改为成功\n        this.status = fulfilled;\n        //保存成功之后的值\n        this.value = value;\n        //判断成功回调是否是异步执行\n        //this.successcallback && this.successcallback(value);\n        while(this.successcallback.length){\n            //7.then方法多次调用,依次执行\n            // this.successcallback.shift()(value);\n            //参数都已经被收集到数组中的函数调用了,不需要传参;\n            this.successcallback.shift()();\n        }\n    }\n\n    //传递失败对应的函数\n    reject = (errinfo) => {\n        //一旦状态确认就不可更改\n        if(this.status !== pending) return;\n        //将状态更改为失败\n        this.status = rejected;\n        //保存失败之后的值\n        this.errinfo = errinfo;\n        //判断失败回调是否是异步执行\n        // this.failcallback && this.failcallback(errinfo);     \n        while(this.failcallback.length){\n            //then方法多次调用,依次执行\n            // this.failcallback.shift()(errinfo);\n            //参数都已经被收集到数组中的函数调用了,不需要传参;\n            this.failcallback.shift()();\n        }\n    }\n    \n    //查看状态的函数\n    then (successcallback,failcallback) {\n        //12.当then没有回调的时候,还是要把值继续延续下去,知道有回调为止\n        successcallback = successcallback ? successcallback : value=>value;\n        failcallback = failcallback ? failcallback : errinfo=>{throw errinfo};\n        //8.实现链式调用,每次都返回一个新的实例\n        const curpromise = new mypromise((resolve,reject)=>{\n            //4.then方法内部做的事情就是判断状态,如果状态成功调用成功的回调 如果状态是失败则调用失败的回调函数\n            //5.成功回调参数:this.value 失败回调参数:errinfo\n            if(this.status === fulfilled) {\n                //这里是为了使用异步执行,因为当前这个执行器是被立即执行的,此时new mypromise的操作并未完成,故拿不到curpromise\n                settimeout(()=>{\n                    try {\n                        //异常情况处理\n                        const curx = successcallback(this.value);\n                        //9.这里的curx不确定是一个值还是一个promise对象. 需要对他进行判断,如果是promise则需要对它返回的值进行判断,同样成功调用resolve,失败调用reject\n                        //resolvepromise(curx,resolve,reject);\n                        //resolve(curx);\n                        //10.首先.then最后返回的是curpromise,所以在then的成功回调中不能再次返回被声明的promise,不然会出现循环调用的情况\n                        resolvepromise(curpromise,curx,resolve,reject);\n                    }catch(err){\n                        reject(err)\n                    }\n                },0)\n            }else if(this.status === rejected) {\n                settimeout(()=>{\n                    try {\n                        //异常情况处理\n                        const curx = failcallback(this.errinfo);\n                        resolvepromise(curpromise,curx,resolve,reject);\n                    }catch(err){\n                        reject(err)\n                    }\n                },0)\n            }else if(this.status === pending) {\n                //6.在promise中加入异步代码\n                this.successcallback.push(()=>{\n                    settimeout(()=>{\n                        try {\n                            //异常情况处理\n                            const curx = successcallback(this.value);\n                            resolvepromise(curpromise,curx,resolve,reject);\n                        }catch(err){\n                            reject(err)\n                        }\n                    },0)\n                });\n                this.failcallback.push(()=>{\n                    settimeout(()=>{\n                        try {\n                            //异常情况处理\n                            const curx = failcallback(this.errinfo);\n                            resolvepromise(curpromise,curx,resolve,reject);\n                        }catch(err){\n                            reject(err)\n                        }\n                    },0)\n                });\n            }\n        })\n        return curpromise\n    }\n\n    //批量执行\n    static all (array) {\n        let result = [];\n        let index = 0;\n        return new mypromise((resolve,rejected)=>{\n            function adddata (value,i) {\n                index++;\n                result[i] = value;\n                if(index === array.length){\n                    //等待所以的异步操作完成之后,才能输出\n                    resolve(result)\n                }\n            }\n            for (let i = 0 ; i< array.length ; i++){\n                if(array[i] instanceof mypromise){\n                    //如果是mypromise对象那么执行它,最后看它的状态是什么,如果成功那么添加数据,如果失败那么终止操作\n                    array[i].then(value=>adddata(value,i),(errinfo)=>rejected(errinfo));\n                }else{\n                    //普通值,直接添加数据\n                    adddata(array[i],i)\n                }\n            }\n        })\n    }\n\n    //把给定的值转成promise对象\n    static resolve (val) {\n        if(val instanceof mypromise) return val;\n        return new mypromise ((resolve,rejected)=>{\n            resolve (val)\n        });\n    }\n\n    //无论成功或失败都执行一次\n    finally(callback){\n        return this.then((value)=>{\n            //把值传递下去\n            // callback(value);\n            // return value\n            //处理异步\n            return mypromise.resolve(callback(value)).then(value=>value);\n        },(errinfo)=>{\n            //把错误传递下去\n            // callback(errinfo);\n            // throw errinfo;\n            return mypromise.resolve(callback(value)).then(value=>value,errinfo=>{throw errinfo});\n        })\n    }\n\n    //捕获错误的回调\n    catch(failcallback){\n        return this.then(undefined,failcallback);\n    }\n}\n\nfunction resolvepromise (curpromise,curx,resolve,reject) {\n    //判断curpromise和curx是否是同一个promise\n    if(curpromise === curx){\n        //直接抛错并退出\n        return reject(new typeerror('chaining cycle detected for promise #<promise>'))\n    }\n    //如何判断curx是不是prmise 就判断它是不是mypromise的实例\n    if(curx instanceof mypromise){\n        //是promise就需要调用then去查看它对应的状态,成功的调用resolve传递下去,失败调用reject\n        curx.then(value=>resolve(value),errinfo=>reject(errinfo))\n    }else{\n        resolve(curx);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n",charsets:{cjk:!0},lastUpdated:"2022/03/08, 00:05:17",lastUpdatedTimestamp:1646669117e3},{title:"事件流",frontmatter:{title:"事件流",date:"2022-03-26T12:29:58.000Z",permalink:"/pages/bddf14/",categories:["前端","Javascript"],tags:["前端","Javascript"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/20.Javascript/8.%E4%BA%8B%E4%BB%B6.html",relativePath:"01.前端/20.Javascript/8.事件.md",key:"v-65dbf974",path:"/pages/bddf14/",headers:[{level:2,title:"什么事件",slug:"什么事件",normalizedTitle:"什么事件",charIndex:2},{level:2,title:"什么事件流",slug:"什么事件流",normalizedTitle:"什么事件流",charIndex:67},{level:2,title:"DOM事件流",slug:"dom事件流",normalizedTitle:"dom事件流",charIndex:77},{level:2,title:"vue事件",slug:"vue事件",normalizedTitle:"vue事件",charIndex:88}],headersStr:"什么事件 什么事件流 DOM事件流 vue事件",content:"# 什么事件\n\n> 事件是您在编程时系统内发生的动作或者发生的事情，系统响应事件后，如果需要，您可以某种方式对事件做出回应。\n\n\n# 什么事件流\n\n\n# DOM事件流\n\n\n# vue事件",normalizedContent:"# 什么事件\n\n> 事件是您在编程时系统内发生的动作或者发生的事情，系统响应事件后，如果需要，您可以某种方式对事件做出回应。\n\n\n# 什么事件流\n\n\n# dom事件流\n\n\n# vue事件",charsets:{cjk:!0},lastUpdated:"2022/04/05, 12:30:49",lastUpdatedTimestamp:1649133049e3},{title:"test",frontmatter:{title:"test",date:"2022-03-03T15:45:28.000Z",permalink:"/pages/7153e7/",categories:["前端","Typescript文章"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/30.Typescript/01.test.html",relativePath:"01.前端/30.Typescript/01.test.md",key:"v-fcfa1de8",path:"/pages/7153e7/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/03, 19:24:28",lastUpdatedTimestamp:1646306668e3},{title:"vite",frontmatter:{title:"vite",date:"2022-03-07T20:45:59.000Z",permalink:"/pages/c7216e/",categories:["前端","工程化"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%B7%A5%E7%A8%8B%E5%8C%96/10.vite.html",relativePath:"01.前端/40.工程化/10.vite.md",key:"v-5e4c81c5",path:"/pages/c7216e/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/07, 23:12:50",lastUpdatedTimestamp:164666597e4},{title:"webpack",frontmatter:{title:"webpack",date:"2022-03-07T20:45:49.000Z",permalink:"/pages/e8939e/",categories:["前端","工程化"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%B7%A5%E7%A8%8B%E5%8C%96/5.webpack.html",relativePath:"01.前端/40.工程化/5.webpack.md",key:"v-ec95f9fa",path:"/pages/e8939e/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/07, 23:12:50",lastUpdatedTimestamp:164666597e4},{title:"vue3进阶笔记之effect",frontmatter:{title:"vue3进阶笔记之effect",date:"2022-04-14T14:56:25.000Z",permalink:"/pages/dac852/",categories:["前端","vue"],tags:["Javascript","vue"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/50.vue/10.vue3%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0%E4%B9%8Beffect.html",relativePath:"01.前端/50.vue/10.vue3进阶笔记之effect.md",key:"v-9048fa48",path:"/pages/dac852/",headers:[{level:2,title:"effect 函数用法",slug:"effect-函数用法",normalizedTitle:"effect 函数用法",charIndex:127},{level:3,title:"普通例子",slug:"普通例子",normalizedTitle:"普通例子",charIndex:214},{level:3,title:"lazy 示例",slug:"lazy-示例",normalizedTitle:"lazy 示例",charIndex:638},{level:3,title:"scheduler 示例",slug:"scheduler-示例",normalizedTitle:"scheduler 示例",charIndex:986},{level:2,title:"effect 函数的实现",slug:"effect-函数的实现",normalizedTitle:"effect 函数的实现",charIndex:1417},{level:2,title:"effect 数据结构的实现",slug:"effect-数据结构的实现",normalizedTitle:"effect 数据结构的实现",charIndex:2106},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2513}],headersStr:"effect 函数用法 普通例子 lazy 示例 scheduler 示例 effect 函数的实现 effect 数据结构的实现 总结",content:"vue3的响应式是基于effect和reactive实现，所以想要理解vue3的响应式原理，就需要清楚effect是如何运作的。\n\nvue3定义了 effect 函数，也实现了用 ReactiveEffect 类来实现 effect 数据结构。\n\n\n# effect 函数用法\n\neffect 接受两个参数：fn 回调参数，option 可选参数对象。\n\neffect 返回一个函数，并且这个函数拥有effect属性。\n\n\n# 普通例子\n\nimport { effect } from \"vue\";\nlet uuid = 0\nconst name = '次'\nconst runner = effect(() => {\n    uuid++\n    console.log(uuid, name)\n})\n// 代码执行到这时 会打印 1 次\n\nrunner() // 会打印 2 次\n\nrunner.effect.run() // 会打印 3 次, 调用 runner 和 runner.effect.run 是执行一样的函数\n\nconsole.log(runner.effect) // 查看函数上effct数据结构，如下图\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n\neffect 函数只接受一个函数 fn 参数时候，会立即执行 fn 这个函数，并返回一个 runner 函数，当 调用 runner 时候，会触发 fn 函数。\n\n\n# lazy 示例\n\n可选参数里的 lazy 是个 Boolean 值。\n\nimport { effect, inject, provide, ref } from \"vue\";\nconst name = ref('lazy')\nconst runner = effect(() => {\n    console.log(name.value)\n}, { lazy: true})\n// 和普通示例不同，执行到这里的时候，并未打印 lazy\nrunner() // 会打印 lazy\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当effect 函数接受两个参数，一个参数为函数fn，另外一个可选参数lazy为true时候，fn 函数不会立即执行了，只有执行 runner 才会触发fn函数执行。 当\n\n\n# scheduler 示例\n\n可选参数里的 scheduler 是个 函数。\n\nimport { effect, ref } from \"vue\";\nconst name = ref('执行effect')\nconst scheduler = () => {\n  console.log('scheduler执行了！')\n}\nconst runner = effect(() => {\n    console.log(name.value)\n}, { scheduler})\nrunner() // 注意 scheduler 函数没有执行\nname.value = 'action'\nrunner() // 此刻才会执行 scheduler 函数\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\neffect接受了scheduler可选参数后，函数fn也不会立即执行。effect里的依赖数据发生改变时候，才会触发 scheduler 函数执行。\n\n\n# effect 函数的实现\n\n只关注重点，省略一些特殊情况处理代码。\n\nexport function effect<T = any>(\n  fn: () => T,\n  options?: ReactiveEffectOptions\n): ReactiveEffectRunner {\n  // 实例化 ReactiveEffect,并赋值给_effect,\n  const _effect = new ReactiveEffect(fn)\n    \n  // 合并可选参数，例如 lazy，scheduler\n  if (options) { \n    extend(_effect, options)\n  }  \n    \n  // 如果 没有可选参数的时候，就不会执行 run，这也就是 为什么 上面会打印 1次 的原因\n  // 获取 lazy 为 true 的时候， 也不会执行 run\n  if (!options || !options.lazy) {\n    _effect.run()\n  }\n\n  // 手动把run函数的中this指向给_effect\n  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner\n  // 返回函数的 effect 属性\n  runner.effect = _effect\n  return runner\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# effect 数据结构的实现\n\nexport class ReactiveEffect<T = any> {\n  active = true \n  deps: Dep[] = []\n  computed?: boolean\n  allowRecurse?: boolean\n  onStop?: () => void\n  constructor(\n    public fn: () => T,\n    public scheduler: EffectScheduler | null = null, \n  ) {\n  }\n  run() {\n      this.fn()\n  }\n  stop() {}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n目前只关注 effect 的数据结构，只需要了解 run 方法执行的时候 会执行 fn 函数即可。\n\n\n# 总结\n\neffect 函数只接受一个函数的时候，会立即执行这个函数，并且返回一个函数。 返回的函数执行的时候，会触发参数函数执行。\n\neffect 可以通过 lazy 来控制参数函数是否延迟执行。\n\neffect 可以通过 scheduler 来调度依赖变更的时候，触发 scheduler 函数执行。",normalizedContent:"vue3的响应式是基于effect和reactive实现，所以想要理解vue3的响应式原理，就需要清楚effect是如何运作的。\n\nvue3定义了 effect 函数，也实现了用 reactiveeffect 类来实现 effect 数据结构。\n\n\n# effect 函数用法\n\neffect 接受两个参数：fn 回调参数，option 可选参数对象。\n\neffect 返回一个函数，并且这个函数拥有effect属性。\n\n\n# 普通例子\n\nimport { effect } from \"vue\";\nlet uuid = 0\nconst name = '次'\nconst runner = effect(() => {\n    uuid++\n    console.log(uuid, name)\n})\n// 代码执行到这时 会打印 1 次\n\nrunner() // 会打印 2 次\n\nrunner.effect.run() // 会打印 3 次, 调用 runner 和 runner.effect.run 是执行一样的函数\n\nconsole.log(runner.effect) // 查看函数上effct数据结构，如下图\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n\neffect 函数只接受一个函数 fn 参数时候，会立即执行 fn 这个函数，并返回一个 runner 函数，当 调用 runner 时候，会触发 fn 函数。\n\n\n# lazy 示例\n\n可选参数里的 lazy 是个 boolean 值。\n\nimport { effect, inject, provide, ref } from \"vue\";\nconst name = ref('lazy')\nconst runner = effect(() => {\n    console.log(name.value)\n}, { lazy: true})\n// 和普通示例不同，执行到这里的时候，并未打印 lazy\nrunner() // 会打印 lazy\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当effect 函数接受两个参数，一个参数为函数fn，另外一个可选参数lazy为true时候，fn 函数不会立即执行了，只有执行 runner 才会触发fn函数执行。 当\n\n\n# scheduler 示例\n\n可选参数里的 scheduler 是个 函数。\n\nimport { effect, ref } from \"vue\";\nconst name = ref('执行effect')\nconst scheduler = () => {\n  console.log('scheduler执行了！')\n}\nconst runner = effect(() => {\n    console.log(name.value)\n}, { scheduler})\nrunner() // 注意 scheduler 函数没有执行\nname.value = 'action'\nrunner() // 此刻才会执行 scheduler 函数\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\neffect接受了scheduler可选参数后，函数fn也不会立即执行。effect里的依赖数据发生改变时候，才会触发 scheduler 函数执行。\n\n\n# effect 函数的实现\n\n只关注重点，省略一些特殊情况处理代码。\n\nexport function effect<t = any>(\n  fn: () => t,\n  options?: reactiveeffectoptions\n): reactiveeffectrunner {\n  // 实例化 reactiveeffect,并赋值给_effect,\n  const _effect = new reactiveeffect(fn)\n    \n  // 合并可选参数，例如 lazy，scheduler\n  if (options) { \n    extend(_effect, options)\n  }  \n    \n  // 如果 没有可选参数的时候，就不会执行 run，这也就是 为什么 上面会打印 1次 的原因\n  // 获取 lazy 为 true 的时候， 也不会执行 run\n  if (!options || !options.lazy) {\n    _effect.run()\n  }\n\n  // 手动把run函数的中this指向给_effect\n  const runner = _effect.run.bind(_effect) as reactiveeffectrunner\n  // 返回函数的 effect 属性\n  runner.effect = _effect\n  return runner\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# effect 数据结构的实现\n\nexport class reactiveeffect<t = any> {\n  active = true \n  deps: dep[] = []\n  computed?: boolean\n  allowrecurse?: boolean\n  onstop?: () => void\n  constructor(\n    public fn: () => t,\n    public scheduler: effectscheduler | null = null, \n  ) {\n  }\n  run() {\n      this.fn()\n  }\n  stop() {}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n目前只关注 effect 的数据结构，只需要了解 run 方法执行的时候 会执行 fn 函数即可。\n\n\n# 总结\n\neffect 函数只接受一个函数的时候，会立即执行这个函数，并且返回一个函数。 返回的函数执行的时候，会触发参数函数执行。\n\neffect 可以通过 lazy 来控制参数函数是否延迟执行。\n\neffect 可以通过 scheduler 来调度依赖变更的时候，触发 scheduler 函数执行。",charsets:{cjk:!0},lastUpdated:"2022/04/16, 10:11:11",lastUpdatedTimestamp:1650075071e3},{title:"vue3进阶笔记之reactive",frontmatter:{title:"vue3进阶笔记之reactive",date:"2022-04-09T12:26:30.000Z",permalink:"/pages/1c753e/",categories:["前端","vue"],tags:["Javascript","vue"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/50.vue/12.vue3%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0%E4%B9%8Breactive.html",relativePath:"01.前端/50.vue/12.vue3进阶笔记之reactive.md",key:"v-0e8cebc8",path:"/pages/1c753e/",headers:[{level:2,title:"感知存取",slug:"感知存取",normalizedTitle:"感知存取",charIndex:104},{level:2,title:"依赖数据",slug:"依赖数据",normalizedTitle:"依赖数据",charIndex:882},{level:2,title:"响应式思想",slug:"响应式思想",normalizedTitle:"响应式思想",charIndex:932},{level:2,title:"依赖数据",slug:"依赖数据-2",normalizedTitle:"依赖数据",charIndex:882},{level:2,title:"收集依赖",slug:"收集依赖",normalizedTitle:"收集依赖",charIndex:908},{level:2,title:"触发依赖",slug:"触发依赖",normalizedTitle:"触发依赖",charIndex:920},{level:2,title:"reactive",slug:"reactive",normalizedTitle:"reactive",charIndex:14}],headersStr:"感知存取 依赖数据 响应式思想 依赖数据 收集依赖 触发依赖 reactive",content:"本文的目的：写一个min版的reactive和effect，弄清楚vue3响应式是如何工作的\n\nreactive 函数接受一个对象作为参数，并返回一个代理对象。详细用法参考官方文档：reactive\n\n\n# 感知存取\n\n平常我们是这样获取和修改对象属性的：\n\n// 定义一个 obj 对象\nconst obj = {age: 20}\n// 修改 obj 的 age 属性\nobj.age = 22\n// 访问 对象属性\nconsole.log(obj.age)\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们可以直接访问和修改对象属性，但是如果我们想感知到这些操作该怎么办？也就是说，访问的时候，告诉我你访问了；修改的时候，告诉我你修改了。\n\n为了实现感知对象操作功能，我们需要: Proxy, Reflect 这两个API。\n\nconst obj = {age: 22}\nnew Proxy(obj, {\n    get(target, key, receiver) {\n        console.log('访问!!!');\n        return Reflect.get(target, key, receiver)\n    },\n    set(target, key, value, receiver) {\n        const result = Reflect.set(target, key, value, receiver)\n        console.log('修改！！！');\n        return result\n    }\n    \n})\n// 获取对象属性\nconsole.log(obj.age)\n\n// 修改对象属性\nobj.age = 30\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nProxy 第二个参数是个对象，这个对象包含了get和set函数。\n\n在get函数里我们可以感知到获取对象属性的操作，在set函数里我们可以感知到对象修改属性的操作。\n\n\n# 依赖数据\n\n非常好，接下来，我们可以在get的时候，收集依赖，set的时候，触发依赖更新。\n\n\n# 响应式思想\n\n我们先来看看下面的代码\n\nlet x = 0;\nlet y = 0\n\nfunction change() {\n    y = x * 2\n}\nx = 2\nchange() // y = 4\n\nx = 4\nchange() // y = 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ny和x的关系是： y是x的2倍。当x变更的时候，通过调用 change 函数，y也会变化。\n\n我们是手动调用的，而响应式是值，当x变更的时候，会自动调用 change 函数。\n\n把依赖关系封装成一个函数，当依赖变更的时候，自动调用这个函数，这就是响应式思想。\n\n\n# 依赖数据\n\neffect-函数的实现,一文介绍了 effect 函数源码。\n\nfunction effect(fn, options) {\n    // 创建依赖数据\n    const _effect = new ReactiveEffect(fn)\n    // 延迟执行，computer 的时候会用上\n    if (!options || !options.lazy) {\n        _effect.run()\n    }\n    // 手动绑定this\n    const runner = _effect.run.bind(_effect)\n    runner.effect = _effect\n    return runner\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nlet activeEffect = undefined // 当前 effect\nlet shouldTrack = false // 是否可以收集依赖\n\nclass ReactiveEffect {\n    deps = [] // 存储 响应式收集\n    active = true // 控制是否收集响应式依赖\n\n    constructor(fn, scheduler) {\n        this.fn = fn\n        this.scheduler = scheduler // 是否调度执行\n    }\n\n    run() { // 执行 相适应依赖收集\n        if (!this.active) {\n            return this.fn()\n        }\n        activeEffect = this // 当前依赖数据\n        shouldTrack = true // 开启依赖收集\n        const result = this.fn() \n        shouldTrack = false // 介绍依赖收集\n        return result\n    }\n\n    stop() { // 停止\n        if (this.active) {\n            this.deps.forEach(dep => {\n                dep.delete(this)\n            })\n            this.active = false\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 收集依赖\n\n当读取对象属性的时候，就进行依赖收集。\n\nconst targetMap = new WeakMap() // 存储依赖数据\n// 收集依赖。\nfunction track(target, key) {\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n        // 如果没有目标对象 target 的依赖，就声明一个空的 Map\n        targetMap.set(target, (depsMap = new Map()))\n    }\n    // 根据找到对应的 依赖\n    let dep = depsMap.get(key)\n    if (!dep) {\n        // 如果 没有 key 对应的依赖，就声明一个空的 Set\n        depsMap.set(key, dep = new Set())\n    }\n    \n    // 进入依赖收集程序\n    trackEffects(dep)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这里利用了WeakMap、Map、Set三种数据结构来存储依赖。\n\nfunction trackEffects(dep) {\n    if(!dep.has(activeEffect)) { // 防止重复收集\n        dep.add(activeEffect) // 收集 reactive 对象的依赖\n        activeEffect.deps.push(dep) // 收集 effect 包裹的依赖\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 触发依赖\n\nfunction trigger(target, key) {\n    const depsMap = targetMap.get(target)\n    if (!depsMap) {\n        // 没有找到，就不触发依赖\n        return\n    }\n    const dep = depsMap.get(key)\n    // 找到 依赖后，遍历执行\n    for (const effect of dep) {\n        if (effect.scheduler) { // 调度执行\n            effect.scheduler()\n        } else {\n            effect.run()\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# reactive\n\nfunction reactive(target) {\n    if (!isObject(target)) {\n        // 如果不是对象数据类型，就直接返回本身\n        console.warn(`value cannot be made reactive: ${String(target)}`)\n        return target\n    }\n\n    return new Proxy(target, {\n        get(target, key, receiver) {\n            // 收集依赖\n            track(target, key)\n            return Reflect.get(target, key, receiver)\n        },\n        set(target, key, value, receiver) {\n            const result = Reflect.set(target, key, value, receiver)\n            // 触发依赖\n            trigger(target, key)\n            return result\n        }\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n测试代码\n\nconst obj = {\n    name: 'test',\n    age: 90\n}\nconst res = reactive(obj)\nconst runner = effect(() => {\n    console.log(res.name)\n    console.log(res.age)\n})\nres.name = '111' // 会触发 effect\nres.age = 200 // 会触发 effect\nstop(runner) // 停止收集\nres.name = '33' // effect 不会被执行\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n完整代码：reactive-effect",normalizedContent:"本文的目的：写一个min版的reactive和effect，弄清楚vue3响应式是如何工作的\n\nreactive 函数接受一个对象作为参数，并返回一个代理对象。详细用法参考官方文档：reactive\n\n\n# 感知存取\n\n平常我们是这样获取和修改对象属性的：\n\n// 定义一个 obj 对象\nconst obj = {age: 20}\n// 修改 obj 的 age 属性\nobj.age = 22\n// 访问 对象属性\nconsole.log(obj.age)\n\n\n1\n2\n3\n4\n5\n6\n\n\n我们可以直接访问和修改对象属性，但是如果我们想感知到这些操作该怎么办？也就是说，访问的时候，告诉我你访问了；修改的时候，告诉我你修改了。\n\n为了实现感知对象操作功能，我们需要: proxy, reflect 这两个api。\n\nconst obj = {age: 22}\nnew proxy(obj, {\n    get(target, key, receiver) {\n        console.log('访问!!!');\n        return reflect.get(target, key, receiver)\n    },\n    set(target, key, value, receiver) {\n        const result = reflect.set(target, key, value, receiver)\n        console.log('修改！！！');\n        return result\n    }\n    \n})\n// 获取对象属性\nconsole.log(obj.age)\n\n// 修改对象属性\nobj.age = 30\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nproxy 第二个参数是个对象，这个对象包含了get和set函数。\n\n在get函数里我们可以感知到获取对象属性的操作，在set函数里我们可以感知到对象修改属性的操作。\n\n\n# 依赖数据\n\n非常好，接下来，我们可以在get的时候，收集依赖，set的时候，触发依赖更新。\n\n\n# 响应式思想\n\n我们先来看看下面的代码\n\nlet x = 0;\nlet y = 0\n\nfunction change() {\n    y = x * 2\n}\nx = 2\nchange() // y = 4\n\nx = 4\nchange() // y = 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ny和x的关系是： y是x的2倍。当x变更的时候，通过调用 change 函数，y也会变化。\n\n我们是手动调用的，而响应式是值，当x变更的时候，会自动调用 change 函数。\n\n把依赖关系封装成一个函数，当依赖变更的时候，自动调用这个函数，这就是响应式思想。\n\n\n# 依赖数据\n\neffect-函数的实现,一文介绍了 effect 函数源码。\n\nfunction effect(fn, options) {\n    // 创建依赖数据\n    const _effect = new reactiveeffect(fn)\n    // 延迟执行，computer 的时候会用上\n    if (!options || !options.lazy) {\n        _effect.run()\n    }\n    // 手动绑定this\n    const runner = _effect.run.bind(_effect)\n    runner.effect = _effect\n    return runner\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nlet activeeffect = undefined // 当前 effect\nlet shouldtrack = false // 是否可以收集依赖\n\nclass reactiveeffect {\n    deps = [] // 存储 响应式收集\n    active = true // 控制是否收集响应式依赖\n\n    constructor(fn, scheduler) {\n        this.fn = fn\n        this.scheduler = scheduler // 是否调度执行\n    }\n\n    run() { // 执行 相适应依赖收集\n        if (!this.active) {\n            return this.fn()\n        }\n        activeeffect = this // 当前依赖数据\n        shouldtrack = true // 开启依赖收集\n        const result = this.fn() \n        shouldtrack = false // 介绍依赖收集\n        return result\n    }\n\n    stop() { // 停止\n        if (this.active) {\n            this.deps.foreach(dep => {\n                dep.delete(this)\n            })\n            this.active = false\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 收集依赖\n\n当读取对象属性的时候，就进行依赖收集。\n\nconst targetmap = new weakmap() // 存储依赖数据\n// 收集依赖。\nfunction track(target, key) {\n    let depsmap = targetmap.get(target)\n    if (!depsmap) {\n        // 如果没有目标对象 target 的依赖，就声明一个空的 map\n        targetmap.set(target, (depsmap = new map()))\n    }\n    // 根据找到对应的 依赖\n    let dep = depsmap.get(key)\n    if (!dep) {\n        // 如果 没有 key 对应的依赖，就声明一个空的 set\n        depsmap.set(key, dep = new set())\n    }\n    \n    // 进入依赖收集程序\n    trackeffects(dep)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这里利用了weakmap、map、set三种数据结构来存储依赖。\n\nfunction trackeffects(dep) {\n    if(!dep.has(activeeffect)) { // 防止重复收集\n        dep.add(activeeffect) // 收集 reactive 对象的依赖\n        activeeffect.deps.push(dep) // 收集 effect 包裹的依赖\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 触发依赖\n\nfunction trigger(target, key) {\n    const depsmap = targetmap.get(target)\n    if (!depsmap) {\n        // 没有找到，就不触发依赖\n        return\n    }\n    const dep = depsmap.get(key)\n    // 找到 依赖后，遍历执行\n    for (const effect of dep) {\n        if (effect.scheduler) { // 调度执行\n            effect.scheduler()\n        } else {\n            effect.run()\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# reactive\n\nfunction reactive(target) {\n    if (!isobject(target)) {\n        // 如果不是对象数据类型，就直接返回本身\n        console.warn(`value cannot be made reactive: ${string(target)}`)\n        return target\n    }\n\n    return new proxy(target, {\n        get(target, key, receiver) {\n            // 收集依赖\n            track(target, key)\n            return reflect.get(target, key, receiver)\n        },\n        set(target, key, value, receiver) {\n            const result = reflect.set(target, key, value, receiver)\n            // 触发依赖\n            trigger(target, key)\n            return result\n        }\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n测试代码\n\nconst obj = {\n    name: 'test',\n    age: 90\n}\nconst res = reactive(obj)\nconst runner = effect(() => {\n    console.log(res.name)\n    console.log(res.age)\n})\nres.name = '111' // 会触发 effect\nres.age = 200 // 会触发 effect\nstop(runner) // 停止收集\nres.name = '33' // effect 不会被执行\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n完整代码：reactive-effect",charsets:{cjk:!0},lastUpdated:"2022/04/16, 10:11:11",lastUpdatedTimestamp:1650075071e3},{title:"vue3进阶笔记之ref",frontmatter:{title:"vue3进阶笔记之ref",date:"2022-04-16T10:13:00.000Z",permalink:"/pages/ecd654/",categories:["前端","vue"],tags:["Javascript","vue"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/50.vue/14.vue3%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0%E4%B9%8Bref.html",relativePath:"01.前端/50.vue/14.vue3进阶笔记之ref.md",key:"v-c4f49838",path:"/pages/ecd654/",headers:[{level:2,title:"why",slug:"why",normalizedTitle:"why",charIndex:84},{level:2,title:"ref 源码实现",slug:"ref-源码实现",normalizedTitle:"ref 源码实现",charIndex:442}],headersStr:"why ref 源码实现",content:"vue3 声明相应数据有两个API：reactive、ref。\n\nvue3进阶笔记之reactive模拟了reactive的实现。本文接下来介绍ref的实现。\n\n\n# why\n\n有了reactive，为什么还要设计一个refAPI？\n\njs数据分为基本数据类型和引用数据类型。引用数据类型共享的引用地址，而基本类型不是。\n\n基本数据类型例子\n\nlet a = '1'\nlet b = a\na = '2'\nconsole.log(b) // 1  b 并没有改变\n\n\n1\n2\n3\n4\n\n\n引用数据类型例子\n\nlet objA = { name: 'a'}\nlet ojbB = objA\nobjA.name = 'b'\nconsole.log(ojbB.name) // b ojbB的name属性变更该了\n\n\n1\n2\n3\n4\n\n\n想要数据是响应式的，对于基本数据类型，不能共享引用地址，那该怎么办？\n\nvue3处理办法就是把基本数据类型封装成引用数据类型，这样就可以共享了。\n\n\n# ref 源码实现\n\nfunction ref(value?: unknown) {\n  return createRef(value)\n}\n// shallow 是浅代理\nfunction createRef(rawValue: unknown, shallow = false) {\n    if (isRef(rawValue)) {\n        return rawValue\n    }\n    return new RefImpl(rawValue, shallow)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n重点关注 RefImpl 这个类的实现。\n\nclass RefImpl<T> {\n  private _value: T\n  private _rawValue: T\n\n  public dep?: Dep = undefined // 存储依赖数据\n  public readonly __v_isRef = true\n\n  constructor(value: T, public readonly _shallow = false) {\n    this._rawValue = _shallow ? value : toRaw(value)\n    this._value = _shallow ? value : convert(value) // 如果是对象，就会调用reactive 实现查看下面\n  }\n\n  get value() {\n    trackRefValue(this) // 收集依赖\n    return this._value\n  }\n\n  set value(newVal) {\n    newVal = this._shallow ? newVal : toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = this._shallow ? newVal : convert(newVal) // 如果是对象，就会调用reactive 实现查看下面\n      triggerRefValue(this, newVal) // 更新依赖\n    }\n  }\n}\n\nconst convert = <T extends unknown>(val: T): T =>\n    isObject(val) ? reactive(val) : val\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n到这里我们知道了。ref包裹的数据存放在value属性上。当读取value的时候，收集依赖，更改value的时候，更新依赖，这里与reactive的逻辑是一样的。\n\n如果不是浅代理，对于引用数据类型，ref内部会调用reactive。说明ref既可以用于基本数据类型，也可以用引用数据类型。",normalizedContent:"vue3 声明相应数据有两个api：reactive、ref。\n\nvue3进阶笔记之reactive模拟了reactive的实现。本文接下来介绍ref的实现。\n\n\n# why\n\n有了reactive，为什么还要设计一个refapi？\n\njs数据分为基本数据类型和引用数据类型。引用数据类型共享的引用地址，而基本类型不是。\n\n基本数据类型例子\n\nlet a = '1'\nlet b = a\na = '2'\nconsole.log(b) // 1  b 并没有改变\n\n\n1\n2\n3\n4\n\n\n引用数据类型例子\n\nlet obja = { name: 'a'}\nlet ojbb = obja\nobja.name = 'b'\nconsole.log(ojbb.name) // b ojbb的name属性变更该了\n\n\n1\n2\n3\n4\n\n\n想要数据是响应式的，对于基本数据类型，不能共享引用地址，那该怎么办？\n\nvue3处理办法就是把基本数据类型封装成引用数据类型，这样就可以共享了。\n\n\n# ref 源码实现\n\nfunction ref(value?: unknown) {\n  return createref(value)\n}\n// shallow 是浅代理\nfunction createref(rawvalue: unknown, shallow = false) {\n    if (isref(rawvalue)) {\n        return rawvalue\n    }\n    return new refimpl(rawvalue, shallow)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n重点关注 refimpl 这个类的实现。\n\nclass refimpl<t> {\n  private _value: t\n  private _rawvalue: t\n\n  public dep?: dep = undefined // 存储依赖数据\n  public readonly __v_isref = true\n\n  constructor(value: t, public readonly _shallow = false) {\n    this._rawvalue = _shallow ? value : toraw(value)\n    this._value = _shallow ? value : convert(value) // 如果是对象，就会调用reactive 实现查看下面\n  }\n\n  get value() {\n    trackrefvalue(this) // 收集依赖\n    return this._value\n  }\n\n  set value(newval) {\n    newval = this._shallow ? newval : toraw(newval)\n    if (haschanged(newval, this._rawvalue)) {\n      this._rawvalue = newval\n      this._value = this._shallow ? newval : convert(newval) // 如果是对象，就会调用reactive 实现查看下面\n      triggerrefvalue(this, newval) // 更新依赖\n    }\n  }\n}\n\nconst convert = <t extends unknown>(val: t): t =>\n    isobject(val) ? reactive(val) : val\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n到这里我们知道了。ref包裹的数据存放在value属性上。当读取value的时候，收集依赖，更改value的时候，更新依赖，这里与reactive的逻辑是一样的。\n\n如果不是浅代理，对于引用数据类型，ref内部会调用reactive。说明ref既可以用于基本数据类型，也可以用引用数据类型。",charsets:{cjk:!0},lastUpdated:"2022/04/16, 10:53:15",lastUpdatedTimestamp:1650077595e3},{title:"vue3进阶笔记之provide、inject",frontmatter:{title:"vue3进阶笔记之provide、inject",date:"2022-04-16T10:51:36.000Z",permalink:"/pages/3c450a/",categories:["前端","vue"],tags:["Javascript","vue"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/50.vue/16.vue3%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0%E4%B9%8Bprovide%E3%80%81inject.html",relativePath:"01.前端/50.vue/16.vue3进阶笔记之provide、inject.md",key:"v-1548b5a9",path:"/pages/3c450a/",headers:[{level:2,title:"provide 源码",slug:"provide-源码",normalizedTitle:"provide 源码",charIndex:28},{level:3,title:"组件是如何创建provides",slug:"组件是如何创建provides",normalizedTitle:"组件是如何创建provides",charIndex:892},{level:2,title:"inject 源码实现",slug:"inject-源码实现",normalizedTitle:"inject 源码实现",charIndex:1453},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2816}],headersStr:"provide 源码 组件是如何创建provides inject 源码实现 总结",content:'本文主要vue3中弄清楚依赖注入是如何实现的。\n\n\n# provide 源码\n\nexport function provide<T>(key: InjectionKey<T> | string | number, value: T) {\n    if (!currentInstance) {\n        if (__DEV__) {\n            warn(`provide() can only be used inside setup().`)\n        }\n    } else {\n        // currentInstance 是当前组件示例\n        let provides = currentInstance.provides\n        // 父组件的provides： 当前组件实例 没有的话，就去父组件的 provides\n        // 为什么是从当前组件里开始获取 父组件的 provides？\n        const parentProvides =\n            currentInstance.parent && currentInstance.parent.provides\n        if (parentProvides === provides) {\n            // 通过 Object.create 指定 parentProvides 为 provides的原型\n            provides = currentInstance.provides = Object.create(parentProvides)\n        }\n        // 处理 好 provides 后，进行赋值操作\n        provides[key as string] = value\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n源码虽然简短，但是理解起来确实不简单。\n\n\n# 组件是如何创建provides\n\ncurrentInstance 是当前组件示例，接下来看看组件实例\n\n  const instance: ComponentInternalInstance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n    ...,\n    provides: parent ? parent.provides : Object.create(appContext.provides), // 此处很重要\n    ...\n}\nconst appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext\nconst emptyAppContext = {\n    ...,\n    provides: Object.create(null),\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n每当创建一个组件的时候，就会先判断是否有父组件，如果有父组件就去父组件的provides，如果没有父组件，provides就是空对象。\n\n这里就清楚了为什么parentProvides是先从当前组件组件实例中获取。\n\n\n# inject 源码实现\n\nfunction inject(\n  key: InjectionKey<any> | string,\n  defaultValue?: unknown, // 默认值，存在找到key 对应的值的情况\n  treatDefaultAsFactory = false\n) {\n  // fallback to `currentRenderingInstance` so that this can be called in\n  // a functional component\n  const instance = currentInstance || currentRenderingInstance\n  if (instance) {\n    // #2400\n    // to support `app.use` plugins,\n    // fallback to appContext\'s `provides` if the intance is at root\n    const provides =\n      instance.parent == null\n        ? instance.vnode.appContext && instance.vnode.appContext.provides\n        : instance.parent.provides // 取父组件实例的 provides\n\n    if (provides && (key as string | symbol) in provides) {\n      // 查找 key，原型链是自动查看，没有自身没有就会向原型中查找。\n      return provides[key as string]\n    } else if (arguments.length > 1) {\n        // provides中不存在可以 key，就去默认值\n        // 默认值 支持函数\n      return treatDefaultAsFactory && isFunction(defaultValue)\n        ? defaultValue.call(instance.proxy)\n        : defaultValue\n    } else if (__DEV__) {\n      warn(`injection "${String(key)}" not found.`)\n    }\n  } else if (__DEV__) {\n    warn(`inject() can only be used inside setup() or functional components.`)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\ninject 先从父组件里获取provides，然后判断provides中是否存在对应的key，如果存在就返回key对应的属性。没有就去传入的默认值。\n\n\n# 总结\n\nvue3在每个组件创建的时候，都会取父组件的provides，如果没有就定义初始化一个的对象。\n\n当组件provide数据的时候，就会指定父组件的provides为原型，然后添加数据。\n\n当组件inject的时候，就会通过原型链查找数据。\n\n因为每个组件都缓存了父组件的provides，所以不需要通过自己手动遍历查找。\n\n另外，存在查找的时候，寻找不到对应的数据。所以为了处理这种情况。vue提供了默认值参数，inject的时候，如果没有找到就去第一个参数作为默认值。\n\n同时第个参数支持函数写法，第三个参数设置传入true，第二个参数为函数类型。\n\nvue3 的依赖注入巧妙的使用了原型链，通过创建组件的时候，缓存父组件的provides，到达provides向下传递。\n\n取值则是常规操作，找到key就返回属性，没有找到就默认值。',normalizedContent:'本文主要vue3中弄清楚依赖注入是如何实现的。\n\n\n# provide 源码\n\nexport function provide<t>(key: injectionkey<t> | string | number, value: t) {\n    if (!currentinstance) {\n        if (__dev__) {\n            warn(`provide() can only be used inside setup().`)\n        }\n    } else {\n        // currentinstance 是当前组件示例\n        let provides = currentinstance.provides\n        // 父组件的provides： 当前组件实例 没有的话，就去父组件的 provides\n        // 为什么是从当前组件里开始获取 父组件的 provides？\n        const parentprovides =\n            currentinstance.parent && currentinstance.parent.provides\n        if (parentprovides === provides) {\n            // 通过 object.create 指定 parentprovides 为 provides的原型\n            provides = currentinstance.provides = object.create(parentprovides)\n        }\n        // 处理 好 provides 后，进行赋值操作\n        provides[key as string] = value\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n源码虽然简短，但是理解起来确实不简单。\n\n\n# 组件是如何创建provides\n\ncurrentinstance 是当前组件示例，接下来看看组件实例\n\n  const instance: componentinternalinstance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n    ...,\n    provides: parent ? parent.provides : object.create(appcontext.provides), // 此处很重要\n    ...\n}\nconst appcontext = (parent ? parent.appcontext : vnode.appcontext) || emptyappcontext\nconst emptyappcontext = {\n    ...,\n    provides: object.create(null),\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n每当创建一个组件的时候，就会先判断是否有父组件，如果有父组件就去父组件的provides，如果没有父组件，provides就是空对象。\n\n这里就清楚了为什么parentprovides是先从当前组件组件实例中获取。\n\n\n# inject 源码实现\n\nfunction inject(\n  key: injectionkey<any> | string,\n  defaultvalue?: unknown, // 默认值，存在找到key 对应的值的情况\n  treatdefaultasfactory = false\n) {\n  // fallback to `currentrenderinginstance` so that this can be called in\n  // a functional component\n  const instance = currentinstance || currentrenderinginstance\n  if (instance) {\n    // #2400\n    // to support `app.use` plugins,\n    // fallback to appcontext\'s `provides` if the intance is at root\n    const provides =\n      instance.parent == null\n        ? instance.vnode.appcontext && instance.vnode.appcontext.provides\n        : instance.parent.provides // 取父组件实例的 provides\n\n    if (provides && (key as string | symbol) in provides) {\n      // 查找 key，原型链是自动查看，没有自身没有就会向原型中查找。\n      return provides[key as string]\n    } else if (arguments.length > 1) {\n        // provides中不存在可以 key，就去默认值\n        // 默认值 支持函数\n      return treatdefaultasfactory && isfunction(defaultvalue)\n        ? defaultvalue.call(instance.proxy)\n        : defaultvalue\n    } else if (__dev__) {\n      warn(`injection "${string(key)}" not found.`)\n    }\n  } else if (__dev__) {\n    warn(`inject() can only be used inside setup() or functional components.`)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\ninject 先从父组件里获取provides，然后判断provides中是否存在对应的key，如果存在就返回key对应的属性。没有就去传入的默认值。\n\n\n# 总结\n\nvue3在每个组件创建的时候，都会取父组件的provides，如果没有就定义初始化一个的对象。\n\n当组件provide数据的时候，就会指定父组件的provides为原型，然后添加数据。\n\n当组件inject的时候，就会通过原型链查找数据。\n\n因为每个组件都缓存了父组件的provides，所以不需要通过自己手动遍历查找。\n\n另外，存在查找的时候，寻找不到对应的数据。所以为了处理这种情况。vue提供了默认值参数，inject的时候，如果没有找到就去第一个参数作为默认值。\n\n同时第个参数支持函数写法，第三个参数设置传入true，第二个参数为函数类型。\n\nvue3 的依赖注入巧妙的使用了原型链，通过创建组件的时候，缓存父组件的provides，到达provides向下传递。\n\n取值则是常规操作，找到key就返回属性，没有找到就默认值。',charsets:{cjk:!0},lastUpdated:"2022/04/18, 10:24:30",lastUpdatedTimestamp:165024867e4},{title:"vue3进阶笔记之vuex",frontmatter:{title:"vue3进阶笔记之vuex",date:"2022-04-18T10:35:03.000Z",permalink:"/pages/18eeef/",categories:["前端","vue"],tags:["Javascript","vue"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/50.vue/18.vue3%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0%E4%B9%8Bvuex.html",relativePath:"01.前端/50.vue/18.vue3进阶笔记之vuex.md",key:"v-68163d88",path:"/pages/18eeef/",headers:[{level:2,title:"vuex 的用途",slug:"vuex-的用途",normalizedTitle:"vuex 的用途",charIndex:22},{level:3,title:"vuex 解决了什么问题。",slug:"vuex-解决了什么问题。",normalizedTitle:"vuex 解决了什么问题。",charIndex:35},{level:3,title:"vuex的雏形",slug:"vuex的雏形",normalizedTitle:"vuex的雏形",charIndex:250},{level:2,title:"实现一个min-vuex",slug:"实现一个min-vuex",normalizedTitle:"实现一个min-vuex",charIndex:548},{level:3,title:"数据操作",slug:"数据操作",normalizedTitle:"数据操作",charIndex:565},{level:3,title:"插件安装",slug:"插件安装",normalizedTitle:"插件安装",charIndex:1594},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:456},{level:3,title:"完整代码",slug:"完整代码",normalizedTitle:"完整代码",charIndex:2388},{level:2,title:"vuex的思考",slug:"vuex的思考",normalizedTitle:"vuex的思考",charIndex:3369}],headersStr:"vuex 的用途 vuex 解决了什么问题。 vuex的雏形 实现一个min-vuex 数据操作 插件安装 使用 完整代码 vuex的思考",content:'理解vuex的作用，以及实现原理。\n\n\n# vuex 的用途\n\n\n# vuex 解决了什么问题。\n\n现在不管是vue、angular或者react，都是采用组件化开发，单项数据流。\n\n这里就会带来一个新的问题，组件之间如何处理共享的数据。如果只是父子组件，可以通过prop和emit来来传递，但是深层次组件采用层层传递就会特别麻烦。\n\nvue和react处理方案都是引入了状态管理，angular中有service，它本身就解决了数据共享问题。\n\nvuex是vue中的状态管理一种具体实现。\n\n\n# vuex的雏形\n\nvuex是处理组件之间的共享数据一种实现方案，如果让你来处理组件间共享数据问题，那么你会如何实现？\n\n解决这个问题常见的思路就是：专门定义一个全局变量，任何组件需要数据的时候都从这个变量中获取。\n\n从设计模式角度来说，引入一个单例来解决数据共享。\n\nwindow._store = {}\n\n\n1\n\n\n但这样就会产生一个问题，window._store 并不是响应式的，如果在 Vue 项目中直接使用，那么就无法自动更新页面。\n\n所以我们需要用 ref 和 reactive 去把数据包裹成响应式数据，并且提供统一的操作方法，这其实就是数据管理框架 Vuex 的雏形了。\n\n\n# 实现一个min-vuex\n\n\n# 数据操作\n\n首先 vuex 是个单例，我们用一个class来实现。\n\nclass Store {}\n\n\n1\n\n\n使用 _state 存储数据，使用 mutations、actions 来存储数据修改的函数\n\nimport { reactive } from "vue";\nclass Store {\n    constructor(option) {\n        this._state = reactive({\n            data: option.state(),\n        }); // 转变成响应式数据\n        this._mutations = option.mutations || {};\n        this._actions = option.actions || {}\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n完善数据存储操作\n\nclass Store {\n  constructor(option) {\n    this._state = reactive({\n      data: option.state(),\n    });\n    this._mutations = option.mutations || {};\n    this._actions = option.actions || {}\n  }\n  get state() { // 读取 state 的时候直接获取响应式数据 _state.data\n    return this._state.data;\n  }\n  commit = (type, payload) => { // 更改数据方法，执行 _mutations 里存储的方法\n    const entry = this._mutations[type];\n    entry && entry(this.state, payload);\n  };\n  dispatch = (type, payload) => { // 与 _mutations 逻辑一样\n    const action = this._actions[type]\n    action && action(this, payload)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 插件安装\n\n我们通过依赖注入：provide、inject 来处理数据共享。\n\n使用的时候，inject store\n\nimport { inject } from "vue";\n\nconst STORE_KEY = "__store__";\n\nfunction useStore() { // 使用的时候，注入store\n  return inject(STORE_KEY);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n安装插件的时候，provide store\n\nclass Store {\n    \n  // main.js 入口处 app.use(store)的时候，会执行这个函数\n  install(app) {\n    app.provide(STORE_KEY, this);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 使用\n\n暴露一个 createStore 去创建 Store 的实例\n\n// 创建 store 实例\nfunction createStore(option) {\n  return new Store(option);\n}\n\n\n1\n2\n3\n4\n\n\n创建实例\n\n// import { createStore } from \'vuex\'\nimport { createStore } from \'./gvuex\'\nconst store = createStore({\n    state() {\n        return {}\n    },\n    mutations: {},\n    actions: {},\n})\nexport default store\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n最终我们使用 store 的方式，在项目入口文件 src/main.js 中使用 app.use(store) 注册\n\n\n# 完整代码\n\nimport { inject, reactive } from "vue";\n\nconst STORE_KEY = "__store__";\n\nfunction useStore() {\n  return inject(STORE_KEY);\n}\n\n// 创建 store 实例\nfunction createStore(option) {\n  return new Store(option);\n}\n\nclass Store {\n  constructor(option) {\n    this._state = reactive({\n      data: option.state(),\n    });\n    this._mutations = option.mutations || {};\n    this._actions = option.actions || {}\n  }\n  get state() {\n    return this._state.data;\n  }\n  commit = (type, payload) => {\n    const entry = this._mutations[type];\n    entry && entry(this.state, payload);\n  };\n  dispatch = (type, payload) => {\n    console.log(\'_actions\', this._actions);\n    const action = this._actions[type]\n    action && action(this, payload)\n  }\n  // main.js 入口处 app.use(store)的时候，会执行这个函数\n  install(app) {\n    app.provide(STORE_KEY, this);\n  }\n}\n\nexport { createStore, useStore };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# vuex的思考\n\nvuex的用途：集中式管理组件数据，包括存储、修改操作。vuex类似与管家，有一定的约束力。 举个生活中例子，公司越大，规则制度越多，这是为什么呢？因为人越多，需要制度来约束，这样方便管理，提高公司运作效率。而小公司不需要，小公司制度多，反而会影响公司的运作。\n\n什么时候该使用vuex呢？ 如果是数据只是组件内部使用，就使用ref。 如果数据需要跨组件，跨页面共享的时候，就使用vuex',normalizedContent:'理解vuex的作用，以及实现原理。\n\n\n# vuex 的用途\n\n\n# vuex 解决了什么问题。\n\n现在不管是vue、angular或者react，都是采用组件化开发，单项数据流。\n\n这里就会带来一个新的问题，组件之间如何处理共享的数据。如果只是父子组件，可以通过prop和emit来来传递，但是深层次组件采用层层传递就会特别麻烦。\n\nvue和react处理方案都是引入了状态管理，angular中有service，它本身就解决了数据共享问题。\n\nvuex是vue中的状态管理一种具体实现。\n\n\n# vuex的雏形\n\nvuex是处理组件之间的共享数据一种实现方案，如果让你来处理组件间共享数据问题，那么你会如何实现？\n\n解决这个问题常见的思路就是：专门定义一个全局变量，任何组件需要数据的时候都从这个变量中获取。\n\n从设计模式角度来说，引入一个单例来解决数据共享。\n\nwindow._store = {}\n\n\n1\n\n\n但这样就会产生一个问题，window._store 并不是响应式的，如果在 vue 项目中直接使用，那么就无法自动更新页面。\n\n所以我们需要用 ref 和 reactive 去把数据包裹成响应式数据，并且提供统一的操作方法，这其实就是数据管理框架 vuex 的雏形了。\n\n\n# 实现一个min-vuex\n\n\n# 数据操作\n\n首先 vuex 是个单例，我们用一个class来实现。\n\nclass store {}\n\n\n1\n\n\n使用 _state 存储数据，使用 mutations、actions 来存储数据修改的函数\n\nimport { reactive } from "vue";\nclass store {\n    constructor(option) {\n        this._state = reactive({\n            data: option.state(),\n        }); // 转变成响应式数据\n        this._mutations = option.mutations || {};\n        this._actions = option.actions || {}\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n完善数据存储操作\n\nclass store {\n  constructor(option) {\n    this._state = reactive({\n      data: option.state(),\n    });\n    this._mutations = option.mutations || {};\n    this._actions = option.actions || {}\n  }\n  get state() { // 读取 state 的时候直接获取响应式数据 _state.data\n    return this._state.data;\n  }\n  commit = (type, payload) => { // 更改数据方法，执行 _mutations 里存储的方法\n    const entry = this._mutations[type];\n    entry && entry(this.state, payload);\n  };\n  dispatch = (type, payload) => { // 与 _mutations 逻辑一样\n    const action = this._actions[type]\n    action && action(this, payload)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 插件安装\n\n我们通过依赖注入：provide、inject 来处理数据共享。\n\n使用的时候，inject store\n\nimport { inject } from "vue";\n\nconst store_key = "__store__";\n\nfunction usestore() { // 使用的时候，注入store\n  return inject(store_key);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n安装插件的时候，provide store\n\nclass store {\n    \n  // main.js 入口处 app.use(store)的时候，会执行这个函数\n  install(app) {\n    app.provide(store_key, this);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 使用\n\n暴露一个 createstore 去创建 store 的实例\n\n// 创建 store 实例\nfunction createstore(option) {\n  return new store(option);\n}\n\n\n1\n2\n3\n4\n\n\n创建实例\n\n// import { createstore } from \'vuex\'\nimport { createstore } from \'./gvuex\'\nconst store = createstore({\n    state() {\n        return {}\n    },\n    mutations: {},\n    actions: {},\n})\nexport default store\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n最终我们使用 store 的方式，在项目入口文件 src/main.js 中使用 app.use(store) 注册\n\n\n# 完整代码\n\nimport { inject, reactive } from "vue";\n\nconst store_key = "__store__";\n\nfunction usestore() {\n  return inject(store_key);\n}\n\n// 创建 store 实例\nfunction createstore(option) {\n  return new store(option);\n}\n\nclass store {\n  constructor(option) {\n    this._state = reactive({\n      data: option.state(),\n    });\n    this._mutations = option.mutations || {};\n    this._actions = option.actions || {}\n  }\n  get state() {\n    return this._state.data;\n  }\n  commit = (type, payload) => {\n    const entry = this._mutations[type];\n    entry && entry(this.state, payload);\n  };\n  dispatch = (type, payload) => {\n    console.log(\'_actions\', this._actions);\n    const action = this._actions[type]\n    action && action(this, payload)\n  }\n  // main.js 入口处 app.use(store)的时候，会执行这个函数\n  install(app) {\n    app.provide(store_key, this);\n  }\n}\n\nexport { createstore, usestore };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# vuex的思考\n\nvuex的用途：集中式管理组件数据，包括存储、修改操作。vuex类似与管家，有一定的约束力。 举个生活中例子，公司越大，规则制度越多，这是为什么呢？因为人越多，需要制度来约束，这样方便管理，提高公司运作效率。而小公司不需要，小公司制度多，反而会影响公司的运作。\n\n什么时候该使用vuex呢？ 如果是数据只是组件内部使用，就使用ref。 如果数据需要跨组件，跨页面共享的时候，就使用vuex',charsets:{cjk:!0},lastUpdated:"2022/04/19, 11:18:08",lastUpdatedTimestamp:1650338288e3},{title:"Vue 生命周期",frontmatter:{title:"Vue 生命周期",date:"2022-03-15T17:28:18.000Z",permalink:"/pages/a4bbd1/",categories:["前端","vue"],tags:["Javascript","vue"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/50.vue/2.Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"01.前端/50.vue/2.Vue 生命周期.md",key:"v-591adf23",path:"/pages/a4bbd1/",headers:[{level:2,title:"完整的生命周期过程",slug:"完整的生命周期过程",normalizedTitle:"完整的生命周期过程",charIndex:83},{level:3,title:"beforeCreate 之前",slug:"beforecreate-之前",normalizedTitle:"beforecreate 之前",charIndex:281},{level:3,title:"beforeCreate到created",slug:"beforecreate到created",normalizedTitle:"beforecreate到created",charIndex:913},{level:3,title:"created到beforeMount",slug:"created到beforemount",normalizedTitle:"created到beforemount",charIndex:1187},{level:3,title:"beforeMount到mounted",slug:"beforemount到mounted",normalizedTitle:"beforemount到mounted",charIndex:1513},{level:3,title:"beforeUpdate",slug:"beforeupdate",normalizedTitle:"beforeupdate",charIndex:148},{level:3,title:"beforeUpdate到updated",slug:"beforeupdate到updated",normalizedTitle:"beforeupdate到updated",charIndex:1970},{level:3,title:"卸载",slug:"卸载",normalizedTitle:"卸载",charIndex:2181},{level:2,title:"实现原理",slug:"实现原理",normalizedTitle:"实现原理",charIndex:73},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2316}],headersStr:"完整的生命周期过程 beforeCreate 之前 beforeCreate到created created到beforeMount beforeMount到mounted beforeUpdate beforeUpdate到updated 卸载 实现原理 参考资料",content:"用文字阐述Vue完整的生命周期，解决面试的时候表示不清的问题。\n\n本文主要有两部分，一部分是各个生命周期分别做了什么事情，另一部分是实现生命周期的实现原理。\n\n\n# 完整的生命周期过程\n\nvue完整的生命周期钩子：beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed、activated、deactivated、errorCaptured、serverPrefetch。\n\n主要四大阶段：创建、挂载、更新、销毁。另外还有一个组件缓存。\n\n\n# beforeCreate 之前\n\nbeforeCreate钩子调用之前，主要做了四件事情，分别是：\n\n * 合并组件的options\n   * 子组件\n     * 指定组件$options原型\n     * 把组件依赖于父组件的props、listeners也挂载到options上，方便子组件调用\n   * 根组件\n     * 创建根组件的options\n\nconst options = {\n    components: {\n        KeepAlive,\n        Transition,\n        TransitionGroup\n    },\n    directives: {\n        model,\n        show\n    },\n    filters: {},\n    _base: Vue\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n * 初始化组件实例关系属性（initLifecycle），比如： $parent、$children、$root、$refs。\n\n * 初始化自定义事件（initEvents），初始化的是父组件在模板中使用v-on或@注册的监听子组件内触发的事件。注意：浏览器原生事件是由父组件处理，而自定义事情交给子组件处理。\n\n * 初始化渲染：主要是获取父组件的vnode节点和执行环境、解析插槽，以及新增组件的createElement方法。\n\n\n# beforeCreate到created\n\nbeforeCreate到created这段时间做了三件事情，分别是：\n\n * 初始化组件的 inject 配置项（initInjections）,先进行键值配对，然后添加到实例上。注意：inject绑定的数据不是响应式的，如果需要响应式的，则需要传入一个可监听的对象。\n\n * initState：数据响应式的重点，处理 props、methods、data、computed、watch\n\n * 解析组件配置项上的 provide 对象（initProvide），在initState之后。\n\n\n# created到beforeMount\n\ncreated到beforeMount这段时间主要是处理模板编译\n\n首先判断是否需要编译，以及应该使用哪个一个模板。\n\n如果vm.$options.el有数据，就会跳过编译。反之，就会进入模板编译。\n\n模板编译的时候优先判断 render 是否存在，如果存在，就直接使用 render 函数了\n\n如果没有，再判断 template 和 el，如果有 template，就不会管 el 了\n\n所以优先级顺序是：render > template > el\n\n因为不管是 el 挂载的，还是 template 最后都会被编译成 render 函数，而如果已经有了 render 函数了，就跳过前面的编译了\n\n\n# beforeMount到mounted\n\nbeforeMount 到 mounted 这段时间做了两件事情，分别是：\n\n * 把 vnode 渲染成真是 DOM ，并挂载。定义 updateComponent 函数，对 render 返回的虚拟 DOM 进行 patch (也就是Diff)到真实 DOM。\n\n * 对模板中数据或状态做响应式处理，为当前组件实例设置一个观察者（Watcher），监控 updateComponent 函数得到的数据。\n\n\n# beforeUpdate\n\n在执行watcher.run方法之前，会执行watcher.before方法，从而执行beforeUpdate钩子函数。\n\n注意：\n\n * 只有视图依赖中的data发放变化，才会触发这个方法，因为没有绑定到视图的data不会被收集到依赖中。\n\n * 此时虚拟DOM和真实DOM都还未被更新\n\n因为虚拟DOM还没未更新，所以可以移除手动添加的事件监听器（添加时间：beforeCreate 之前，initEvents）\n\n\n# beforeUpdate到updated\n\n这段时间主要了做了一件事件，那就是开启任务队列。\n\n每一个组件实例都有一个对应的watcher实例，watcher会在组件渲染的过程中把接触过的数据属性记录为依赖。之后，当依赖的值发生，触发setter方法，会通知watcher，此时Vue就会开启一个任务队列，并缓冲同一事情循环中发生变化的所有变更数据。如果同一个watcher被多次触发，只会被推入任务队列中一次。\n\n\n# 卸载\n\nbeforeDestroy到destoryed：从父组件中删除当前组件，移除当前组件内的所有观察者(依赖追踪)，删除数据对象的引用，删除虚拟 DOM\n\ndestoryed调用之后，关闭所有事件监听，删除当前根组件的引用，删除父级的引用\n\n\n# 实现原理\n\n\n# 参考资料\n\n * Vue初始化中的选项合并之initInternalComponent详解\n * 初始化阶段(initEvents)\n * 初始化阶段(initInjections)",normalizedContent:"用文字阐述vue完整的生命周期，解决面试的时候表示不清的问题。\n\n本文主要有两部分，一部分是各个生命周期分别做了什么事情，另一部分是实现生命周期的实现原理。\n\n\n# 完整的生命周期过程\n\nvue完整的生命周期钩子：beforecreate、created、beforemount、mounted、beforeupdate、updated、beforedestroy、destroyed、activated、deactivated、errorcaptured、serverprefetch。\n\n主要四大阶段：创建、挂载、更新、销毁。另外还有一个组件缓存。\n\n\n# beforecreate 之前\n\nbeforecreate钩子调用之前，主要做了四件事情，分别是：\n\n * 合并组件的options\n   * 子组件\n     * 指定组件$options原型\n     * 把组件依赖于父组件的props、listeners也挂载到options上，方便子组件调用\n   * 根组件\n     * 创建根组件的options\n\nconst options = {\n    components: {\n        keepalive,\n        transition,\n        transitiongroup\n    },\n    directives: {\n        model,\n        show\n    },\n    filters: {},\n    _base: vue\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n * 初始化组件实例关系属性（initlifecycle），比如： $parent、$children、$root、$refs。\n\n * 初始化自定义事件（initevents），初始化的是父组件在模板中使用v-on或@注册的监听子组件内触发的事件。注意：浏览器原生事件是由父组件处理，而自定义事情交给子组件处理。\n\n * 初始化渲染：主要是获取父组件的vnode节点和执行环境、解析插槽，以及新增组件的createelement方法。\n\n\n# beforecreate到created\n\nbeforecreate到created这段时间做了三件事情，分别是：\n\n * 初始化组件的 inject 配置项（initinjections）,先进行键值配对，然后添加到实例上。注意：inject绑定的数据不是响应式的，如果需要响应式的，则需要传入一个可监听的对象。\n\n * initstate：数据响应式的重点，处理 props、methods、data、computed、watch\n\n * 解析组件配置项上的 provide 对象（initprovide），在initstate之后。\n\n\n# created到beforemount\n\ncreated到beforemount这段时间主要是处理模板编译\n\n首先判断是否需要编译，以及应该使用哪个一个模板。\n\n如果vm.$options.el有数据，就会跳过编译。反之，就会进入模板编译。\n\n模板编译的时候优先判断 render 是否存在，如果存在，就直接使用 render 函数了\n\n如果没有，再判断 template 和 el，如果有 template，就不会管 el 了\n\n所以优先级顺序是：render > template > el\n\n因为不管是 el 挂载的，还是 template 最后都会被编译成 render 函数，而如果已经有了 render 函数了，就跳过前面的编译了\n\n\n# beforemount到mounted\n\nbeforemount 到 mounted 这段时间做了两件事情，分别是：\n\n * 把 vnode 渲染成真是 dom ，并挂载。定义 updatecomponent 函数，对 render 返回的虚拟 dom 进行 patch (也就是diff)到真实 dom。\n\n * 对模板中数据或状态做响应式处理，为当前组件实例设置一个观察者（watcher），监控 updatecomponent 函数得到的数据。\n\n\n# beforeupdate\n\n在执行watcher.run方法之前，会执行watcher.before方法，从而执行beforeupdate钩子函数。\n\n注意：\n\n * 只有视图依赖中的data发放变化，才会触发这个方法，因为没有绑定到视图的data不会被收集到依赖中。\n\n * 此时虚拟dom和真实dom都还未被更新\n\n因为虚拟dom还没未更新，所以可以移除手动添加的事件监听器（添加时间：beforecreate 之前，initevents）\n\n\n# beforeupdate到updated\n\n这段时间主要了做了一件事件，那就是开启任务队列。\n\n每一个组件实例都有一个对应的watcher实例，watcher会在组件渲染的过程中把接触过的数据属性记录为依赖。之后，当依赖的值发生，触发setter方法，会通知watcher，此时vue就会开启一个任务队列，并缓冲同一事情循环中发生变化的所有变更数据。如果同一个watcher被多次触发，只会被推入任务队列中一次。\n\n\n# 卸载\n\nbeforedestroy到destoryed：从父组件中删除当前组件，移除当前组件内的所有观察者(依赖追踪)，删除数据对象的引用，删除虚拟 dom\n\ndestoryed调用之后，关闭所有事件监听，删除当前根组件的引用，删除父级的引用\n\n\n# 实现原理\n\n\n# 参考资料\n\n * vue初始化中的选项合并之initinternalcomponent详解\n * 初始化阶段(initevents)\n * 初始化阶段(initinjections)",charsets:{cjk:!0},lastUpdated:"2022/03/18, 17:06:03",lastUpdatedTimestamp:1647594363e3},{title:"vue3进阶笔记之pinia",frontmatter:{title:"vue3进阶笔记之pinia",date:"2022-04-20T16:12:25.000Z",permalink:"/pages/a72a65/",categories:["前端","vue"],tags:["Javascript","vue"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/50.vue/20.vue3%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0%E4%B9%8Bpinia.html",relativePath:"01.前端/50.vue/20.vue3进阶笔记之pinia.md",key:"v-0feb9fa6",path:"/pages/a72a65/",headers:[{level:2,title:"pinia 安装到vue中",slug:"pinia-安装到vue中",normalizedTitle:"pinia 安装到vue中",charIndex:146},{level:2,title:"pinia 插件机制",slug:"pinia-插件机制",normalizedTitle:"pinia 插件机制",charIndex:1048}],headersStr:"pinia 安装到vue中 pinia 插件机制",content:"Pinia 是 vuex5，如果你不了了解 vuex 原理，先阅读这篇min-vuex.\n\n本文主要内容是 pinia 源码阅读笔记, 但并不是逐行阅读。本文的目的是围绕以下几个问题：\n\n * pinia 作为插件是如何安装到vue中？\n * pinia 本身插件机制是如何实现的？\n\n\n# pinia 安装到vue中\n\n安装插件的时候 provide 到 vue中。\n\nexport function createPinia(): Pinia {\n  const pinia: Pinia = markRaw({\n    install(app: App) { // pinia 作为插件 安裝方法\n      if (!isVue2) {\n        pinia._a = app\n        app.provide(piniaSymbol, pinia) // 插件安裝的時候 provide pinia\n        app.config.globalProperties.$pinia = pinia // 全局的 $pinia 变量配置 Pinia 对象\n      }\n    },\n  })\n  return pinia\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n使用的时候 inject 到组件实例中。\n\n  function useStore(pinia?: Pinia | null, hot?: StoreGeneric): StoreGeneric {\n    const currentInstance = getCurrentInstance() // 当前组件实例\n    // 如果 useStrore 中没有 Pinia 的话，就使用 inject 去获取 Pinia 实例。\n    // 这里 inject 的数据就是 createPinia 函数中 install 方法提供的。\n    pinia =\n        (__TEST__ && activePinia && activePinia._testing ? null : pinia) ||\n        (currentInstance && inject(piniaSymbol))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里实现的逻辑与min-vue插件类似的，也是通过依赖注入来安装插件。只不过这里加入了优化，使用的使用惰性引入。\n\n\n# pinia 插件机制\n\nexport function createPinia(): Pinia {\n  let _p: Pinia['_p'] = []\n  // 存储插件内容，在 install，之前使用 use 添加插件\n  let toBeInstalled: PiniaPlugin[] = []\n\n  const pinia: Pinia = markRaw({\n    install(app: App) { // pinia 作为插件 安裝方法\n      if (!isVue2) {\n        pinia._a = app\n        app.provide(piniaSymbol, pinia) // 插件安裝的時候 provide pinia\n        app.config.globalProperties.$pinia = pinia // 全局的 $pinia 变量配置 Pinia 对象\n \n        // 插件机制：通过 use 方法往 toBeInstalled 数组里添加插件，然后在install 的时候，遍历 toBeInstalled，存放到 Pinia 实例的 _p 属性上\n        toBeInstalled.forEach((plugin) => _p.push(plugin))\n        toBeInstalled = []\n      }\n    },\n    use(plugin) {\n      if (!this._a && !isVue2) {\n        toBeInstalled.push(plugin) // 添加插件\n      } else {\n        _p.push(plugin)\n      }\n      return this\n    },\n    _p,\n  })\n  return pinia\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n通过 use 方法，把插件保存到 toBeInstalled 数组中，然后在 install 房里，把 toBeInstalled 数据赋值到 pinia 的_p 属性上。",normalizedContent:"pinia 是 vuex5，如果你不了了解 vuex 原理，先阅读这篇min-vuex.\n\n本文主要内容是 pinia 源码阅读笔记, 但并不是逐行阅读。本文的目的是围绕以下几个问题：\n\n * pinia 作为插件是如何安装到vue中？\n * pinia 本身插件机制是如何实现的？\n\n\n# pinia 安装到vue中\n\n安装插件的时候 provide 到 vue中。\n\nexport function createpinia(): pinia {\n  const pinia: pinia = markraw({\n    install(app: app) { // pinia 作为插件 安裝方法\n      if (!isvue2) {\n        pinia._a = app\n        app.provide(piniasymbol, pinia) // 插件安裝的時候 provide pinia\n        app.config.globalproperties.$pinia = pinia // 全局的 $pinia 变量配置 pinia 对象\n      }\n    },\n  })\n  return pinia\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n使用的时候 inject 到组件实例中。\n\n  function usestore(pinia?: pinia | null, hot?: storegeneric): storegeneric {\n    const currentinstance = getcurrentinstance() // 当前组件实例\n    // 如果 usestrore 中没有 pinia 的话，就使用 inject 去获取 pinia 实例。\n    // 这里 inject 的数据就是 createpinia 函数中 install 方法提供的。\n    pinia =\n        (__test__ && activepinia && activepinia._testing ? null : pinia) ||\n        (currentinstance && inject(piniasymbol))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里实现的逻辑与min-vue插件类似的，也是通过依赖注入来安装插件。只不过这里加入了优化，使用的使用惰性引入。\n\n\n# pinia 插件机制\n\nexport function createpinia(): pinia {\n  let _p: pinia['_p'] = []\n  // 存储插件内容，在 install，之前使用 use 添加插件\n  let tobeinstalled: piniaplugin[] = []\n\n  const pinia: pinia = markraw({\n    install(app: app) { // pinia 作为插件 安裝方法\n      if (!isvue2) {\n        pinia._a = app\n        app.provide(piniasymbol, pinia) // 插件安裝的時候 provide pinia\n        app.config.globalproperties.$pinia = pinia // 全局的 $pinia 变量配置 pinia 对象\n \n        // 插件机制：通过 use 方法往 tobeinstalled 数组里添加插件，然后在install 的时候，遍历 tobeinstalled，存放到 pinia 实例的 _p 属性上\n        tobeinstalled.foreach((plugin) => _p.push(plugin))\n        tobeinstalled = []\n      }\n    },\n    use(plugin) {\n      if (!this._a && !isvue2) {\n        tobeinstalled.push(plugin) // 添加插件\n      } else {\n        _p.push(plugin)\n      }\n      return this\n    },\n    _p,\n  })\n  return pinia\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n通过 use 方法，把插件保存到 tobeinstalled 数组中，然后在 install 房里，把 tobeinstalled 数据赋值到 pinia 的_p 属性上。",charsets:{cjk:!0},lastUpdated:"2022/06/20, 17:17:46",lastUpdatedTimestamp:1655716666e3},{title:"响应式原理",frontmatter:{title:"响应式原理",date:"2022-03-08T03:11:45.000Z",permalink:"/pages/c51d69/",categories:["前端","vue"],tags:["Javascript","vue"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/50.vue/4.%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html",relativePath:"01.前端/50.vue/4.响应式原理.md",key:"v-65efea34",path:"/pages/c51d69/",headers:[{level:2,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:43},{level:2,title:"vue2 实现原理",slug:"vue2-实现原理",normalizedTitle:"vue2 实现原理",charIndex:158},{level:3,title:"转换成get、set",slug:"转换成get、set",normalizedTitle:"转换成get、set",charIndex:172},{level:3,title:"搜集依赖",slug:"搜集依赖",normalizedTitle:"搜集依赖",charIndex:290},{level:3,title:"更新依赖",slug:"更新依赖",normalizedTitle:"更新依赖",charIndex:412},{level:2,title:"vue2 如何处理数组响应式",slug:"vue2-如何处理数组响应式",normalizedTitle:"vue2 如何处理数组响应式",charIndex:484},{level:2,title:"vue3 实现原理",slug:"vue3-实现原理",normalizedTitle:"vue3 实现原理",charIndex:782},{level:2,title:"vue3和vue2响应式原理对比",slug:"vue3和vue2响应式原理对比",normalizedTitle:"vue3和vue2响应式原理对比",charIndex:1062},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1374}],headersStr:"定义 vue2 实现原理 转换成get、set 搜集依赖 更新依赖 vue2 如何处理数组响应式 vue3 实现原理 vue3和vue2响应式原理对比 参考资料",content:"简述Vue的响应式原理，用自己的话表述出来，解决面试的时候表达不清楚的问题。\n\n\n# 定义\n\n响应式是指组件中的data数据发生变化后，视图也会随着发生改变。\n\nvue2 的实现方式是：Object.defineProperty实现数据劫持 + 观察者模式 ，而Vue3 主要通过Proxy这个API实现。\n\n\n# vue2 实现原理\n\n\n# 转换成get、set\n\n在vue initState的时候，通过Object.defineProperty这个API，把组件里的data数据转换成getter、setter，同时也会创建Dep来收集该data的Watcher。\n\n\n# 搜集依赖\n\n在组件渲染的时候，会创建一个对应的Watcher，并将Dep.target标识为当前的Watcher。此时，如果视图使用了data中的数据，就会Data触发get方法，然后调用Dep.addSub将Watcher搜集起来。\n\n\n# 更新依赖\n\n数据更新的时候，就会触发data的set方法，然后调用Dep.notify通知用到该data的Watcher去更新DOM。\n\n\n# vue2 如何处理数组响应式\n\nObject.defineProperty不能监听数组长度的变化。\n\n因为性能问题，未采用监听数组每个下标的方法，而是重写会影响数组方法。\n\nvue在ininState的时候，会在初始化Observer类的时候会创建一个Dep来收集依赖，并且为每个响应式数据定义一个__ob__的属性。\n\n在遇到处理数组转换成响应式的时候，vue首先通过Object.defineProperty拦截数组原型的push、pop、shift、unshift、splice、slice、reverse这7个方法，然后在这些方法内部调用__ob__.dep.notify方法。\n\n\n# vue3 实现原理\n\nvue3在setupComponent的时候，会调用composition-api，处理options得到响应式对象，并且会创建一个负责渲染的effect。\n\n在组件渲染的时候，会触发get，调用track方法，然后通过Proxy对象和key形成对应的deps，将负责渲染的effect存入deps中。\n\n数据更新的时候，会触发set，调用trigger方法，然后通过Proxy对象和key找到对应的deps，然后把deps分类成功computedRunners和effect。需要调度的，则会放入调度中；不需要的就会依次执行。\n\n\n# vue3和vue2响应式原理对比\n\n * vue2采用 Object.defineProperty 来劫持整个对象，vue3采用的是proxy来劫持对整个，这两个api相同之处就是只能劫持对象本身，不能劫持子对象的变化。对于子对象，vue2是通过深度遍历所有属性，而vue3是在对象属性被访问的时候，才会递归执行下一步的reactive。vue3实现了延迟定义子对象响应式的实现，这样做可以较大的提高性能。\n\n * vue3解决了vue2中对属性的添加、删除动作不能监测，对数组基于下标的修改、数组length修改不能监测的问题。\n\n * vue3实现了对Map、Set、WeakMap 和 WeakSet 的支持\n\n\n# 参考资料\n\n * 图解 Vue 响应式原理\n * Vue原理解析（七）：全面深入理解响应式原理(下)-数组进阶篇\n * vue3.0 响应式原理(超详细)",normalizedContent:"简述vue的响应式原理，用自己的话表述出来，解决面试的时候表达不清楚的问题。\n\n\n# 定义\n\n响应式是指组件中的data数据发生变化后，视图也会随着发生改变。\n\nvue2 的实现方式是：object.defineproperty实现数据劫持 + 观察者模式 ，而vue3 主要通过proxy这个api实现。\n\n\n# vue2 实现原理\n\n\n# 转换成get、set\n\n在vue initstate的时候，通过object.defineproperty这个api，把组件里的data数据转换成getter、setter，同时也会创建dep来收集该data的watcher。\n\n\n# 搜集依赖\n\n在组件渲染的时候，会创建一个对应的watcher，并将dep.target标识为当前的watcher。此时，如果视图使用了data中的数据，就会data触发get方法，然后调用dep.addsub将watcher搜集起来。\n\n\n# 更新依赖\n\n数据更新的时候，就会触发data的set方法，然后调用dep.notify通知用到该data的watcher去更新dom。\n\n\n# vue2 如何处理数组响应式\n\nobject.defineproperty不能监听数组长度的变化。\n\n因为性能问题，未采用监听数组每个下标的方法，而是重写会影响数组方法。\n\nvue在ininstate的时候，会在初始化observer类的时候会创建一个dep来收集依赖，并且为每个响应式数据定义一个__ob__的属性。\n\n在遇到处理数组转换成响应式的时候，vue首先通过object.defineproperty拦截数组原型的push、pop、shift、unshift、splice、slice、reverse这7个方法，然后在这些方法内部调用__ob__.dep.notify方法。\n\n\n# vue3 实现原理\n\nvue3在setupcomponent的时候，会调用composition-api，处理options得到响应式对象，并且会创建一个负责渲染的effect。\n\n在组件渲染的时候，会触发get，调用track方法，然后通过proxy对象和key形成对应的deps，将负责渲染的effect存入deps中。\n\n数据更新的时候，会触发set，调用trigger方法，然后通过proxy对象和key找到对应的deps，然后把deps分类成功computedrunners和effect。需要调度的，则会放入调度中；不需要的就会依次执行。\n\n\n# vue3和vue2响应式原理对比\n\n * vue2采用 object.defineproperty 来劫持整个对象，vue3采用的是proxy来劫持对整个，这两个api相同之处就是只能劫持对象本身，不能劫持子对象的变化。对于子对象，vue2是通过深度遍历所有属性，而vue3是在对象属性被访问的时候，才会递归执行下一步的reactive。vue3实现了延迟定义子对象响应式的实现，这样做可以较大的提高性能。\n\n * vue3解决了vue2中对属性的添加、删除动作不能监测，对数组基于下标的修改、数组length修改不能监测的问题。\n\n * vue3实现了对map、set、weakmap 和 weakset 的支持\n\n\n# 参考资料\n\n * 图解 vue 响应式原理\n * vue原理解析（七）：全面深入理解响应式原理(下)-数组进阶篇\n * vue3.0 响应式原理(超详细)",charsets:{cjk:!0},lastUpdated:"2022/03/18, 21:31:21",lastUpdatedTimestamp:1647610281e3},{title:"Mixin混入原理",frontmatter:{title:"Mixin混入原理",date:"2022-03-08T11:34:20.000Z",permalink:"/pages/329c47/",categories:["前端","vue"],tags:["Javascript","vue"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/50.vue/6.Mixin%E6%B7%B7%E5%85%A5%E5%8E%9F%E7%90%86.html",relativePath:"01.前端/50.vue/6.Mixin混入原理.md",key:"v-1e2c6bdc",path:"/pages/329c47/",headersStr:null,content:"弄清楚Mixin是什么，",normalizedContent:"弄清楚mixin是什么，",charsets:{cjk:!0},lastUpdated:"2022/03/18, 17:06:03",lastUpdatedTimestamp:1647594363e3},{title:"模板编译原理",frontmatter:{title:"模板编译原理",date:"2022-03-20T20:04:14.000Z",permalink:"/pages/c009df/",categories:["前端","vue"],tags:["前端","vue"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/50.vue/8.%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.html",relativePath:"01.前端/50.vue/8.模板编译原理.md",key:"v-c16372ea",path:"/pages/c009df/",headers:[{level:2,title:"确定render函数",slug:"确定render函数",normalizedTitle:"确定render函数",charIndex:81}],headersStr:"确定render函数",content:"vue中模板编译指的是如何生成render渲染函数，也就是虚拟DOM（vnode）是如何生成的。\n\n在created到beforeMount这段生命周期里，主要是确定render函数。他们优先级顺序是：render > template > el。\n\n\n# 确定render函数",normalizedContent:"vue中模板编译指的是如何生成render渲染函数，也就是虚拟dom（vnode）是如何生成的。\n\n在created到beforemount这段生命周期里，主要是确定render函数。他们优先级顺序是：render > template > el。\n\n\n# 确定render函数",charsets:{cjk:!0},lastUpdated:"2022/03/24, 10:44:26",lastUpdatedTimestamp:1648089866e3},{title:"30SecondsString",frontmatter:{title:"30SecondsString",date:"2022-04-05T12:26:19.000Z",permalink:"/pages/2e07e0/",categories:["前端","30-seconds-of-code"],tags:["前端","30-seconds-of-code"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/70.30-seconds-of-code/10.30SecondsString.html",relativePath:"01.前端/70.30-seconds-of-code/10.30SecondsString.md",key:"v-05d14a18",path:"/pages/2e07e0/",headers:[{level:2,title:"CSVToArray: CSV格式字符串转数组",slug:"csvtoarray-csv格式字符串转数组",normalizedTitle:"csvtoarray: csv格式字符串转数组",charIndex:2},{level:2,title:"CSVToJSON: CSV格式字符串转JSON",slug:"csvtojson-csv格式字符串转json",normalizedTitle:"csvtojson: csv格式字符串转json",charIndex:421},{level:2,title:"URLJoin: url拼接",slug:"urljoin-url拼接",normalizedTitle:"urljoin: url拼接",charIndex:1057}],headersStr:"CSVToArray: CSV格式字符串转数组 CSVToJSON: CSV格式字符串转JSON URLJoin: url拼接",content:"# CSVToArray: CSV格式字符串转数组\n\nconst CSVToArray = (data, delimiter = ',', omitFirstRow = false) =>\n  data\n    .slice(omitFirstRow ? data.indexOf('\\n') + 1 : 0)\n    .split('\\n')\n    .map(v => v.split(delimiter));\n\n\n1\n2\n3\n4\n5\n\n\nCSVToArray('a,b\\nc,d'); // [['a', 'b'], ['c', 'd']];\nCSVToArray('a;b\\nc;d', ';'); // [['a', 'b'], ['c', 'd']];\nCSVToArray('col1,col2\\na,b\\nc,d', ',', true); // [['a', 'b'], ['c', 'd']];\n\n\n1\n2\n3\n\n\n\n# CSVToJSON: CSV格式字符串转JSON\n\nconst CSVToJSON = (data, delimiter = ',') => {\n  const titles = data.slice(0, data.indexOf('\\n')).split(delimiter);\n  return data\n    .slice(data.indexOf('\\n') + 1)\n    .split('\\n')\n    .map(v => {\n      const values = v.split(delimiter);\n      return titles.reduce(\n        (obj, title, index) => ((obj[title] = values[index]), obj),\n        {}\n      );\n    });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nCSVToJSON('col1,col2\\na,b\\nc,d');\n// [{'col1': 'a', 'col2': 'b'}, {'col1': 'c', 'col2': 'd'}];\nCSVToJSON('col1;col2\\na;b\\nc;d', ';');\n// [{'col1': 'a', 'col2': 'b'}, {'col1': 'c', 'col2': 'd'}];\n\n\n1\n2\n3\n4\n\n\n\n# URLJoin: url拼接\n\nconst URLJoin = (...args) =>\n  args\n    .join('/')\n    .replace(/[\\/]+/g, '/')\n    .replace(/^(.+):\\//, '$1://')\n    .replace(/^file:/, 'file:/')\n    .replace(/\\/(\\?|&|#[^!])/g, '$1')\n    .replace(/\\?/g, '&')\n    .replace('&', '?');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nURLJoin('http://www.google.com', 'a', '/b/cd', '?foo=123', '?bar=foo');\n// 'http://www.google.com/a/b/cd?foo=123&bar=foo'\n\n\n1\n2\n",normalizedContent:"# csvtoarray: csv格式字符串转数组\n\nconst csvtoarray = (data, delimiter = ',', omitfirstrow = false) =>\n  data\n    .slice(omitfirstrow ? data.indexof('\\n') + 1 : 0)\n    .split('\\n')\n    .map(v => v.split(delimiter));\n\n\n1\n2\n3\n4\n5\n\n\ncsvtoarray('a,b\\nc,d'); // [['a', 'b'], ['c', 'd']];\ncsvtoarray('a;b\\nc;d', ';'); // [['a', 'b'], ['c', 'd']];\ncsvtoarray('col1,col2\\na,b\\nc,d', ',', true); // [['a', 'b'], ['c', 'd']];\n\n\n1\n2\n3\n\n\n\n# csvtojson: csv格式字符串转json\n\nconst csvtojson = (data, delimiter = ',') => {\n  const titles = data.slice(0, data.indexof('\\n')).split(delimiter);\n  return data\n    .slice(data.indexof('\\n') + 1)\n    .split('\\n')\n    .map(v => {\n      const values = v.split(delimiter);\n      return titles.reduce(\n        (obj, title, index) => ((obj[title] = values[index]), obj),\n        {}\n      );\n    });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\ncsvtojson('col1,col2\\na,b\\nc,d');\n// [{'col1': 'a', 'col2': 'b'}, {'col1': 'c', 'col2': 'd'}];\ncsvtojson('col1;col2\\na;b\\nc;d', ';');\n// [{'col1': 'a', 'col2': 'b'}, {'col1': 'c', 'col2': 'd'}];\n\n\n1\n2\n3\n4\n\n\n\n# urljoin: url拼接\n\nconst urljoin = (...args) =>\n  args\n    .join('/')\n    .replace(/[\\/]+/g, '/')\n    .replace(/^(.+):\\//, '$1://')\n    .replace(/^file:/, 'file:/')\n    .replace(/\\/(\\?|&|#[^!])/g, '$1')\n    .replace(/\\?/g, '&')\n    .replace('&', '?');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nurljoin('http://www.google.com', 'a', '/b/cd', '?foo=123', '?bar=foo');\n// 'http://www.google.com/a/b/cd?foo=123&bar=foo'\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/04/12, 10:01:25",lastUpdatedTimestamp:1649728885e3},{title:"30SecondsMath",frontmatter:{title:"30SecondsMath",date:"2022-04-10T16:55:03.000Z",permalink:"/pages/908120/",author:{name:"30-seconds",link:"https://github.com/30-seconds/30-seconds-of-code"},categories:["前端","30-seconds-of-code"],tags:["工具函数","Math"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/70.30-seconds-of-code/15.30SecondsMath.html",relativePath:"01.前端/70.30-seconds-of-code/15.30SecondsMath.md",key:"v-cddb19c0",path:"/pages/908120/",headers:[{level:2,title:"HSBToRGB: 颜色HSB格式转换成RGB格式",slug:"hsbtorgb-颜色hsb格式转换成rgb格式",normalizedTitle:"hsbtorgb: 颜色hsb格式转换成rgb格式",charIndex:2},{level:2,title:"HSLToRGB: 颜色HSL格式转换成RGB格式",slug:"hsltorgb-颜色hsl格式转换成rgb格式",normalizedTitle:"hsltorgb: 颜色hsl格式转换成rgb格式",charIndex:348},{level:2,title:"RGBToHSB: 颜色RGB格式转换成HSB格式",slug:"rgbtohsb-颜色rgb格式转换成hsb格式",normalizedTitle:"rgbtohsb: 颜色rgb格式转换成hsb格式",charIndex:714},{level:2,title:"RGBToHSL: 颜色RGB格式转换成HSL格式",slug:"rgbtohsl-颜色rgb格式转换成hsl格式",normalizedTitle:"rgbtohsl: 颜色rgb格式转换成hsl格式",charIndex:1166},{level:2,title:"RGBToHex: 颜色RGB格式转换成Hex格式",slug:"rgbtohex-颜色rgb格式转换成hex格式",normalizedTitle:"rgbtohex: 颜色rgb格式转换成hex格式",charIndex:1727},{level:2,title:"accumulate: 一个数是前面所有数的和",slug:"accumulate-一个数是前面所有数的和",normalizedTitle:"accumulate: 一个数是前面所有数的和",charIndex:1896}],headersStr:"HSBToRGB: 颜色HSB格式转换成RGB格式 HSLToRGB: 颜色HSL格式转换成RGB格式 RGBToHSB: 颜色RGB格式转换成HSB格式 RGBToHSL: 颜色RGB格式转换成HSL格式 RGBToHex: 颜色RGB格式转换成Hex格式 accumulate: 一个数是前面所有数的和",content:"# HSBToRGB: 颜色HSB格式转换成RGB格式\n\nconst HSBToRGB = (h, s, b) => {\n  s /= 100;\n  b /= 100;\n  const k = (n) => (n + h / 60) % 6;\n  const f = (n) => b * (1 - s * Math.max(0, Math.min(k(n), 4 - k(n), 1)));\n  return [255 * f(5), 255 * f(3), 255 * f(1)];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nHSBToRGB(18, 81, 99); // [252.45, 109.31084999999996, 47.965499999999984]\n\n\n1\n\n\n\n# HSLToRGB: 颜色HSL格式转换成RGB格式\n\nconst HSLToRGB = (h, s, l) => {\n  s /= 100;\n  l /= 100;\n  const k = n => (n + h / 30) % 12;\n  const a = s * Math.min(l, 1 - l);\n  const f = n =>\n    l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));\n  return [255 * f(0), 255 * f(8), 255 * f(4)];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nHSLToRGB(13, 100, 11); // [56.1, 12.155, 0]\n\n\n1\n\n\n\n# RGBToHSB: 颜色RGB格式转换成HSB格式\n\nconst RGBToHSB = (r, g, b) => {\n  r /= 255;\n  g /= 255;\n  b /= 255;\n  const v = Math.max(r, g, b),\n    n = v - Math.min(r, g, b);\n  const h =\n    n === 0 ? 0 : n && v === r ? (g - b) / n : v === g ? 2 + (b - r) / n : 4 + (r - g) / n;\n  return [60 * (h < 0 ? h + 6 : h), v && (n / v) * 100, v * 100];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nRGBToHSB(252, 111, 48);\n// [18.529411764705856, 80.95238095238095, 98.82352941176471]\n\n\n1\n2\n\n\n\n# RGBToHSL: 颜色RGB格式转换成HSL格式\n\nconst RGBToHSL = (r, g, b) => {\n  r /= 255;\n  g /= 255;\n  b /= 255;\n  const l = Math.max(r, g, b);\n  const s = l - Math.min(r, g, b);\n  const h = s\n    ? l === r\n      ? (g - b) / s\n      : l === g\n      ? 2 + (b - r) / s\n      : 4 + (r - g) / s\n    : 0;\n  return [\n    60 * h < 0 ? 60 * h + 360 : 60 * h,\n    100 * (s ? (l <= 0.5 ? s / (2 * l - s) : s / (2 - (2 * l - s))) : 0),\n    (100 * (2 * l - s)) / 2,\n  ];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nRGBToHSL(45, 23, 11); // [21.17647, 60.71428, 10.98039]\n\n\n1\n\n\n\n# RGBToHex: 颜色RGB格式转换成Hex格式\n\nconst RGBToHex = (r, g, b) =>\n  ((r << 16) + (g << 8) + b).toString(16).padStart(6, '0');\n\n\n1\n2\n\n\nRGBToHex(255, 165, 1); // 'ffa501'\n\n\n1\n\n\n\n# accumulate: 一个数是前面所有数的和\n\nconst accumulate = (...nums) =>\n  nums.reduce((acc, n) => [...acc, n + (acc.slice(-1)[0] || 0)], []);\n\n\n1\n2\n\n\naccumulate(1, 2, 3, 4); // [1, 3, 6, 10]\naccumulate(...[1, 2, 3, 4]); // [1, 3, 6, 10]\n\n\n1\n2\n",normalizedContent:"# hsbtorgb: 颜色hsb格式转换成rgb格式\n\nconst hsbtorgb = (h, s, b) => {\n  s /= 100;\n  b /= 100;\n  const k = (n) => (n + h / 60) % 6;\n  const f = (n) => b * (1 - s * math.max(0, math.min(k(n), 4 - k(n), 1)));\n  return [255 * f(5), 255 * f(3), 255 * f(1)];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nhsbtorgb(18, 81, 99); // [252.45, 109.31084999999996, 47.965499999999984]\n\n\n1\n\n\n\n# hsltorgb: 颜色hsl格式转换成rgb格式\n\nconst hsltorgb = (h, s, l) => {\n  s /= 100;\n  l /= 100;\n  const k = n => (n + h / 30) % 12;\n  const a = s * math.min(l, 1 - l);\n  const f = n =>\n    l - a * math.max(-1, math.min(k(n) - 3, math.min(9 - k(n), 1)));\n  return [255 * f(0), 255 * f(8), 255 * f(4)];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nhsltorgb(13, 100, 11); // [56.1, 12.155, 0]\n\n\n1\n\n\n\n# rgbtohsb: 颜色rgb格式转换成hsb格式\n\nconst rgbtohsb = (r, g, b) => {\n  r /= 255;\n  g /= 255;\n  b /= 255;\n  const v = math.max(r, g, b),\n    n = v - math.min(r, g, b);\n  const h =\n    n === 0 ? 0 : n && v === r ? (g - b) / n : v === g ? 2 + (b - r) / n : 4 + (r - g) / n;\n  return [60 * (h < 0 ? h + 6 : h), v && (n / v) * 100, v * 100];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nrgbtohsb(252, 111, 48);\n// [18.529411764705856, 80.95238095238095, 98.82352941176471]\n\n\n1\n2\n\n\n\n# rgbtohsl: 颜色rgb格式转换成hsl格式\n\nconst rgbtohsl = (r, g, b) => {\n  r /= 255;\n  g /= 255;\n  b /= 255;\n  const l = math.max(r, g, b);\n  const s = l - math.min(r, g, b);\n  const h = s\n    ? l === r\n      ? (g - b) / s\n      : l === g\n      ? 2 + (b - r) / s\n      : 4 + (r - g) / s\n    : 0;\n  return [\n    60 * h < 0 ? 60 * h + 360 : 60 * h,\n    100 * (s ? (l <= 0.5 ? s / (2 * l - s) : s / (2 - (2 * l - s))) : 0),\n    (100 * (2 * l - s)) / 2,\n  ];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nrgbtohsl(45, 23, 11); // [21.17647, 60.71428, 10.98039]\n\n\n1\n\n\n\n# rgbtohex: 颜色rgb格式转换成hex格式\n\nconst rgbtohex = (r, g, b) =>\n  ((r << 16) + (g << 8) + b).tostring(16).padstart(6, '0');\n\n\n1\n2\n\n\nrgbtohex(255, 165, 1); // 'ffa501'\n\n\n1\n\n\n\n# accumulate: 一个数是前面所有数的和\n\nconst accumulate = (...nums) =>\n  nums.reduce((acc, n) => [...acc, n + (acc.slice(-1)[0] || 0)], []);\n\n\n1\n2\n\n\naccumulate(1, 2, 3, 4); // [1, 3, 6, 10]\naccumulate(...[1, 2, 3, 4]); // [1, 3, 6, 10]\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/04/12, 10:00:45",lastUpdatedTimestamp:1649728845e3},{title:"30SecondsNode",frontmatter:{title:"30SecondsNode",date:"2022-04-12T08:56:06.000Z",permalink:"/pages/28a623/",categories:["前端","30-seconds-of-code"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/70.30-seconds-of-code/20.30SecondsNode.html",relativePath:"01.前端/70.30-seconds-of-code/20.30SecondsNode.md",key:"v-6849e8f8",path:"/pages/28a623/",headers:[{level:2,title:"JSONToFile：把js对象写入成json文件",slug:"jsontofile-把js对象写入成json文件",normalizedTitle:"jsontofile：把js对象写入成json文件",charIndex:2},{level:2,title:"UUIDGeneratorNode： Node 生成UUID",slug:"uuidgeneratornode-node-生成uuid",normalizedTitle:"uuidgeneratornode： node 生成uuid",charIndex:282}],headersStr:"JSONToFile：把js对象写入成json文件 UUIDGeneratorNode： Node 生成UUID",content:"# JSONToFile：把js对象写入成json文件\n\nconst fs = require('fs');\n\nconst JSONToFile = (obj, filename) =>\n  fs.writeFileSync(`${filename}.json`, JSON.stringify(obj, null, 2));\n\n\n1\n2\n3\n4\n\n\nJSONToFile({ test: 'is passed' }, 'testJsonFile');\n// writes the object to 'testJsonFile.json'\n\n\n1\n2\n\n\n\n# UUIDGeneratorNode： Node 生成UUID\n\nconst crypto = require('crypto');\n\nconst UUIDGeneratorNode = () =>\n  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n    (c ^ (crypto.randomBytes(1)[0] & (15 >> (c / 4)))).toString(16)\n  );\n\n\n1\n2\n3\n4\n5\n6\n\n\nUUIDGeneratorNode(); // '79c7c136-60ee-40a2-beb2-856f1feabefc'\n\n\n1\n",normalizedContent:"# jsontofile：把js对象写入成json文件\n\nconst fs = require('fs');\n\nconst jsontofile = (obj, filename) =>\n  fs.writefilesync(`${filename}.json`, json.stringify(obj, null, 2));\n\n\n1\n2\n3\n4\n\n\njsontofile({ test: 'is passed' }, 'testjsonfile');\n// writes the object to 'testjsonfile.json'\n\n\n1\n2\n\n\n\n# uuidgeneratornode： node 生成uuid\n\nconst crypto = require('crypto');\n\nconst uuidgeneratornode = () =>\n  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n    (c ^ (crypto.randombytes(1)[0] & (15 >> (c / 4)))).tostring(16)\n  );\n\n\n1\n2\n3\n4\n5\n6\n\n\nuuidgeneratornode(); // '79c7c136-60ee-40a2-beb2-856f1feabefc'\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/12, 09:11:55",lastUpdatedTimestamp:1649725915e3},{title:"30SecondsBrower",frontmatter:{title:"30SecondsBrower",date:"2022-04-12T09:23:20.000Z",permalink:"/pages/8fb9cb/",categories:["前端","30-seconds-of-code"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/70.30-seconds-of-code/25.30SecondsBrower.html",relativePath:"01.前端/70.30-seconds-of-code/25.30SecondsBrower.md",key:"v-00e56428",path:"/pages/8fb9cb/",headers:[{level:2,title:"UUIDGeneratorBrowser: 浏览器端生成UUID",slug:"uuidgeneratorbrowser-浏览器端生成uuid",normalizedTitle:"uuidgeneratorbrowser: 浏览器端生成uuid",charIndex:2},{level:2,title:"addClass: DOM中添加class",slug:"addclass-dom中添加class",normalizedTitle:"addclass: dom中添加class",charIndex:337},{level:2,title:"addEventListenerAll: 多个DOM添加相同事件",slug:"addeventlistenerall-多个dom添加相同事件",normalizedTitle:"addeventlistenerall: 多个dom添加相同事件",charIndex:543},{level:2,title:"addMultipleListeners: DOM添加多个事件",slug:"addmultiplelisteners-dom添加多个事件",normalizedTitle:"addmultiplelisteners: dom添加多个事件",charIndex:953},{level:2,title:"addStyles: DOM添加内联样式",slug:"addstyles-dom添加内联样式",normalizedTitle:"addstyles: dom添加内联样式",charIndex:1313}],headersStr:"UUIDGeneratorBrowser: 浏览器端生成UUID addClass: DOM中添加class addEventListenerAll: 多个DOM添加相同事件 addMultipleListeners: DOM添加多个事件 addStyles: DOM添加内联样式",content:"# UUIDGeneratorBrowser: 浏览器端生成UUID\n\nconst UUIDGeneratorBrowser = () =>\n  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n    (\n      c ^\n      (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))\n    ).toString(16)\n  );\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nUUIDGeneratorBrowser(); // '7982fcfe-5721-4632-bede-6000885be57d'\n\n\n1\n\n\n\n# addClass: DOM中添加class\n\nconst addClass = (el, className) => el.classList.add(className);\n\n\n1\n\n\naddClass(document.querySelector('p'), 'special');\n// The paragraph will now have the 'special' class\n\n\n1\n2\n\n\n\n# addEventListenerAll: 多个DOM添加相同事件\n\nconst addEventListenerAll = (targets, type, listener, options, useCapture) => {\n  targets.forEach(target =>\n    target.addEventListener(type, listener, options, useCapture)\n  );\n};\n\n\n1\n2\n3\n4\n5\n\n\naddEventListenerAll(document.querySelectorAll('a'), 'click', () =>\n  console.log('Clicked a link')\n);\n// Logs 'Clicked a link' whenever any anchor element is clicked\n\n\n1\n2\n3\n4\n\n\n\n# addMultipleListeners: DOM添加多个事件\n\nconst addMultipleListeners = (el, types, listener, options, useCapture) => {\n  types.forEach(type =>\n    el.addEventListener(type, listener, options, useCapture)\n  );\n};\n\n\n1\n2\n3\n4\n5\n\n\naddMultipleListeners(\n  document.querySelector('.my-element'),\n  ['click', 'mousedown'],\n  () => { console.log('hello!') }\n);\n\n\n1\n2\n3\n4\n5\n\n\n\n# addStyles: DOM添加内联样式\n\nconst addStyles = (el, styles) => Object.assign(el.style, styles);\n\n\n1\n\n\naddStyles(document.getElementById('my-element'), {\n  background: 'red',\n  color: '#ffff00',\n  fontSize: '3rem'\n});\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# uuidgeneratorbrowser: 浏览器端生成uuid\n\nconst uuidgeneratorbrowser = () =>\n  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n    (\n      c ^\n      (crypto.getrandomvalues(new uint8array(1))[0] & (15 >> (c / 4)))\n    ).tostring(16)\n  );\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nuuidgeneratorbrowser(); // '7982fcfe-5721-4632-bede-6000885be57d'\n\n\n1\n\n\n\n# addclass: dom中添加class\n\nconst addclass = (el, classname) => el.classlist.add(classname);\n\n\n1\n\n\naddclass(document.queryselector('p'), 'special');\n// the paragraph will now have the 'special' class\n\n\n1\n2\n\n\n\n# addeventlistenerall: 多个dom添加相同事件\n\nconst addeventlistenerall = (targets, type, listener, options, usecapture) => {\n  targets.foreach(target =>\n    target.addeventlistener(type, listener, options, usecapture)\n  );\n};\n\n\n1\n2\n3\n4\n5\n\n\naddeventlistenerall(document.queryselectorall('a'), 'click', () =>\n  console.log('clicked a link')\n);\n// logs 'clicked a link' whenever any anchor element is clicked\n\n\n1\n2\n3\n4\n\n\n\n# addmultiplelisteners: dom添加多个事件\n\nconst addmultiplelisteners = (el, types, listener, options, usecapture) => {\n  types.foreach(type =>\n    el.addeventlistener(type, listener, options, usecapture)\n  );\n};\n\n\n1\n2\n3\n4\n5\n\n\naddmultiplelisteners(\n  document.queryselector('.my-element'),\n  ['click', 'mousedown'],\n  () => { console.log('hello!') }\n);\n\n\n1\n2\n3\n4\n5\n\n\n\n# addstyles: dom添加内联样式\n\nconst addstyles = (el, styles) => object.assign(el.style, styles);\n\n\n1\n\n\naddstyles(document.getelementbyid('my-element'), {\n  background: 'red',\n  color: '#ffff00',\n  fontsize: '3rem'\n});\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/04/12, 10:00:19",lastUpdatedTimestamp:1649728819e3},{title:"30SecondsDate",frontmatter:{title:"30SecondsDate",date:"2022-04-12T09:25:36.000Z",permalink:"/pages/ee2d60/",categories:["前端","30-seconds-of-code"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/70.30-seconds-of-code/30.30SecondsDate.html",relativePath:"01.前端/70.30-seconds-of-code/30.30SecondsDate.md",key:"v-4e647fa2",path:"/pages/ee2d60/",headers:[{level:2,title:"addDaysToDate: 日期添加天数",slug:"adddaystodate-日期添加天数",normalizedTitle:"adddaystodate: 日期添加天数",charIndex:2},{level:2,title:"addMinutesToDate: 日期添加分钟",slug:"addminutestodate-日期添加分钟",normalizedTitle:"addminutestodate: 日期添加分钟",charIndex:287},{level:2,title:"addWeekDays: 日期添加工作日",slug:"addweekdays-日期添加工作日",normalizedTitle:"addweekdays: 日期添加工作日",charIndex:636}],headersStr:"addDaysToDate: 日期添加天数 addMinutesToDate: 日期添加分钟 addWeekDays: 日期添加工作日",content:"# addDaysToDate: 日期添加天数\n\nconst addDaysToDate = (date, n) => {\n  const d = new Date(date);\n  d.setDate(d.getDate() + n);\n  return d.toISOString().split('T')[0];\n};\n\n\n1\n2\n3\n4\n5\n\n\naddDaysToDate('2020-10-15', 10); // '2020-10-25'\naddDaysToDate('2020-10-15', -10); // '2020-10-05'\n\n\n1\n2\n\n\n\n# addMinutesToDate: 日期添加分钟\n\nconst addMinutesToDate = (date, n) => {\n  const d = new Date(date);\n  d.setTime(d.getTime() + n * 60000);\n  return d.toISOString().split('.')[0].replace('T',' ');\n};\n\n\n1\n2\n3\n4\n5\n\n\naddMinutesToDate('2020-10-19 12:00:00', 10); // '2020-10-19 12:10:00'\naddMinutesToDate('2020-10-19', -10); // '2020-10-18 23:50:00'\n\n\n1\n2\n\n\n\n# addWeekDays: 日期添加工作日\n\n不包含法定节假日，除了周末都是工作日\n\nconst addWeekDays = (startDate, count) =>\n    Array.from({ length: count }).reduce(date => {\n        date = new Date(date.setDate(date.getDate() + 1));\n        if (date.getDay() % 6 === 0)\n            date = new Date(date.setDate(date.getDate() + (date.getDay() / 6 + 1)));\n        return date;\n    }, startDate);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\naddWeekDays(new Date('Oct 09, 2020'), 5); // 'Oct 16, 2020'\naddWeekDays(new Date('Oct 12, 2020'), 5); // 'Oct 19, 2020'\n\n\n1\n2\n",normalizedContent:"# adddaystodate: 日期添加天数\n\nconst adddaystodate = (date, n) => {\n  const d = new date(date);\n  d.setdate(d.getdate() + n);\n  return d.toisostring().split('t')[0];\n};\n\n\n1\n2\n3\n4\n5\n\n\nadddaystodate('2020-10-15', 10); // '2020-10-25'\nadddaystodate('2020-10-15', -10); // '2020-10-05'\n\n\n1\n2\n\n\n\n# addminutestodate: 日期添加分钟\n\nconst addminutestodate = (date, n) => {\n  const d = new date(date);\n  d.settime(d.gettime() + n * 60000);\n  return d.toisostring().split('.')[0].replace('t',' ');\n};\n\n\n1\n2\n3\n4\n5\n\n\naddminutestodate('2020-10-19 12:00:00', 10); // '2020-10-19 12:10:00'\naddminutestodate('2020-10-19', -10); // '2020-10-18 23:50:00'\n\n\n1\n2\n\n\n\n# addweekdays: 日期添加工作日\n\n不包含法定节假日，除了周末都是工作日\n\nconst addweekdays = (startdate, count) =>\n    array.from({ length: count }).reduce(date => {\n        date = new date(date.setdate(date.getdate() + 1));\n        if (date.getday() % 6 === 0)\n            date = new date(date.setdate(date.getdate() + (date.getday() / 6 + 1)));\n        return date;\n    }, startdate);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\naddweekdays(new date('oct 09, 2020'), 5); // 'oct 16, 2020'\naddweekdays(new date('oct 12, 2020'), 5); // 'oct 19, 2020'\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/04/12, 09:57:43",lastUpdatedTimestamp:1649728663e3},{title:"30SecondsArray",frontmatter:{title:"30SecondsArray",date:"2022-04-03T19:36:53.000Z",permalink:"/pages/14d237/",author:{name:"30-seconds",link:"https://github.com/30-seconds/30-seconds-of-code"},categories:["前端","30-seconds-of-code"],tags:["工具函数","数组"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/70.30-seconds-of-code/5.30SecondsArray.html",relativePath:"01.前端/70.30-seconds-of-code/5.30SecondsArray.md",key:"v-33194080",path:"/pages/14d237/",headers:[{level:2,title:"all：布尔全等判断",slug:"all-布尔全等判断",normalizedTitle:"all：布尔全等判断",charIndex:2},{level:2,title:"allEqual：检查数组各项相等",slug:"allequal-检查数组各项相等",normalizedTitle:"allequal：检查数组各项相等",charIndex:141},{level:2,title:"allEqualBy：检查数组各项是否满足条件（四舍五入）",slug:"allequalby-检查数组各项是否满足条件-四舍五入",normalizedTitle:"allequalby：检查数组各项是否满足条件（四舍五入）",charIndex:306},{level:2,title:"allUnique：检查数组是否重复",slug:"allunique-检查数组是否重复",normalizedTitle:"allunique：检查数组是否重复",charIndex:566},{level:2,title:"allUniqueBy：根据条件（四舍五入）检查数组是否重复",slug:"alluniqueby-根据条件-四舍五入-检查数组是否重复",normalizedTitle:"alluniqueby：根据条件（四舍五入）检查数组是否重复",charIndex:729},{level:2,title:"someAny：检查数组是否要求",slug:"someany-检查数组是否要求",normalizedTitle:"someany：检查数组是否要求",charIndex:954},{level:2,title:"aperture：分割数组，每份长度为n",slug:"aperture-分割数组-每份长度为n",normalizedTitle:"aperture：分割数组，每份长度为n",charIndex:1120},{level:2,title:"approximatelyEqual：约等于",slug:"approximatelyequal-约等于",normalizedTitle:"approximatelyequal：约等于",charIndex:1422},{level:2,title:"arithmeticProgression：等差数列",slug:"arithmeticprogression-等差数列",normalizedTitle:"arithmeticprogression：等差数列",charIndex:1601},{level:2,title:"arrayToCSV：数组转CSV格式（带空格的字符串）",slug:"arraytocsv-数组转csv格式-带空格的字符串",normalizedTitle:"arraytocsv：数组转csv格式（带空格的字符串）",charIndex:1812},{level:2,title:"arrayToHTMLList：数组转li列表",slug:"arraytohtmllist-数组转li列表",normalizedTitle:"arraytohtmllist：数组转li列表",charIndex:2248},{level:2,title:"average：平均数",slug:"average-平均数",normalizedTitle:"average：平均数",charIndex:2531},{level:2,title:"averageBy：数组对象属性平均数",slug:"averageby-数组对象属性平均数",normalizedTitle:"averageby：数组对象属性平均数",charIndex:2700},{level:2,title:"JSONtoCSV: JSON数组转CSV格式",slug:"jsontocsv-json数组转csv格式",normalizedTitle:"jsontocsv: json数组转csv格式",charIndex:3023}],headersStr:"all：布尔全等判断 allEqual：检查数组各项相等 allEqualBy：检查数组各项是否满足条件（四舍五入） allUnique：检查数组是否重复 allUniqueBy：根据条件（四舍五入）检查数组是否重复 someAny：检查数组是否要求 aperture：分割数组，每份长度为n approximatelyEqual：约等于 arithmeticProgression：等差数列 arrayToCSV：数组转CSV格式（带空格的字符串） arrayToHTMLList：数组转li列表 average：平均数 averageBy：数组对象属性平均数 JSONtoCSV: JSON数组转CSV格式",content:"# all：布尔全等判断\n\nconst all = (arr, fn = Boolean) => arr.every(fn);\n\n\n1\n\n\nall([4, 2, 3], x => x > 1); // true\nall([1, 2, 3]); // true\n\n\n1\n2\n\n\n\n# allEqual：检查数组各项相等\n\nconst allEqual = arr => arr.every(val => val === arr[0]);\n\n\n1\n\n\nallEqual([1, 2, 3, 4, 5, 6]); // false\nallEqual([1, 1, 1, 1]); // true\n\n\n1\n2\n\n\n\n# allEqualBy：检查数组各项是否满足条件（四舍五入）\n\nconst allEqualBy = (arr, fn) => {\n  const eql = fn(arr[0]);\n  return arr.every(val => fn(val) === eql);\n};\n\n\n1\n2\n3\n4\n\n\nallEqualBy([1.1, 1.2, 1.3], Math.round); // true\nallEqualBy([1.1, 1.3, 1.6], Math.round); // false\n\n\n1\n2\n\n\n\n# allUnique：检查数组是否重复\n\nconst allUnique = arr => arr.length === new Set(arr).size;\n\n\n1\n\n\nallUnique([1, 2, 3, 4]); // true\nallUnique([1, 1, 2, 3]); // false\n\n\n1\n2\n\n\n\n# allUniqueBy：根据条件（四舍五入）检查数组是否重复\n\nconst allUniqueBy = (arr, fn) => arr.length === new Set(arr.map(fn)).size;\n\n\n1\n\n\nallUniqueBy([1.2, 2.4, 2.9], Math.round); // true\nallUniqueBy([1.2, 2.3, 2.4], Math.round); // false\n\n\n1\n2\n\n\n\n# someAny：检查数组是否要求\n\nconst someAny = (arr, fn = Boolean) => arr.some(fn);\n\n\n1\n\n\nsomeAny([0, 1, 2, 0], x => x >= 2); // true\nsomeAny([0, 0, 1, 0]); // true\n\n\n\n1\n2\n3\n\n\n\n# aperture：分割数组，每份长度为n\n\nconst aperture = (n, arr) =>\n  n > arr.length\n    ? []\n    : arr.slice(n - 1).map((v, i) => arr.slice(i, i + n));\n\n\n1\n2\n3\n4\n\n\naperture(2, [1, 2, 3, 4]); // [[1, 2], [2, 3], [3, 4]]\naperture(3, [1, 2, 3, 4]); // [[1, 2, 3], [2, 3, 4]]\naperture(5, [1, 2, 3, 4]); // []\n\n\n1\n2\n3\n\n\n\n# approximatelyEqual：约等于\n\nconst approximatelyEqual = (v1, v2, epsilon = 0.001) =>\n  Math.abs(v1 - v2) < epsilon;\n\n\n1\n2\n\n\napproximatelyEqual(Math.PI / 2.0, 1.5708); // true\n\n\n1\n\n\n\n# arithmeticProgression：等差数列\n\nconst arithmeticProgression  = (n, lim) =>\n  Array.from({ length: Math.ceil(lim / n) }, (_, i) => (i + 1) * n );\n\n\n1\n2\n\n\narithmeticProgression(5, 25); // [5, 10, 15, 20, 25]\n\n\n1\n\n\n\n# arrayToCSV：数组转CSV格式（带空格的字符串）\n\nconst arrayToCSV = (arr, delimiter = ',') =>\n  arr\n    .map(v =>\n      v.map(x => (isNaN(x) ? `\"${x.replace(/\"/g, '\"\"')}\"` : x)).join(delimiter)\n    )\n    .join('\\n');\n\n\n1\n2\n3\n4\n5\n6\n\n\narrayToCSV([['a', 'b'], ['c', 'd']]); // '\"a\",\"b\"\\n\"c\",\"d\"'\narrayToCSV([['a', 'b'], ['c', 'd']], ';'); // '\"a\";\"b\"\\n\"c\";\"d\"'\narrayToCSV([['a', '\"b\" great'], ['c', 3.1415]]); // '\"a\",\"\"\"b\"\" great\"\\n\"c\",3.1415'\n\n\n1\n2\n3\n\n\n\n# arrayToHTMLList：数组转li列表\n\n此代码段将数组的元素转换为 li 标签，并将其附加到给定ID的列表中。\n\nconst arrayToHTMLList = (arr, listID) =>\n  document.querySelector(`#${listID}`).innerHTML += arr\n    .map(item => `<li>${item}</li>`)\n    .join('');\n\n\n1\n2\n3\n4\n\n\narrayToHTMLList(['item 1', 'item 2'], 'myListID');\n\n\n1\n\n\n\n# average：平均数\n\nconst average = (...nums) =>\n  nums.reduce((acc, val) => acc + val, 0) / nums.length;\n\n\n1\n2\n\n\naverage(...[1, 2, 3]); // 2\naverage(1, 2, 3); // 2\n\n\n1\n2\n\n\n\n# averageBy：数组对象属性平均数\n\nconst averageBy = (arr, fn) =>\n  arr\n    .map(typeof fn === 'function' ? fn : val => val[fn])\n    .reduce((acc, val) => acc + val, 0) / arr.length;\n\n\n1\n2\n3\n4\n\n\naverageBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 5\naverageBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 5\n\n\n1\n2\n\n\n\n# JSONtoCSV: JSON数组转CSV格式\n\nconst JSONtoCSV = (arr, columns, delimiter = ',') =>\n  [\n    columns.join(delimiter),\n    ...arr.map(obj =>\n      columns.reduce(\n        (acc, key) =>\n          `${acc}${!acc.length ? '' : delimiter}\"${!obj[key] ? '' : obj[key]}\"`,\n        ''\n      )\n    ),\n  ].join('\\n');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nJSONtoCSV(\n  [{ a: 1, b: 2 }, { a: 3, b: 4, c: 5 }, { a: 6 }, { b: 7 }],\n  ['a', 'b']\n); // 'a,b\\n\"1\",\"2\"\\n\"3\",\"4\"\\n\"6\",\"\"\\n\"\",\"7\"'\nJSONtoCSV(\n  [{ a: 1, b: 2 }, { a: 3, b: 4, c: 5 }, { a: 6 }, { b: 7 }],\n  ['a', 'b'],\n  ';'\n); // 'a;b\\n\"1\";\"2\"\\n\"3\";\"4\"\\n\"6\";\"\"\\n\"\";\"7\"'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",normalizedContent:"# all：布尔全等判断\n\nconst all = (arr, fn = boolean) => arr.every(fn);\n\n\n1\n\n\nall([4, 2, 3], x => x > 1); // true\nall([1, 2, 3]); // true\n\n\n1\n2\n\n\n\n# allequal：检查数组各项相等\n\nconst allequal = arr => arr.every(val => val === arr[0]);\n\n\n1\n\n\nallequal([1, 2, 3, 4, 5, 6]); // false\nallequal([1, 1, 1, 1]); // true\n\n\n1\n2\n\n\n\n# allequalby：检查数组各项是否满足条件（四舍五入）\n\nconst allequalby = (arr, fn) => {\n  const eql = fn(arr[0]);\n  return arr.every(val => fn(val) === eql);\n};\n\n\n1\n2\n3\n4\n\n\nallequalby([1.1, 1.2, 1.3], math.round); // true\nallequalby([1.1, 1.3, 1.6], math.round); // false\n\n\n1\n2\n\n\n\n# allunique：检查数组是否重复\n\nconst allunique = arr => arr.length === new set(arr).size;\n\n\n1\n\n\nallunique([1, 2, 3, 4]); // true\nallunique([1, 1, 2, 3]); // false\n\n\n1\n2\n\n\n\n# alluniqueby：根据条件（四舍五入）检查数组是否重复\n\nconst alluniqueby = (arr, fn) => arr.length === new set(arr.map(fn)).size;\n\n\n1\n\n\nalluniqueby([1.2, 2.4, 2.9], math.round); // true\nalluniqueby([1.2, 2.3, 2.4], math.round); // false\n\n\n1\n2\n\n\n\n# someany：检查数组是否要求\n\nconst someany = (arr, fn = boolean) => arr.some(fn);\n\n\n1\n\n\nsomeany([0, 1, 2, 0], x => x >= 2); // true\nsomeany([0, 0, 1, 0]); // true\n\n\n\n1\n2\n3\n\n\n\n# aperture：分割数组，每份长度为n\n\nconst aperture = (n, arr) =>\n  n > arr.length\n    ? []\n    : arr.slice(n - 1).map((v, i) => arr.slice(i, i + n));\n\n\n1\n2\n3\n4\n\n\naperture(2, [1, 2, 3, 4]); // [[1, 2], [2, 3], [3, 4]]\naperture(3, [1, 2, 3, 4]); // [[1, 2, 3], [2, 3, 4]]\naperture(5, [1, 2, 3, 4]); // []\n\n\n1\n2\n3\n\n\n\n# approximatelyequal：约等于\n\nconst approximatelyequal = (v1, v2, epsilon = 0.001) =>\n  math.abs(v1 - v2) < epsilon;\n\n\n1\n2\n\n\napproximatelyequal(math.pi / 2.0, 1.5708); // true\n\n\n1\n\n\n\n# arithmeticprogression：等差数列\n\nconst arithmeticprogression  = (n, lim) =>\n  array.from({ length: math.ceil(lim / n) }, (_, i) => (i + 1) * n );\n\n\n1\n2\n\n\narithmeticprogression(5, 25); // [5, 10, 15, 20, 25]\n\n\n1\n\n\n\n# arraytocsv：数组转csv格式（带空格的字符串）\n\nconst arraytocsv = (arr, delimiter = ',') =>\n  arr\n    .map(v =>\n      v.map(x => (isnan(x) ? `\"${x.replace(/\"/g, '\"\"')}\"` : x)).join(delimiter)\n    )\n    .join('\\n');\n\n\n1\n2\n3\n4\n5\n6\n\n\narraytocsv([['a', 'b'], ['c', 'd']]); // '\"a\",\"b\"\\n\"c\",\"d\"'\narraytocsv([['a', 'b'], ['c', 'd']], ';'); // '\"a\";\"b\"\\n\"c\";\"d\"'\narraytocsv([['a', '\"b\" great'], ['c', 3.1415]]); // '\"a\",\"\"\"b\"\" great\"\\n\"c\",3.1415'\n\n\n1\n2\n3\n\n\n\n# arraytohtmllist：数组转li列表\n\n此代码段将数组的元素转换为 li 标签，并将其附加到给定id的列表中。\n\nconst arraytohtmllist = (arr, listid) =>\n  document.queryselector(`#${listid}`).innerhtml += arr\n    .map(item => `<li>${item}</li>`)\n    .join('');\n\n\n1\n2\n3\n4\n\n\narraytohtmllist(['item 1', 'item 2'], 'mylistid');\n\n\n1\n\n\n\n# average：平均数\n\nconst average = (...nums) =>\n  nums.reduce((acc, val) => acc + val, 0) / nums.length;\n\n\n1\n2\n\n\naverage(...[1, 2, 3]); // 2\naverage(1, 2, 3); // 2\n\n\n1\n2\n\n\n\n# averageby：数组对象属性平均数\n\nconst averageby = (arr, fn) =>\n  arr\n    .map(typeof fn === 'function' ? fn : val => val[fn])\n    .reduce((acc, val) => acc + val, 0) / arr.length;\n\n\n1\n2\n3\n4\n\n\naverageby([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 5\naverageby([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 5\n\n\n1\n2\n\n\n\n# jsontocsv: json数组转csv格式\n\nconst jsontocsv = (arr, columns, delimiter = ',') =>\n  [\n    columns.join(delimiter),\n    ...arr.map(obj =>\n      columns.reduce(\n        (acc, key) =>\n          `${acc}${!acc.length ? '' : delimiter}\"${!obj[key] ? '' : obj[key]}\"`,\n        ''\n      )\n    ),\n  ].join('\\n');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\njsontocsv(\n  [{ a: 1, b: 2 }, { a: 3, b: 4, c: 5 }, { a: 6 }, { b: 7 }],\n  ['a', 'b']\n); // 'a,b\\n\"1\",\"2\"\\n\"3\",\"4\"\\n\"6\",\"\"\\n\"\",\"7\"'\njsontocsv(\n  [{ a: 1, b: 2 }, { a: 3, b: 4, c: 5 }, { a: 6 }, { b: 7 }],\n  ['a', 'b'],\n  ';'\n); // 'a;b\\n\"1\";\"2\"\\n\"3\";\"4\"\\n\"6\";\"\"\\n\"\";\"7\"'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",charsets:{cjk:!0},lastUpdated:"2022/04/12, 09:05:13",lastUpdatedTimestamp:1649725513e3},{title:"Chrome架构：仅仅打开了1个页面，为什么有4个进程",frontmatter:{title:"Chrome架构：仅仅打开了1个页面，为什么有4个进程",date:"2022-04-04T00:10:47.000Z",permalink:"/pages/4555d4/",author:{name:"李兵",link:"https://time.geekbang.org/column/intro/216?tab=comment"},categories:["前端","浏览器","宏观视角上的浏览器"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/80.%E6%B5%8F%E8%A7%88%E5%99%A8/10.%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8A%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/4.Chrome%E6%9E%B6%E6%9E%84.html",relativePath:"01.前端/80.浏览器/10.宏观视角上的浏览器/4.Chrome架构.md",key:"v-7d53ccf6",path:"/pages/4555d4/",headers:[{level:2,title:"进程和线程",slug:"进程和线程",normalizedTitle:"进程和线程",charIndex:247},{level:3,title:"什么是并行处理",slug:"什么是并行处理",normalizedTitle:"什么是并行处理",charIndex:334},{level:3,title:"线程 VS 进程",slug:"线程-vs-进程",normalizedTitle:"线程 vs 进程",charIndex:734},{level:2,title:"单进程浏览器时代",slug:"单进程浏览器时代",normalizedTitle:"单进程浏览器时代",charIndex:1634},{level:2,title:"多进程浏览器时代",slug:"多进程浏览器时代",normalizedTitle:"多进程浏览器时代",charIndex:2929},{level:3,title:"早期多进程架构",slug:"早期多进程架构",normalizedTitle:"早期多进程架构",charIndex:2989},{level:3,title:"目前多进程架构",slug:"目前多进程架构",normalizedTitle:"目前多进程架构",charIndex:3724},{level:3,title:"未来面向服务的架构",slug:"未来面向服务的架构",normalizedTitle:"未来面向服务的架构",charIndex:4684},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:956}],headersStr:"进程和线程 什么是并行处理 线程 VS 进程 单进程浏览器时代 多进程浏览器时代 早期多进程架构 目前多进程架构 未来面向服务的架构 总结",content:'在开始之前，我们一起看下，Chrome打开一个页面需要启动多少进程？你可以点击Chrome浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开Chrome的任务管理器的窗口，如下图\n\n\n\n和Windows任务管理器一样，Chrome任务管理器也是用来展示运行中Chrome使用的进程信息的。从图中可以看到，Chrome启动了4个进程，你也许会好奇，只是打开了1个页面，为什么要启动这么多进程呢？\n\n在解答这个问题之前，我们需要了解一下进程的概念，不过由于好多人容易把进程和线程的概念混淆，从而影响后续其他概念的理解，所以这里我就将这两个概念以及它们之间的关系一并为你讲解下。\n\n\n# 进程和线程\n\n不过，在介绍进程和线程之前，我需要先讲解下什么是并行处理，因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多\n\n\n# 什么是并行处理\n\n计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果\n\nA = 1+2\nB = 20/5\nC = 7*8\n\n\n1\n2\n3\n\n\n在编写代码的时候，我们可以把这个过程拆分为四个任务：\n\n * 任务1 是计算A=1+2；\n * 任务2 是计算B=20/5；\n * 任务3 是计算C=7*8；\n * 任务4 是显示最后计算的结果\n\n正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。\n\n如果采用多线程，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。\n\n通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能\n\n\n# 线程 VS 进程\n\n多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。那什么又是进程呢？\n\n一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。\n\n为了让你更好地理解上述计算过程，我画了下面这张对比图\n\n\n\n从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。\n\n总结来说，进程和线程之间的关系有以下4个特点\n\n1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。\n\n我们可以模拟以下场景：\n\nA = 1+2\nB = 20/0\nC = 7*8\n\n\n1\n2\n3\n\n\n我把上述三个表达式稍作修改，在计算B的值的时候，我把表达式的分母改成0，当线程执行到B = 20/0时，由于分母为0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了\n\n2. 线程之间共享进程中的数据。\n\n如下图所示，线程之间可以对进程的公共数据进行读写操作。\n\n\n\n从上图可以看出，线程1、线程2、线程3分别把执行的结果写入A、B、C中，然后线程2继续从A、B、C中读取数据，用来显示执行结果。\n\n3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。\n\n当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n\n比如之前的IE浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉\n\n4. 进程之间的内容相互隔离。\n\n进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程A写入数据到进程B的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。\n\n\n# 单进程浏览器时代\n\n在了解了进程和线程之后，我们再来一起看下单进程浏览器的架构。顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示\n\n\n\n如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。下面我就来一一分析下出现这些问题的原因\n\n问题1：不稳定\n\n早期浏览器需要借助于插件来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。\n\n除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的JavaScript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃\n\n问题2：不流畅\n\n从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。\n\n比如，下面这个无限循环的脚本：\n\nfunction freeze() {\n\twhile (1) {\n\t\tconsole.log("freeze");\n\t}\n}\nfreeze();\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果让这个脚本运行在一个单进程浏览器的页面里，你感觉会发生什么？\n\n因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。这块内容要继续往深的地方讲就到页面的事件循环系统了，具体相关内容我会在后面的模块中为你深入讲解。\n\n除了上述脚本或者插件会让单进程浏览器变卡顿外，页面的内存泄漏也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢\n\n问题3：不安全\n\n这里依然可以从插件和页面脚本两个方面来解释该原因。\n\n插件可以使用C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。\n\n至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。\n\n以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全。这是一段不堪回首的过去，也许你没有经历过，不过你可以想象一下这样的场景：当你正在用浏览器打开多个页面时，突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应，然后你发现你给老板写的邮件页面也随之消失了，这时你的心情会不会和页面一样崩溃呢\n\n\n# 多进程浏览器时代\n\n好在现代浏览器已经解决了这些问题，是如何解决的呢？这就得聊聊我们这个“多进程浏览器时代”了\n\n\n# 早期多进程架构\n\n你可以先看看下面这张图，这是2008年Chrome发布时的进程架构。\n\n\n\n从图中可以看出，Chrome的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过IPC机制进行通信（如图中虚线部分）。\n\n我们先看看如何解决不稳定的问题。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。\n\n接下来再来看看不流畅的问题是如何解决的。同样，JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在Chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。\n\n对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。\n\n最后我们再来看看上面的两个安全问题是怎么解决的。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。\n\n好了，分析完早期的Chrome浏览器后，相信你已经了解了浏览器采用多进程架构的必要性\n\n\n# 目前多进程架构\n\n不过Chrome的发展是滚滚向前的，相较之前，目前的架构又有了很多新的变化。我们先看看最新的Chrome进程架构，你可以参考下图\n\n\n\n从图中可以看出，最新的Chrome浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程\n\n下面我们来逐个分析下这几个进程的功能。\n\n浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU进程。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响 讲到这里，现在你应该就可以回答文章开头提到的问题了：仅仅打开了1个页面，为什么有4个进程？因为打开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。\n\n不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题\n\n更高的资源占用。因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这就意味着浏览器会消耗更多的内存资源。 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了 对于上面这两个问题，Chrome团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题\n\n\n# 未来面向服务的架构\n\n为了解决这些问题，在2016年，Chrome官方团队使用“面向服务的架构”（Services Oriented Architecture，简称SOA）的思想设计了新的Chrome架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过IPC来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。如果你对面向服务的架构感兴趣，你可以去网上搜索下资料，这里就不过多介绍了。\n\nChrome最终要把UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是Chrome“面向服务的架构”的进程模型图\n\n\n\n目前Chrome正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。\n\nChrome正在逐步构建Chrome基础服务（Chrome Foundation Service），如果你认为Chrome是“便携式操作系统”，那么Chrome基础服务便可以被视为该操作系统的“基础”系统服务层。\n\n同时Chrome还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome会将很多服务整合到一个进程中，从而节省内存占用。\n\n\n\n\n# 总结\n\n好了，今天就到这里，下面我来简要梳理并总结今天的内容。\n\n本文我主要是从Chrome进程架构的视角，分析了浏览器的进化史。\n\n最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后Chrome试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome的架构体系变得越来越复杂，这种架构的复杂性倒逼Chrome开发团队必须进行架构的重构，最终Chrome团队选择了面向服务架构（SOA）形式，这也是Chrome团队现阶段的一个主要任务。\n\n鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过Chrome开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到Chrome新的变化。\n\n总体说来，Chrome是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利',normalizedContent:'在开始之前，我们一起看下，chrome打开一个页面需要启动多少进程？你可以点击chrome浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开chrome的任务管理器的窗口，如下图\n\n\n\n和windows任务管理器一样，chrome任务管理器也是用来展示运行中chrome使用的进程信息的。从图中可以看到，chrome启动了4个进程，你也许会好奇，只是打开了1个页面，为什么要启动这么多进程呢？\n\n在解答这个问题之前，我们需要了解一下进程的概念，不过由于好多人容易把进程和线程的概念混淆，从而影响后续其他概念的理解，所以这里我就将这两个概念以及它们之间的关系一并为你讲解下。\n\n\n# 进程和线程\n\n不过，在介绍进程和线程之前，我需要先讲解下什么是并行处理，因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多\n\n\n# 什么是并行处理\n\n计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果\n\na = 1+2\nb = 20/5\nc = 7*8\n\n\n1\n2\n3\n\n\n在编写代码的时候，我们可以把这个过程拆分为四个任务：\n\n * 任务1 是计算a=1+2；\n * 任务2 是计算b=20/5；\n * 任务3 是计算c=7*8；\n * 任务4 是显示最后计算的结果\n\n正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。\n\n如果采用多线程，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。\n\n通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能\n\n\n# 线程 vs 进程\n\n多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。那什么又是进程呢？\n\n一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。\n\n为了让你更好地理解上述计算过程，我画了下面这张对比图\n\n\n\n从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。\n\n总结来说，进程和线程之间的关系有以下4个特点\n\n1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。\n\n我们可以模拟以下场景：\n\na = 1+2\nb = 20/0\nc = 7*8\n\n\n1\n2\n3\n\n\n我把上述三个表达式稍作修改，在计算b的值的时候，我把表达式的分母改成0，当线程执行到b = 20/0时，由于分母为0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了\n\n2. 线程之间共享进程中的数据。\n\n如下图所示，线程之间可以对进程的公共数据进行读写操作。\n\n\n\n从上图可以看出，线程1、线程2、线程3分别把执行的结果写入a、b、c中，然后线程2继续从a、b、c中读取数据，用来显示执行结果。\n\n3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。\n\n当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n\n比如之前的ie浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉\n\n4. 进程之间的内容相互隔离。\n\n进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程a写入数据到进程b的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（ipc）的机制了。\n\n\n# 单进程浏览器时代\n\n在了解了进程和线程之后，我们再来一起看下单进程浏览器的架构。顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、javascript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示\n\n\n\n如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。下面我就来一一分析下出现这些问题的原因\n\n问题1：不稳定\n\n早期浏览器需要借助于插件来实现诸如web视频、web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。\n\n除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的javascript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃\n\n问题2：不流畅\n\n从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、javascript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。\n\n比如，下面这个无限循环的脚本：\n\nfunction freeze() {\n\twhile (1) {\n\t\tconsole.log("freeze");\n\t}\n}\nfreeze();\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果让这个脚本运行在一个单进程浏览器的页面里，你感觉会发生什么？\n\n因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。这块内容要继续往深的地方讲就到页面的事件循环系统了，具体相关内容我会在后面的模块中为你深入讲解。\n\n除了上述脚本或者插件会让单进程浏览器变卡顿外，页面的内存泄漏也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢\n\n问题3：不安全\n\n这里依然可以从插件和页面脚本两个方面来解释该原因。\n\n插件可以使用c/c++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。\n\n至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。\n\n以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全。这是一段不堪回首的过去，也许你没有经历过，不过你可以想象一下这样的场景：当你正在用浏览器打开多个页面时，突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应，然后你发现你给老板写的邮件页面也随之消失了，这时你的心情会不会和页面一样崩溃呢\n\n\n# 多进程浏览器时代\n\n好在现代浏览器已经解决了这些问题，是如何解决的呢？这就得聊聊我们这个“多进程浏览器时代”了\n\n\n# 早期多进程架构\n\n你可以先看看下面这张图，这是2008年chrome发布时的进程架构。\n\n\n\n从图中可以看出，chrome的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过ipc机制进行通信（如图中虚线部分）。\n\n我们先看看如何解决不稳定的问题。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。\n\n接下来再来看看不流畅的问题是如何解决的。同样，javascript也是运行在渲染进程中的，所以即使javascript阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。\n\n对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。\n\n最后我们再来看看上面的两个安全问题是怎么解决的。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。\n\n好了，分析完早期的chrome浏览器后，相信你已经了解了浏览器采用多进程架构的必要性\n\n\n# 目前多进程架构\n\n不过chrome的发展是滚滚向前的，相较之前，目前的架构又有了很多新的变化。我们先看看最新的chrome进程架构，你可以参考下图\n\n\n\n从图中可以看出，最新的chrome浏览器包括：1个浏览器（browser）主进程、1个 gpu 进程、1个网络（network）进程、多个渲染进程和多个插件进程\n\n下面我们来逐个分析下这几个进程的功能。\n\n浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程。核心任务是将 html、css 和 javascript 转换为用户可以与之交互的网页，排版引擎blink和javascript引擎v8都是运行在该进程中，默认情况下，chrome会为每个tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 gpu进程。其实，chrome刚开始发布的时候是没有gpu进程的。而gpu的使用初衷是为了实现3d css的效果，只是随后网页、chrome的ui界面都选择采用gpu来绘制，这使得gpu成为浏览器普遍的需求。最后，chrome在其多进程架构上也引入了gpu进程。 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响 讲到这里，现在你应该就可以回答文章开头提到的问题了：仅仅打开了1个页面，为什么有4个进程？因为打开1个页面至少需要1个网络进程、1个浏览器进程、1个gpu进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。\n\n不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题\n\n更高的资源占用。因为每个进程都会包含公共基础结构的副本（如javascript运行环境），这就意味着浏览器会消耗更多的内存资源。 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了 对于上面这两个问题，chrome团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题\n\n\n# 未来面向服务的架构\n\n为了解决这些问题，在2016年，chrome官方团队使用“面向服务的架构”（services oriented architecture，简称soa）的思想设计了新的chrome架构。也就是说 chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（service），每个服务（service）都可以在独立的进程中运行，访问服务（service）必须使用定义好的接口，通过ipc来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 chrome 简单、稳定、高速、安全的目标。如果你对面向服务的架构感兴趣，你可以去网上搜索下资料，这里就不过多介绍了。\n\nchrome最终要把ui、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是chrome“面向服务的架构”的进程模型图\n\n\n\n目前chrome正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。\n\nchrome正在逐步构建chrome基础服务（chrome foundation service），如果你认为chrome是“便携式操作系统”，那么chrome基础服务便可以被视为该操作系统的“基础”系统服务层。\n\n同时chrome还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），chrome会将很多服务整合到一个进程中，从而节省内存占用。\n\n\n\n\n# 总结\n\n好了，今天就到这里，下面我来简要梳理并总结今天的内容。\n\n本文我主要是从chrome进程架构的视角，分析了浏览器的进化史。\n\n最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后chrome试图应用到更多业务场景，如移动设备、vr、视频等，为了支持这些场景，chrome的架构体系变得越来越复杂，这种架构的复杂性倒逼chrome开发团队必须进行架构的重构，最终chrome团队选择了面向服务架构（soa）形式，这也是chrome团队现阶段的一个主要任务。\n\n鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过chrome开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到chrome新的变化。\n\n总体说来，chrome是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利',charsets:{cjk:!0},lastUpdated:"2022/04/04, 00:54:06",lastUpdatedTimestamp:1649004846e3},{title:"test",frontmatter:{title:"test",date:"2022-03-03T14:49:40.000Z",permalink:"/pages/c78068/",categories:["网络","HTTP"],tags:["网络"]},regularPath:"/02.%E7%BD%91%E7%BB%9C/20.HTTP/01.test.html",relativePath:"02.网络/20.HTTP/01.test.md",key:"v-acb4ec08",path:"/pages/c78068/",headersStr:null,content:"# test\n\n11 22",normalizedContent:"# test\n\n11 22",charsets:{},lastUpdated:"2022/03/04, 02:35:02",lastUpdatedTimestamp:1646332502e3},{title:"http缓存",frontmatter:{title:"http缓存",date:"2022-03-22T10:33:07.000Z",permalink:"/pages/fef14d/",categories:["网络","HTTP"],tags:["网络","HTTP"]},regularPath:"/02.%E7%BD%91%E7%BB%9C/20.HTTP/10.http%E7%BC%93%E5%AD%98.html",relativePath:"02.网络/20.HTTP/10.http缓存.md",key:"v-c3cad6c0",path:"/pages/fef14d/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/24, 10:44:26",lastUpdatedTimestamp:1648089866e3},{title:"index",frontmatter:{title:"index",date:"2022-03-04T16:39:55.000Z",permalink:"/pages/87eaf1/",categories:["leetcode","序言"],tags:[null]},regularPath:"/03.%E7%AE%97%E6%B3%95/0.%E5%BA%8F%E8%A8%80/0.index.html",relativePath:"03.算法/0.序言/0.index.md",key:"v-73d54d6b",path:"/pages/87eaf1/",headers:[{level:2,title:"四步分析法",slug:"四步分析法",normalizedTitle:"四步分析法",charIndex:2}],headersStr:"四步分析法",content:"# 四步分析法\n\n 1. 模拟：模拟题目的运行。\n 2. 规律：尝试总结出题目的一般规律和特点。\n 3. 匹配：找到符合这些特点的数据结构与算法。\n 4. 边界：考虑特殊情况。",normalizedContent:"# 四步分析法\n\n 1. 模拟：模拟题目的运行。\n 2. 规律：尝试总结出题目的一般规律和特点。\n 3. 匹配：找到符合这些特点的数据结构与算法。\n 4. 边界：考虑特殊情况。",charsets:{cjk:!0},lastUpdated:"2022/03/07, 23:12:50",lastUpdatedTimestamp:164666597e4},{title:"判断字符串括号是否合法",frontmatter:{title:"判断字符串括号是否合法",date:"2022-03-04T17:01:57.000Z",permalink:"/pages/7796ac/",categories:["leetcode","栈"],tags:["算法","栈"]},regularPath:"/03.%E7%AE%97%E6%B3%95/10.%E6%A0%88/1.%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%AC%E5%8F%B7%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95.html",relativePath:"03.算法/10.栈/1.判断字符串括号是否合法.md",key:"v-707e3d4d",path:"/pages/7796ac/",headers:[{level:2,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:2},{level:3,title:"规律",slug:"规律",normalizedTitle:"规律",charIndex:97},{level:3,title:"边界",slug:"边界",normalizedTitle:"边界",charIndex:201},{level:3,title:"JS代码实现",slug:"js代码实现",normalizedTitle:"js代码实现",charIndex:268},{level:3,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:976},{level:3,title:"深度扩展",slug:"深度扩展",normalizedTitle:"深度扩展",charIndex:1050},{level:3,title:"广度优化",slug:"广度优化",normalizedTitle:"广度优化",charIndex:2011}],headersStr:"题目 规律 边界 JS代码实现 复杂度分析 深度扩展 广度优化",content:'# 题目\n\n\n字符串中只有字符\'(\'和\')\'。合法字符串需要括号可以配对。比如\n\n输入："()"\n\n输出：true\n\n：()，()()，(())是合法的。)(，()(，(()是非法的。\n\n\n# 规律\n\n（1）每个左括号\'(\'或者右括号\')\'都完成配对，才是合法的。\n\n（2）配对可以通过消除法来消掉合法的括号，如果最后没有任何字符了，那么就是合法字符串。\n\n（3）奇数长度的字符串总是非法的。\n\n\n# 边界\n\n * 字符串为空\n\n * 字符串只有 1 个或者奇数个\n\n * 字符串是"(((())))"嵌套很多层的是否可以处理\n\n\n# JS代码实现\n\nfunction isValid(s) {\n  // 处理边界\n  if (!s) {\n    return false;\n  }\n  const len = s.length;\n  if (len % 2 === 1) {\n    // 长度为奇数，不可能是一个有效的合法字符\n    return false;\n  }\n  // 消除法的主要核心逻辑:\n  const stack = [];\n  const isEmpty = () => stack.length === 0;\n  for (let i = 0; i < len; i++) {\n    const item = s[i];\n    if (item === "(") {\n      // 入栈\n      stack.push(item);\n    } else if (item === ")") {\n      if (isEmpty()) {\n        // 出栈失败\n        return false;\n      }\n      // 出栈\n      stack.pop();\n    }\n  }\n\n  return isEmpty();\n}\n\n// test\nconsole.log(isValid("()()(())"));\nconsole.log(isValid("()()(()"));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 复杂度分析\n\n每个字符只入栈一次，出栈一次，所以时间复杂度为 O(N)，而空间复杂度为 O(N)，因为最差情况下可能会把整个字符串都入栈。\n\n\n# 深度扩展\n\n栈中元素都相同时，实际上没有必要使用栈，只需要记录栈中元素个数\n\n/*****\n * ** =========== 深度优化 ==========\n * 栈中相邻的内容相同引入计数，这样就可以不用入栈了，减少内存消耗\n * ***********/\nfunction isValid_deep(s) {\n  // 处理边界\n  if (!s) {\n    return false;\n  }\n  const len = s.length;\n  if (len % 2 === 1) {\n    // 长度为奇数，不可能是一个有效的合法字符\n    return false;\n  }\n  // 消除法的主要核心逻辑:\n  let leftBraceNum = 0; // 记录相邻相同的内容个数\n  const isEmpty = () => leftBraceNum === 0;\n  for (let i = 0; i < len; i++) {\n    const item = s[i];\n    if (item === "(") {\n      // 如果是\'(\'，那么压栈\n      leftBraceNum++;\n    } else if (item === ")") {\n      // 如果是\')\'，那么就尝试弹栈\n      if (isEmpty()) {\n        // 如果弹栈失败，那么返回false\n        return false;\n      }\n      // 出栈\n      leftBraceNum--;\n    }\n  }\n\n  return isEmpty();\n}\n\nconsole.log("==== isValid_deep ====");\nconsole.log(isValid_deep("()()(())"));\nconsole.log(isValid_deep("()()(()"));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 广度优化\n\n栈中只存放了一个维度的信息：左括号\'(\'和右括号\')\'。如果栈中的内容变得更加丰富一点，就可以得到下面这道扩展题。\n\n有效括号\n\n/*****\n * ** =========== 广度优化 ==========\n * 引入不同的元素\n * ***********/\nfunction isValid_width(s) {\n  // 处理边界\n  if (!s) {\n    return false;\n  }\n  const len = s.length;\n  if (len % 2 === 1) {\n    // 长度为奇数，不可能是一个有效的合法字符\n    return false;\n  }\n  // 消除法的主要核心逻辑:\n  const stack = [];\n  const isEmpty = () => stack.length === 0;\n  for (let i = 0; i < len; i++) {\n    const item = s[i];\n    if (item === "(" || item === "{" || item === "[") {\n      // 入栈\n      stack.push(item);\n    } else if (item === ")") {\n      // 出栈\n      const result = stack.pop();\n      if (!result || result !== "(") {\n        return false;\n      }\n    } else if (item === "}") {\n      // 出栈\n      const result = stack.pop();\n      if (!result || result !== "{") {\n        return false;\n      }\n    } else if (item === "]") {\n      // 出栈\n      const result = stack.pop();\n      if (!result || result !== "[") {\n        return false;\n      }\n    }\n  }\n\n  return isEmpty();\n}\n\nconsole.log("==== isValid_width ====");\nconsole.log(isValid_width("()()(())({{[]}}[])"));\nconsole.log(isValid_width("()()(()"));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n',normalizedContent:'# 题目\n\n\n字符串中只有字符\'(\'和\')\'。合法字符串需要括号可以配对。比如\n\n输入："()"\n\n输出：true\n\n：()，()()，(())是合法的。)(，()(，(()是非法的。\n\n\n# 规律\n\n（1）每个左括号\'(\'或者右括号\')\'都完成配对，才是合法的。\n\n（2）配对可以通过消除法来消掉合法的括号，如果最后没有任何字符了，那么就是合法字符串。\n\n（3）奇数长度的字符串总是非法的。\n\n\n# 边界\n\n * 字符串为空\n\n * 字符串只有 1 个或者奇数个\n\n * 字符串是"(((())))"嵌套很多层的是否可以处理\n\n\n# js代码实现\n\nfunction isvalid(s) {\n  // 处理边界\n  if (!s) {\n    return false;\n  }\n  const len = s.length;\n  if (len % 2 === 1) {\n    // 长度为奇数，不可能是一个有效的合法字符\n    return false;\n  }\n  // 消除法的主要核心逻辑:\n  const stack = [];\n  const isempty = () => stack.length === 0;\n  for (let i = 0; i < len; i++) {\n    const item = s[i];\n    if (item === "(") {\n      // 入栈\n      stack.push(item);\n    } else if (item === ")") {\n      if (isempty()) {\n        // 出栈失败\n        return false;\n      }\n      // 出栈\n      stack.pop();\n    }\n  }\n\n  return isempty();\n}\n\n// test\nconsole.log(isvalid("()()(())"));\nconsole.log(isvalid("()()(()"));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 复杂度分析\n\n每个字符只入栈一次，出栈一次，所以时间复杂度为 o(n)，而空间复杂度为 o(n)，因为最差情况下可能会把整个字符串都入栈。\n\n\n# 深度扩展\n\n栈中元素都相同时，实际上没有必要使用栈，只需要记录栈中元素个数\n\n/*****\n * ** =========== 深度优化 ==========\n * 栈中相邻的内容相同引入计数，这样就可以不用入栈了，减少内存消耗\n * ***********/\nfunction isvalid_deep(s) {\n  // 处理边界\n  if (!s) {\n    return false;\n  }\n  const len = s.length;\n  if (len % 2 === 1) {\n    // 长度为奇数，不可能是一个有效的合法字符\n    return false;\n  }\n  // 消除法的主要核心逻辑:\n  let leftbracenum = 0; // 记录相邻相同的内容个数\n  const isempty = () => leftbracenum === 0;\n  for (let i = 0; i < len; i++) {\n    const item = s[i];\n    if (item === "(") {\n      // 如果是\'(\'，那么压栈\n      leftbracenum++;\n    } else if (item === ")") {\n      // 如果是\')\'，那么就尝试弹栈\n      if (isempty()) {\n        // 如果弹栈失败，那么返回false\n        return false;\n      }\n      // 出栈\n      leftbracenum--;\n    }\n  }\n\n  return isempty();\n}\n\nconsole.log("==== isvalid_deep ====");\nconsole.log(isvalid_deep("()()(())"));\nconsole.log(isvalid_deep("()()(()"));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 广度优化\n\n栈中只存放了一个维度的信息：左括号\'(\'和右括号\')\'。如果栈中的内容变得更加丰富一点，就可以得到下面这道扩展题。\n\n有效括号\n\n/*****\n * ** =========== 广度优化 ==========\n * 引入不同的元素\n * ***********/\nfunction isvalid_width(s) {\n  // 处理边界\n  if (!s) {\n    return false;\n  }\n  const len = s.length;\n  if (len % 2 === 1) {\n    // 长度为奇数，不可能是一个有效的合法字符\n    return false;\n  }\n  // 消除法的主要核心逻辑:\n  const stack = [];\n  const isempty = () => stack.length === 0;\n  for (let i = 0; i < len; i++) {\n    const item = s[i];\n    if (item === "(" || item === "{" || item === "[") {\n      // 入栈\n      stack.push(item);\n    } else if (item === ")") {\n      // 出栈\n      const result = stack.pop();\n      if (!result || result !== "(") {\n        return false;\n      }\n    } else if (item === "}") {\n      // 出栈\n      const result = stack.pop();\n      if (!result || result !== "{") {\n        return false;\n      }\n    } else if (item === "]") {\n      // 出栈\n      const result = stack.pop();\n      if (!result || result !== "[") {\n        return false;\n      }\n    }\n  }\n\n  return isempty();\n}\n\nconsole.log("==== isvalid_width ====");\nconsole.log(isvalid_width("()()(())({{[]}}[])"));\nconsole.log(isvalid_width("()()(()"));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n',charsets:{cjk:!0},lastUpdated:"2022/03/20, 14:13:17",lastUpdatedTimestamp:1647756797e3},{title:"二叉树的前序遍历",frontmatter:{title:"二叉树的前序遍历",date:"2022-03-20T14:32:20.000Z",permalink:"/pages/f79bac/",categories:["算法","栈"],tags:["算法","栈"]},regularPath:"/03.%E7%AE%97%E6%B3%95/10.%E6%A0%88/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.html",relativePath:"03.算法/10.栈/144. 二叉树的前序遍历.md",key:"v-15fef6fe",path:"/pages/f79bac/",headers:[{level:2,title:"理解二叉树的前序遍历",slug:"理解二叉树的前序遍历",normalizedTitle:"理解二叉树的前序遍历",charIndex:35},{level:2,title:"解答",slug:"解答",normalizedTitle:"解答",charIndex:135},{level:3,title:"1.模拟",slug:"_1-模拟",normalizedTitle:"1.模拟",charIndex:142},{level:3,title:"2.规律",slug:"_2-规律",normalizedTitle:"2.规律",charIndex:378},{level:3,title:"3.匹配",slug:"_3-匹配",normalizedTitle:"3.匹配",charIndex:396},{level:3,title:"4.边界",slug:"_4-边界",normalizedTitle:"4.边界",charIndex:421},{level:3,title:"JS实现",slug:"js实现",normalizedTitle:"js实现",charIndex:447}],headersStr:"理解二叉树的前序遍历 解答 1.模拟 2.规律 3.匹配 4.边界 JS实现",content:'给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\n\n\n# 理解二叉树的前序遍历\n\n二叉树的前序遍历的记忆法则是“根左右"，即先遍历根节点，再遍历左子树节点，再遍历右子树节点。\n\n例子：\n\n前序遍历的结果是：【A, B, D, E, C, F, G】\n\n\n# 解答\n\n\n# 1.模拟\n\n二叉树前序遍历是“根左右"，那么结果就是：A -> B -> D -> E -> C -> F -> G\n\n模拟过程应该是：\n\n * B -> D -> E 当作整体 B;\n * C -> F -> G当作整体 C;\n * A -> B -> C 当作整体 A\n\n先是跟节点A，然后是左子树B，B有子节点，继续处理B的子树D、E。\n\n左子树B都处理完后，就处理右子树C的子树F、G。\n\n把每个树当作一个整体，如果有子树，则记录父树结果，并且消除子树。\n\n\n# 2.规律\n\n子树会消除父树\n\n\n# 3.匹配\n\n遇到匹配就应该想到栈数据结构\n\n\n# 4.边界\n\n根节点为空，直接返回一个空数组\n\n\n# JS实现\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nfunction preorderTraversal (root) {\n  const result = []\n\n  // 边界\n  if(!root) return result\n\n  const stack = []\n  stack.push(root)\n\n  while(stack.length) {\n    const {val, left, right} = stack.pop()\n    if(val) result.push(val)\n    if(right) stack.push(right) // 先入 子右树\n    if(left) stack.push(left) // 后入 子左数\n  }\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nleetcode: 二叉树的前序遍历',normalizedContent:'给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\n\n\n# 理解二叉树的前序遍历\n\n二叉树的前序遍历的记忆法则是“根左右"，即先遍历根节点，再遍历左子树节点，再遍历右子树节点。\n\n例子：\n\n前序遍历的结果是：【a, b, d, e, c, f, g】\n\n\n# 解答\n\n\n# 1.模拟\n\n二叉树前序遍历是“根左右"，那么结果就是：a -> b -> d -> e -> c -> f -> g\n\n模拟过程应该是：\n\n * b -> d -> e 当作整体 b;\n * c -> f -> g当作整体 c;\n * a -> b -> c 当作整体 a\n\n先是跟节点a，然后是左子树b，b有子节点，继续处理b的子树d、e。\n\n左子树b都处理完后，就处理右子树c的子树f、g。\n\n把每个树当作一个整体，如果有子树，则记录父树结果，并且消除子树。\n\n\n# 2.规律\n\n子树会消除父树\n\n\n# 3.匹配\n\n遇到匹配就应该想到栈数据结构\n\n\n# 4.边界\n\n根节点为空，直接返回一个空数组\n\n\n# js实现\n\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {number[]}\n */\nfunction preordertraversal (root) {\n  const result = []\n\n  // 边界\n  if(!root) return result\n\n  const stack = []\n  stack.push(root)\n\n  while(stack.length) {\n    const {val, left, right} = stack.pop()\n    if(val) result.push(val)\n    if(right) stack.push(right) // 先入 子右树\n    if(left) stack.push(left) // 后入 子左数\n  }\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nleetcode: 二叉树的前序遍历',charsets:{cjk:!0},lastUpdated:"2022/03/20, 17:41:53",lastUpdatedTimestamp:1647769313e3},{title:"二叉树的后序遍历",frontmatter:{title:"二叉树的后序遍历",date:"2022-03-20T17:43:39.000Z",permalink:"/pages/cc00cd/",categories:["算法","栈"],tags:["算法","栈"]},regularPath:"/03.%E7%AE%97%E6%B3%95/10.%E6%A0%88/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.html",relativePath:"03.算法/10.栈/145. 二叉树的后序遍历.md",key:"v-4ced6830",path:"/pages/cc00cd/",headers:[{level:2,title:"理解二叉树的后序遍历",slug:"理解二叉树的后序遍历",normalizedTitle:"理解二叉树的后序遍历",charIndex:2},{level:2,title:"解答",slug:"解答",normalizedTitle:"解答",charIndex:102},{level:3,title:"1.模拟",slug:"_1-模拟",normalizedTitle:"1.模拟",charIndex:109}],headersStr:"理解二叉树的后序遍历 解答 1.模拟",content:'# 理解二叉树的后序遍历\n\n二叉树的后序遍历的记忆法则是“左右根"，即先遍历左子树节点，再遍历右子树节点，最后遍历根节点\n\n例子：\n\n后序遍历的结果是:【D, E, B, F, G, C, A】\n\n\n# 解答\n\n\n# 1.模拟\n\n二叉树前序遍历是“左右根"，那么结果就是：【D, E, B, F, G, C, A】\n\n模拟过程应该是：\n\n * B -> D -> E 当作整体 B;\n * C -> F -> G当作整体 C;\n * A -> B -> C 当作整体 A\n\nfunction postorderTraversal(root) {\n  const result = []\n\n  if(!root) return result\n\n  const stack = []\n  let pre = null\n  while(root || stack.length) {\n    while(root) {\n      stack.push(root)\n      root = root.left\n    }\n    const now = stack.pop()\n\n    if(now.right === null || now.right === pre) {\n      result.push(now.val)\n      pre = now\n      root = null\n    } else {\n      stack.push(root)\n      root = root.right\n    }\n  }\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n',normalizedContent:'# 理解二叉树的后序遍历\n\n二叉树的后序遍历的记忆法则是“左右根"，即先遍历左子树节点，再遍历右子树节点，最后遍历根节点\n\n例子：\n\n后序遍历的结果是:【d, e, b, f, g, c, a】\n\n\n# 解答\n\n\n# 1.模拟\n\n二叉树前序遍历是“左右根"，那么结果就是：【d, e, b, f, g, c, a】\n\n模拟过程应该是：\n\n * b -> d -> e 当作整体 b;\n * c -> f -> g当作整体 c;\n * a -> b -> c 当作整体 a\n\nfunction postordertraversal(root) {\n  const result = []\n\n  if(!root) return result\n\n  const stack = []\n  let pre = null\n  while(root || stack.length) {\n    while(root) {\n      stack.push(root)\n      root = root.left\n    }\n    const now = stack.pop()\n\n    if(now.right === null || now.right === pre) {\n      result.push(now.val)\n      pre = now\n      root = null\n    } else {\n      stack.push(root)\n      root = root.right\n    }\n  }\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n',charsets:{cjk:!0},lastUpdated:"2022/03/20, 20:03:32",lastUpdatedTimestamp:1647777812e3},{title:"大鱼吃小鱼",frontmatter:{title:"大鱼吃小鱼",date:"2022-03-07T16:50:52.000Z",permalink:"/pages/0255ab/",categories:["leetcode","栈"],tags:["算法","栈"]},regularPath:"/03.%E7%AE%97%E6%B3%95/10.%E6%A0%88/2.%E5%A4%A7%E9%B1%BC%E5%90%83%E5%B0%8F%E9%B1%BC.html",relativePath:"03.算法/10.栈/2.大鱼吃小鱼.md",key:"v-3f867205",path:"/pages/0255ab/",headers:[{level:2,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:2},{level:3,title:"分析",slug:"分析",normalizedTitle:"分析",charIndex:295},{level:3,title:"规律",slug:"规律",normalizedTitle:"规律",charIndex:387},{level:3,title:"边界",slug:"边界",normalizedTitle:"边界",charIndex:437},{level:3,title:"JS代码实现",slug:"js代码实现",normalizedTitle:"js代码实现",charIndex:480},{level:3,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:2919}],headersStr:"题目 分析 规律 边界 JS代码实现 复杂度分析",content:'# 题目\n\n\n在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i 条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件:\n 1. 所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离；\n 2. 当方向相对时，大鱼会吃掉小鱼；\n 3. 鱼的大小都不一样。\n\n输入：Size = [4, 2, 5, 3, 1], Dir = [1, 1, 0, 0, 0]\n\n输出：3\n\n请完成以下接口来计算还剩下几条鱼？\n\n\n# 分析\n\n大鱼吃掉小鱼的时候，可以认为是一种消除行为。只不过与括号匹配时的行为不一样：\n\n * 括号匹配是会同时把左括号与右括号消除掉；\n\n * 大鱼吃小鱼，只会把小鱼消除掉。\n\n\n# 规律\n\n * 如果两条鱼相对而游时，那么较小的鱼会被吃掉；\n\n * 其他情况没有鱼被吃掉。\n\n\n# 边界\n\n * 所有的鱼都朝着一个方向游；\n\n * 一条鱼吃掉了其他的所有鱼。\n\n\n# JS代码实现\n\n# 栈中存放内容\n\n/***\n * 大鱼吃小鱼\n *\n * 栈中存放内容\n */\nfunction solution(fishSize, fishDirection) {\n  // 如果鱼的数量小于等于1，那么直接返回鱼的数量\n  const len = fishSize.length;\n  if (len <= 1) {\n    return len;\n  }\n\n  const stack = [],\n    left = 0, // 0表示鱼向左游\n    right = 1; // 1表示鱼向右游\n  let direction = fishDirection[0]; // 栈中鱼的方向，栈中只有一个方法，相反方向的鱼，大鱼会打小鱼吃掉\n\n  for (let i = 0; i < len; i++) {\n    // 当前鱼的情况：1，游动的方向；2，大小\n    const curFishDirection = fishDirection[i];\n    const curFishSize = fishSize[i];\n    // 当前的鱼是否被栈中的鱼吃掉了\n    let hasEat = false;\n    while (stack.length && curFishDirection !== direction) {\n      const last = stack[stack.length - 1];\n      if (last < curFishSize) {\n        stack.pop();\n      } else {\n        hasEat = true;\n        break;\n      }\n    }\n\n    if (stack.length === 0) {\n      direction = curFishDirection;\n    }\n\n    if (!hasEat) {\n      stack.push(curFishSize);\n    }\n  }\n\n  return stack.length;\n}\n\n// test\nconsole.log("=== solution ====");\nconsole.log(solution([4, 2, 5, 3, 1], [1, 1, 0, 0, 0]));\nconsole.log(solution([4, 2, 5, 3, 1], [0, 1, 0, 0, 0]));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n# 栈中存放索引\n\n/***\n * 大鱼吃小鱼\n *\n * 栈中存放索引\n */\nfunction solution_index(fishSize, fishDirection) {\n  // 如果鱼的数量小于等于1，那么直接返回鱼的数量\n  const len = fishSize.length;\n  if (len <= 1) {\n    return len;\n  }\n\n  const stack = [],\n    left = 0, // 0表示鱼向左游\n    right = 1; // 1表示鱼向右游\n  let direction = fishDirection[0]; // 栈中鱼的方向，栈中只有一个方法，相反方向的鱼，大鱼会打小鱼吃掉\n\n  for (let i = 0; i < len; i++) {\n    // 当前鱼的情况：1，游动的方向；2，大小\n    const curFishDirection = fishDirection[i];\n    const curFishSize = fishSize[i];\n    // 当前的鱼是否被栈中的鱼吃掉了\n    let hasEat = false;\n    while (stack.length && curFishDirection !== direction) {\n      const last = stack[stack.length - 1];\n      if (fishSize[last] < curFishSize) {\n        stack.pop();\n      } else {\n        hasEat = true;\n        break;\n      }\n    }\n\n    if (stack.length === 0) {\n      direction = curFishDirection;\n    }\n\n    if (!hasEat) {\n      stack.push(i);\n    }\n  }\n\n  return stack.length;\n}\n\n// test\nconsole.log("=== solution_index ====");\nconsole.log(solution_index([4, 2, 5, 3, 1], [1, 1, 0, 0, 0]));\nconsole.log(solution_index([4, 2, 5, 3, 1], [0, 1, 0, 0, 0]));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 复杂度分析\n\n每只鱼只入栈一次，出栈一次，所以时间复杂度 为 O(N)，而空间复杂度为 O(N)，因为最差情况下可能把所有的鱼都入栈。',normalizedContent:'# 题目\n\n\n在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 size，dir，size[i] 表示第 i 条鱼的大小，dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件:\n 1. 所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离；\n 2. 当方向相对时，大鱼会吃掉小鱼；\n 3. 鱼的大小都不一样。\n\n输入：size = [4, 2, 5, 3, 1], dir = [1, 1, 0, 0, 0]\n\n输出：3\n\n请完成以下接口来计算还剩下几条鱼？\n\n\n# 分析\n\n大鱼吃掉小鱼的时候，可以认为是一种消除行为。只不过与括号匹配时的行为不一样：\n\n * 括号匹配是会同时把左括号与右括号消除掉；\n\n * 大鱼吃小鱼，只会把小鱼消除掉。\n\n\n# 规律\n\n * 如果两条鱼相对而游时，那么较小的鱼会被吃掉；\n\n * 其他情况没有鱼被吃掉。\n\n\n# 边界\n\n * 所有的鱼都朝着一个方向游；\n\n * 一条鱼吃掉了其他的所有鱼。\n\n\n# js代码实现\n\n# 栈中存放内容\n\n/***\n * 大鱼吃小鱼\n *\n * 栈中存放内容\n */\nfunction solution(fishsize, fishdirection) {\n  // 如果鱼的数量小于等于1，那么直接返回鱼的数量\n  const len = fishsize.length;\n  if (len <= 1) {\n    return len;\n  }\n\n  const stack = [],\n    left = 0, // 0表示鱼向左游\n    right = 1; // 1表示鱼向右游\n  let direction = fishdirection[0]; // 栈中鱼的方向，栈中只有一个方法，相反方向的鱼，大鱼会打小鱼吃掉\n\n  for (let i = 0; i < len; i++) {\n    // 当前鱼的情况：1，游动的方向；2，大小\n    const curfishdirection = fishdirection[i];\n    const curfishsize = fishsize[i];\n    // 当前的鱼是否被栈中的鱼吃掉了\n    let haseat = false;\n    while (stack.length && curfishdirection !== direction) {\n      const last = stack[stack.length - 1];\n      if (last < curfishsize) {\n        stack.pop();\n      } else {\n        haseat = true;\n        break;\n      }\n    }\n\n    if (stack.length === 0) {\n      direction = curfishdirection;\n    }\n\n    if (!haseat) {\n      stack.push(curfishsize);\n    }\n  }\n\n  return stack.length;\n}\n\n// test\nconsole.log("=== solution ====");\nconsole.log(solution([4, 2, 5, 3, 1], [1, 1, 0, 0, 0]));\nconsole.log(solution([4, 2, 5, 3, 1], [0, 1, 0, 0, 0]));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n# 栈中存放索引\n\n/***\n * 大鱼吃小鱼\n *\n * 栈中存放索引\n */\nfunction solution_index(fishsize, fishdirection) {\n  // 如果鱼的数量小于等于1，那么直接返回鱼的数量\n  const len = fishsize.length;\n  if (len <= 1) {\n    return len;\n  }\n\n  const stack = [],\n    left = 0, // 0表示鱼向左游\n    right = 1; // 1表示鱼向右游\n  let direction = fishdirection[0]; // 栈中鱼的方向，栈中只有一个方法，相反方向的鱼，大鱼会打小鱼吃掉\n\n  for (let i = 0; i < len; i++) {\n    // 当前鱼的情况：1，游动的方向；2，大小\n    const curfishdirection = fishdirection[i];\n    const curfishsize = fishsize[i];\n    // 当前的鱼是否被栈中的鱼吃掉了\n    let haseat = false;\n    while (stack.length && curfishdirection !== direction) {\n      const last = stack[stack.length - 1];\n      if (fishsize[last] < curfishsize) {\n        stack.pop();\n      } else {\n        haseat = true;\n        break;\n      }\n    }\n\n    if (stack.length === 0) {\n      direction = curfishdirection;\n    }\n\n    if (!haseat) {\n      stack.push(i);\n    }\n  }\n\n  return stack.length;\n}\n\n// test\nconsole.log("=== solution_index ====");\nconsole.log(solution_index([4, 2, 5, 3, 1], [1, 1, 0, 0, 0]));\nconsole.log(solution_index([4, 2, 5, 3, 1], [0, 1, 0, 0, 0]));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 复杂度分析\n\n每只鱼只入栈一次，出栈一次，所以时间复杂度 为 o(n)，而空间复杂度为 o(n)，因为最差情况下可能把所有的鱼都入栈。',charsets:{cjk:!0},lastUpdated:"2022/03/07, 23:12:50",lastUpdatedTimestamp:164666597e4},{title:"有效的括号",frontmatter:{title:"有效的括号",date:"2022-03-20T13:49:13.000Z",permalink:"/pages/c8d9ba/",categories:["算法","栈"],tags:["算法","栈"]},regularPath:"/03.%E7%AE%97%E6%B3%95/10.%E6%A0%88/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html",relativePath:"03.算法/10.栈/20.有效的括号.md",key:"v-61854e96",path:"/pages/c8d9ba/",headers:[{level:2,title:"解答",slug:"解答",normalizedTitle:"解答",charIndex:182}],headersStr:"解答",content:'给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n 1. 左括号必须用相同类型的右括号闭合。\n\n 2. 左括号必须以正确的顺序闭合。\n\n示例1：\n\n输入：s = "([)]"\n输出：false\n\n\n1\n2\n\n\n示例2：\n\n输入：s = "{[]}"\n输出：true\n\n\n1\n2\n\n\n\n# 解答\n\n如果你觉得题目太难，可以先理解判断字符串括号是否合法的完整解答，以及扩展知识。\n\n规律：配对消除。\n\n边界：\n\n * 字符串为空\n\n * 字符串为奇数个\n\nfunction isValid(s) {\n  // 处理边界\n  if (!s) {\n    return false;\n  }\n  const len = s.length;\n  if (len % 2 === 1) {\n    // 长度为奇数，不可能是一个有效的合法字符\n    return false;\n  }\n  // 消除法的主要核心逻辑:\n  const stack = [];\n  const isEmpty = () => stack.length === 0;\n  for (let i = 0; i < len; i++) {\n    const item = s[i];\n    if (item === "(" || item === "{" || item === "[") {\n      // 入栈\n      stack.push(item);\n    } else if (item === ")") {\n      // 出栈\n      const result = stack.pop();\n      if (!result || result !== "(") {\n        return false;\n      }\n    } else if (item === "}") {\n      // 出栈\n      const result = stack.pop();\n      if (!result || result !== "{") {\n        return false;\n      }\n    } else if (item === "]") {\n      // 出栈\n      const result = stack.pop();\n      if (!result || result !== "[") {\n        return false;\n      }\n    }\n  }\n\n  return isEmpty();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nleetcode: 有效括号',normalizedContent:'给定一个只包括 \'(\'，\')\'，\'{\'，\'}\'，\'[\'，\']\' 的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n 1. 左括号必须用相同类型的右括号闭合。\n\n 2. 左括号必须以正确的顺序闭合。\n\n示例1：\n\n输入：s = "([)]"\n输出：false\n\n\n1\n2\n\n\n示例2：\n\n输入：s = "{[]}"\n输出：true\n\n\n1\n2\n\n\n\n# 解答\n\n如果你觉得题目太难，可以先理解判断字符串括号是否合法的完整解答，以及扩展知识。\n\n规律：配对消除。\n\n边界：\n\n * 字符串为空\n\n * 字符串为奇数个\n\nfunction isvalid(s) {\n  // 处理边界\n  if (!s) {\n    return false;\n  }\n  const len = s.length;\n  if (len % 2 === 1) {\n    // 长度为奇数，不可能是一个有效的合法字符\n    return false;\n  }\n  // 消除法的主要核心逻辑:\n  const stack = [];\n  const isempty = () => stack.length === 0;\n  for (let i = 0; i < len; i++) {\n    const item = s[i];\n    if (item === "(" || item === "{" || item === "[") {\n      // 入栈\n      stack.push(item);\n    } else if (item === ")") {\n      // 出栈\n      const result = stack.pop();\n      if (!result || result !== "(") {\n        return false;\n      }\n    } else if (item === "}") {\n      // 出栈\n      const result = stack.pop();\n      if (!result || result !== "{") {\n        return false;\n      }\n    } else if (item === "]") {\n      // 出栈\n      const result = stack.pop();\n      if (!result || result !== "[") {\n        return false;\n      }\n    }\n  }\n\n  return isempty();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nleetcode: 有效括号',charsets:{cjk:!0},lastUpdated:"2022/03/20, 14:13:17",lastUpdatedTimestamp:1647756797e3},{title:"找出数组中右边比我小的元素",frontmatter:{title:"找出数组中右边比我小的元素",date:"2022-03-07T18:11:52.000Z",permalink:"/pages/26a51f/",categories:["leetcode","栈"],tags:["算法","单调栈"]},regularPath:"/03.%E7%AE%97%E6%B3%95/10.%E6%A0%88/3.%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%B3%E8%BE%B9%E6%AF%94%E6%88%91%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0.html",relativePath:"03.算法/10.栈/3.找出数组中右边比我小的元素.md",key:"v-ecddd03c",path:"/pages/26a51f/",headers:[{level:2,title:"找出数组中右边比我小的元素",slug:"找出数组中右边比我小的元素",normalizedTitle:"找出数组中右边比我小的元素",charIndex:2},{level:3,title:"例子",slug:"例子",normalizedTitle:"例子",charIndex:153},{level:3,title:"规律",slug:"规律",normalizedTitle:"规律",charIndex:187},{level:3,title:"模拟运行",slug:"模拟运行",normalizedTitle:"模拟运行",charIndex:423},{level:3,title:"JS代码实现",slug:"js代码实现",normalizedTitle:"js代码实现",charIndex:936},{level:3,title:"复杂度分析",slug:"复杂度分析",normalizedTitle:"复杂度分析",charIndex:1665},{level:2,title:"数组中右边第一个比我大的元素的位置",slug:"数组中右边第一个比我大的元素的位置",normalizedTitle:"数组中右边第一个比我大的元素的位置",charIndex:1738},{level:2,title:"数组中元素左边离我最近且比我小的元素的位置",slug:"数组中元素左边离我最近且比我小的元素的位置",normalizedTitle:"数组中元素左边离我最近且比我小的元素的位置",charIndex:2518},{level:2,title:"数组中元素左边离我最近且比我大的元素的位置",slug:"数组中元素左边离我最近且比我大的元素的位置",normalizedTitle:"数组中元素左边离我最近且比我大的元素的位置",charIndex:2544}],headersStr:"找出数组中右边比我小的元素 例子 规律 模拟运行 JS代码实现 复杂度分析 数组中右边第一个比我大的元素的位置 数组中元素左边离我最近且比我小的元素的位置 数组中元素左边离我最近且比我大的元素的位置",content:'# 找出数组中右边比我小的元素\n\n\n一个整数数组 A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。\n\n输入：[5, 2]\n\n输出：[1, -1]\n\n: 因为元素 5 的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。\n\n\n# 例子\n\n输入： [1, 2, 4, 9, 4, 0, 5]\n\n\n# 规律\n\n这里我们是照着题意去寻找一个右边比它小的数的下标。可以发现，A[4] = 4 及 A[5] = 0，这两个数字多次被用到。并且：\n\n * A[4] 发现有左边 A[3]，A[3] 就匹配成功；\n\n * 结合 A[5] = 0 的例子，我们发现它会把比它大的数都进行匹配成功，但是 A[3] 除外；\n\n * A[3] 可以认为是匹配成功之后，被 A[4]消除了。\n\n这时可以总结出：一个数总是想与左边比它大的数进行匹配，匹配到了之后，小的数会消除掉大的数。\n\n\n# 模拟运行\n\nStep 1. 首先将 A[0] = 1 的下标 0 入栈。\n\nStep 2. 将 A[1] = 2 的下标 1 入栈。满足单调栈。\n\nStep 3. 将 A[2] = 4 的下标 2 入栈。满足单调栈。\n\nStep 4. 将 A[3] = 9 的下标 3 入栈。满足单调栈。\n\nStep 5. 将 A[4] = 4 的下标 4 入栈时，不满足单调性，需要将 A[3] = 9 从栈中弹出去。下标 4 将栈中下标 3 弹出栈，记录 A[3] 右边更小的是 index = 4。\n\nStep 6. 将 A[5] = 0 的下标 5 入栈时，不满足单调性，需要将 A[4] = 4 从栈中弹出去。下标 5 将下标 4 弹出栈，记录 A[4] 右边更小的是 index = 5。A[5] = 0 会将栈中的下标 0, 1, 2 都弹出栈，因此也需要记录相应下标右边比其小的下标为 5，再将 A[5] = 0 的下标 5 放入栈中。\n\nStep 7. 将 A[6] = 5 的下标 6 放入栈中。满足单调性。\n\nStep 8. 此时，再也没有元素要入栈了，那么栈中的元素右边没有比其更小的元素。因此设置为 -1.\n\n\n# JS代码实现\n\nfunction findRightSmall(list) {\n  const result = [];\n  const stack = []; // 单调栈\n  const peek = () => stack[stack.length - 1]; // 取栈顶元素\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i];\n    while (stack.length && list[peek()] > item) {\n      // 消除的时候，记录一下被谁消除了\n      result[peek()] = i;\n      // 消除时候，值更大的需要从栈中消失\n      stack.pop();\n    }\n    stack.push(i);\n  }\n  // 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。\n  while (stack.length) {\n    result[peek()] = -1;\n    stack.pop();\n  }\n  return result;\n}\n\n// test\nconsole.log("=== findRightSmall ====");\nconsole.log(findRightSmall([5, 2]));\nconsole.log(findRightSmall([1, 2, 4, 9, 4, 0, 5]));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 复杂度分析\n\n每个元素只入栈一次，出栈一次，所以时间复杂度为 O(N)，而空间复杂度为 O(N)，因为最差情况可能会把所有的元素都入栈。\n\n\n# 数组中右边第一个比我大的元素的位置\n\n与 找出数组中右边比我小的元素 相比，只需要在栈弹出的时候，修改为栈顶元素小于当前元素即可。\n\nfunction findRightBig(list) {\n  const result = [];\n  const stack = []; // 单调栈\n  const peek = () => stack[stack.length - 1]; // 取栈顶元素\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i];\n    while (stack.length && list[peek()] < item) {\n      // 消除的时候，记录一下被谁消除了\n      result[peek()] = i;\n      // 消除时候，值更大的需要从栈中消失\n      stack.pop();\n    }\n    stack.push(i);\n  }\n  // 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。\n  while (stack.length) {\n    result[peek()] = -1;\n    stack.pop();\n  }\n  return result;\n}\n\n// test\nconsole.log("=== findRightBig ====");\nconsole.log(findRightBig([5, 2]));\nconsole.log(findRightBig([1, 2, 4, 9, 4, 0, 5]));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 数组中元素左边离我最近且比我小的元素的位置\n\n\n# 数组中元素左边离我最近且比我大的元素的位置',normalizedContent:'# 找出数组中右边比我小的元素\n\n\n一个整数数组 a，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。\n\n输入：[5, 2]\n\n输出：[1, -1]\n\n: 因为元素 5 的右边离我最近且比我小的位置应该是 a[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。\n\n\n# 例子\n\n输入： [1, 2, 4, 9, 4, 0, 5]\n\n\n# 规律\n\n这里我们是照着题意去寻找一个右边比它小的数的下标。可以发现，a[4] = 4 及 a[5] = 0，这两个数字多次被用到。并且：\n\n * a[4] 发现有左边 a[3]，a[3] 就匹配成功；\n\n * 结合 a[5] = 0 的例子，我们发现它会把比它大的数都进行匹配成功，但是 a[3] 除外；\n\n * a[3] 可以认为是匹配成功之后，被 a[4]消除了。\n\n这时可以总结出：一个数总是想与左边比它大的数进行匹配，匹配到了之后，小的数会消除掉大的数。\n\n\n# 模拟运行\n\nstep 1. 首先将 a[0] = 1 的下标 0 入栈。\n\nstep 2. 将 a[1] = 2 的下标 1 入栈。满足单调栈。\n\nstep 3. 将 a[2] = 4 的下标 2 入栈。满足单调栈。\n\nstep 4. 将 a[3] = 9 的下标 3 入栈。满足单调栈。\n\nstep 5. 将 a[4] = 4 的下标 4 入栈时，不满足单调性，需要将 a[3] = 9 从栈中弹出去。下标 4 将栈中下标 3 弹出栈，记录 a[3] 右边更小的是 index = 4。\n\nstep 6. 将 a[5] = 0 的下标 5 入栈时，不满足单调性，需要将 a[4] = 4 从栈中弹出去。下标 5 将下标 4 弹出栈，记录 a[4] 右边更小的是 index = 5。a[5] = 0 会将栈中的下标 0, 1, 2 都弹出栈，因此也需要记录相应下标右边比其小的下标为 5，再将 a[5] = 0 的下标 5 放入栈中。\n\nstep 7. 将 a[6] = 5 的下标 6 放入栈中。满足单调性。\n\nstep 8. 此时，再也没有元素要入栈了，那么栈中的元素右边没有比其更小的元素。因此设置为 -1.\n\n\n# js代码实现\n\nfunction findrightsmall(list) {\n  const result = [];\n  const stack = []; // 单调栈\n  const peek = () => stack[stack.length - 1]; // 取栈顶元素\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i];\n    while (stack.length && list[peek()] > item) {\n      // 消除的时候，记录一下被谁消除了\n      result[peek()] = i;\n      // 消除时候，值更大的需要从栈中消失\n      stack.pop();\n    }\n    stack.push(i);\n  }\n  // 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。\n  while (stack.length) {\n    result[peek()] = -1;\n    stack.pop();\n  }\n  return result;\n}\n\n// test\nconsole.log("=== findrightsmall ====");\nconsole.log(findrightsmall([5, 2]));\nconsole.log(findrightsmall([1, 2, 4, 9, 4, 0, 5]));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 复杂度分析\n\n每个元素只入栈一次，出栈一次，所以时间复杂度为 o(n)，而空间复杂度为 o(n)，因为最差情况可能会把所有的元素都入栈。\n\n\n# 数组中右边第一个比我大的元素的位置\n\n与 找出数组中右边比我小的元素 相比，只需要在栈弹出的时候，修改为栈顶元素小于当前元素即可。\n\nfunction findrightbig(list) {\n  const result = [];\n  const stack = []; // 单调栈\n  const peek = () => stack[stack.length - 1]; // 取栈顶元素\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i];\n    while (stack.length && list[peek()] < item) {\n      // 消除的时候，记录一下被谁消除了\n      result[peek()] = i;\n      // 消除时候，值更大的需要从栈中消失\n      stack.pop();\n    }\n    stack.push(i);\n  }\n  // 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。\n  while (stack.length) {\n    result[peek()] = -1;\n    stack.pop();\n  }\n  return result;\n}\n\n// test\nconsole.log("=== findrightbig ====");\nconsole.log(findrightbig([5, 2]));\nconsole.log(findrightbig([1, 2, 4, 9, 4, 0, 5]));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 数组中元素左边离我最近且比我小的元素的位置\n\n\n# 数组中元素左边离我最近且比我大的元素的位置',charsets:{cjk:!0},lastUpdated:"2022/03/07, 23:12:50",lastUpdatedTimestamp:164666597e4},{title:"二叉树的中序遍历",frontmatter:{title:"二叉树的中序遍历",date:"2022-03-20T16:07:14.000Z",permalink:"/pages/12f998/",categories:["算法","栈"],tags:["算法","栈"]},regularPath:"/03.%E7%AE%97%E6%B3%95/10.%E6%A0%88/94.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html",relativePath:"03.算法/10.栈/94. 二叉树的中序遍历.md",key:"v-d62bce2e",path:"/pages/12f998/",headers:[{level:2,title:"理解二叉树的中序遍历",slug:"理解二叉树的中序遍历",normalizedTitle:"理解二叉树的中序遍历",charIndex:34},{level:2,title:"解答",slug:"解答",normalizedTitle:"解答",charIndex:133},{level:3,title:"1.模拟",slug:"_1-模拟",normalizedTitle:"1.模拟",charIndex:140},{level:3,title:"2.规律",slug:"_2-规律",normalizedTitle:"2.规律",charIndex:387},{level:3,title:"3.匹配",slug:"_3-匹配",normalizedTitle:"3.匹配",charIndex:411},{level:3,title:"4.边界",slug:"_4-边界",normalizedTitle:"4.边界",charIndex:436},{level:3,title:"JS实现",slug:"js实现",normalizedTitle:"js实现",charIndex:462}],headersStr:"理解二叉树的中序遍历 解答 1.模拟 2.规律 3.匹配 4.边界 JS实现",content:'给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n\n\n# 理解二叉树的中序遍历\n\n二叉树的中序遍历的记忆法则是“左根右"，即先遍历左子树节点，再遍历根节点，再遍历右子树节点\n\n例子：\n\n前序遍历的结果是：【D, B, E, A, F, C, G】\n\n\n# 解答\n\n\n# 1.模拟\n\n二叉树中序遍历是“左根右"，那么结果就是：【D, B, E, A, F, C, G】\n\n模拟过程应该是：\n\n * B -> D -> E 当作整体 B;\n * C -> F -> G当作整体 C;\n * A -> B -> C 当作整体 A\n\n先是处理根节点的左子树B，B有子节点，则是处理B的左子树D，D没有子树，所以是 D, B, E\n\n处理完左子树B完后，就则就到了根节点A，然后是根节点右子树C,\n\nC节点有左子树E,则先处理F，然后是C节点，最好是C的右子树G。\n\n\n# 2.规律\n\n左子树被父树和右子树消除掉\n\n\n# 3.匹配\n\n遇到匹配就应该想到栈数据结构\n\n\n# 4.边界\n\n根节点为空，直接返回一个空数组\n\n\n# JS实现\n\nfunction inorderTraversal(root) {\n  const result = []\n\n  // 边界\n  if(!root) return result\n\n  const stack = []\n  \n  while(root || stack.length) {\n    // 一直找左节点，直到没有左节点为止\n    while(root) {\n      stack.push(root)\n      root = root.left\n    }\n    const now = stack.pop()\n    result.push(now.val)\n    \n    root = now.right // 处理右子节点\n  }\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nleetcode: 二叉树的中序遍历',normalizedContent:'给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n\n\n# 理解二叉树的中序遍历\n\n二叉树的中序遍历的记忆法则是“左根右"，即先遍历左子树节点，再遍历根节点，再遍历右子树节点\n\n例子：\n\n前序遍历的结果是：【d, b, e, a, f, c, g】\n\n\n# 解答\n\n\n# 1.模拟\n\n二叉树中序遍历是“左根右"，那么结果就是：【d, b, e, a, f, c, g】\n\n模拟过程应该是：\n\n * b -> d -> e 当作整体 b;\n * c -> f -> g当作整体 c;\n * a -> b -> c 当作整体 a\n\n先是处理根节点的左子树b，b有子节点，则是处理b的左子树d，d没有子树，所以是 d, b, e\n\n处理完左子树b完后，就则就到了根节点a，然后是根节点右子树c,\n\nc节点有左子树e,则先处理f，然后是c节点，最好是c的右子树g。\n\n\n# 2.规律\n\n左子树被父树和右子树消除掉\n\n\n# 3.匹配\n\n遇到匹配就应该想到栈数据结构\n\n\n# 4.边界\n\n根节点为空，直接返回一个空数组\n\n\n# js实现\n\nfunction inordertraversal(root) {\n  const result = []\n\n  // 边界\n  if(!root) return result\n\n  const stack = []\n  \n  while(root || stack.length) {\n    // 一直找左节点，直到没有左节点为止\n    while(root) {\n      stack.push(root)\n      root = root.left\n    }\n    const now = stack.pop()\n    result.push(now.val)\n    \n    root = now.right // 处理右子节点\n  }\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nleetcode: 二叉树的中序遍历',charsets:{cjk:!0},lastUpdated:"2022/03/20, 17:41:53",lastUpdatedTimestamp:1647769313e3},{title:"Array | 数组",frontmatter:{title:"Array | 数组",date:"2022-06-17T18:53:06.000Z",permalink:"/pages/8f6f25/",categories:["算法","数据结构"],tags:["算法","数据结构"]},regularPath:"/03.%E7%AE%97%E6%B3%95/5.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.Array.html",relativePath:"03.算法/5.数据结构/5.Array.md",key:"v-27bffdd9",path:"/pages/8f6f25/",headers:[{level:2,title:"高效率的读取",slug:"高效率的读取",normalizedTitle:"高效率的读取",charIndex:199},{level:2,title:"飘忽不定的新增",slug:"飘忽不定的新增",normalizedTitle:"飘忽不定的新增",charIndex:464},{level:2,title:"缓慢的删除",slug:"缓慢的删除",normalizedTitle:"缓慢的删除",charIndex:703},{level:2,title:"遍历修改",slug:"遍历修改",normalizedTitle:"遍历修改",charIndex:953},{level:2,title:"动态数组",slug:"动态数组",normalizedTitle:"动态数组",charIndex:1061},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1195}],headersStr:"高效率的读取 飘忽不定的新增 缓慢的删除 遍历修改 动态数组 总结",content:"# 序言\n\n如果你有过开发经验，数组对于你来说一定不陌生，因为大部分编程语言都内置了数组这种数据结构。\n\n对于一种数组结构，通常我们都会时间复杂度和空间复杂度来进行分析，进而来判断这个数组结构使用的是否合理。\n\n那么对于数组，为什么增加和删除的时候时间复杂度为 O(n) 呢，而读取的时候，时间复杂度为 O(1) 。\n\n如果你已经知道这个问题的答案，恭喜你，你已经掌握了数组这个数据结构。\n\n\n# 高效率的读取\n\n我们是利用下标来读取数组里的数据，比如：\n\nconst arr = ['a', 'b', 'c']\n// 读取\nconsole.log(arr[0])\nconsole.log(arr[1])\n\n\n1\n2\n3\n4\n\n\n假设 arr 数组起始地址为 0x00，那么第二个元素的地址为 0x01，第三个元素的地址为 0x03。\n\n在物理结构上，数组是连续性的。随机读取某个元素的时候，只需要执行简单的数学运算就知道了。\n\n数组读取的时候效果很高，时间复杂度为 O(1), 因为在数组里可以快速找到任何一个元素。\n\n\n# 飘忽不定的新增\n\n数组在创建的时候，大小是固定的，因为指定大小，才能知道分配多少内存空间。\n\n既然大小是固定的，数组不够用的时候，怎么办？对于这个问题，也许你会简单，不够就加呗！ 是的，计算机就是这么处理，对于数组内存超了的时候，需要进行扩容处理。\n\n每次新增元素的时候，判断内存空间够不够，如果不够，就申请一个更大的内存，然后把之前的元素都移动到新的内存里去。\n\n当内存足够的时候，往里添加数据即可，反之则要扩容。这就是为什么增加的时候，最坏时间复杂度为 O(n)。\n\n\n# 缓慢的删除\n\n有了扩容，相对于就有缩容，不能只增加，不减少，要不然申请了100M内存，但只存1k大小的元素，这不存粹浪费内存空间嘛！\n\n每次在删除元素的时候，就判断内存空间是否过于大，如果太大了，就申请一个更小的内存空间，然后把之前的元素移动到新内存里去。\n\n如果内存刚好呢,就需要把删除位置之后的元素往前移。因为如果只是删除元素，那么删除的位置就会空缺，就会带来两个问题：\n\n * 造成内存空间浪费\n * 读取的数据不对\n\n为了不浪费内存空间，数组删除的时候，最坏时间复杂度为 O(n)。\n\n\n# 遍历修改\n\n修改数组中某个元素的时候，需要经过两个步骤。\n\n 1. 遍历找到要修改元素的索引。\n 2. 根据索引获取元素，然后进行替换操作。\n\n因为需要遍历，所以数组修改的时候，最坏时间复杂度为 O(n)。\n\n\n# 动态数组\n\n上面我们讲到数组长度是固定，增加和删除的还需要考虑内存问题。有没有办法让我们不考虑内存，只进行数组操作。这种数组叫做动态数组。但其本质上并改变数组性质，只能自动帮住我们解决了内存问题。是的，你想的没有错，JavaScript里的数组就是动态数组。\n\n\n# 总结\n\n数组是一块连续的内存空间，在创建的时候就确定了大小。\n\n数组的优点是读取效率高，时间复杂度为 O(1)。\n\n缺点是新增、修改、删除的效率低，时间复杂度为 O(n)。",normalizedContent:"# 序言\n\n如果你有过开发经验，数组对于你来说一定不陌生，因为大部分编程语言都内置了数组这种数据结构。\n\n对于一种数组结构，通常我们都会时间复杂度和空间复杂度来进行分析，进而来判断这个数组结构使用的是否合理。\n\n那么对于数组，为什么增加和删除的时候时间复杂度为 o(n) 呢，而读取的时候，时间复杂度为 o(1) 。\n\n如果你已经知道这个问题的答案，恭喜你，你已经掌握了数组这个数据结构。\n\n\n# 高效率的读取\n\n我们是利用下标来读取数组里的数据，比如：\n\nconst arr = ['a', 'b', 'c']\n// 读取\nconsole.log(arr[0])\nconsole.log(arr[1])\n\n\n1\n2\n3\n4\n\n\n假设 arr 数组起始地址为 0x00，那么第二个元素的地址为 0x01，第三个元素的地址为 0x03。\n\n在物理结构上，数组是连续性的。随机读取某个元素的时候，只需要执行简单的数学运算就知道了。\n\n数组读取的时候效果很高，时间复杂度为 o(1), 因为在数组里可以快速找到任何一个元素。\n\n\n# 飘忽不定的新增\n\n数组在创建的时候，大小是固定的，因为指定大小，才能知道分配多少内存空间。\n\n既然大小是固定的，数组不够用的时候，怎么办？对于这个问题，也许你会简单，不够就加呗！ 是的，计算机就是这么处理，对于数组内存超了的时候，需要进行扩容处理。\n\n每次新增元素的时候，判断内存空间够不够，如果不够，就申请一个更大的内存，然后把之前的元素都移动到新的内存里去。\n\n当内存足够的时候，往里添加数据即可，反之则要扩容。这就是为什么增加的时候，最坏时间复杂度为 o(n)。\n\n\n# 缓慢的删除\n\n有了扩容，相对于就有缩容，不能只增加，不减少，要不然申请了100m内存，但只存1k大小的元素，这不存粹浪费内存空间嘛！\n\n每次在删除元素的时候，就判断内存空间是否过于大，如果太大了，就申请一个更小的内存空间，然后把之前的元素移动到新内存里去。\n\n如果内存刚好呢,就需要把删除位置之后的元素往前移。因为如果只是删除元素，那么删除的位置就会空缺，就会带来两个问题：\n\n * 造成内存空间浪费\n * 读取的数据不对\n\n为了不浪费内存空间，数组删除的时候，最坏时间复杂度为 o(n)。\n\n\n# 遍历修改\n\n修改数组中某个元素的时候，需要经过两个步骤。\n\n 1. 遍历找到要修改元素的索引。\n 2. 根据索引获取元素，然后进行替换操作。\n\n因为需要遍历，所以数组修改的时候，最坏时间复杂度为 o(n)。\n\n\n# 动态数组\n\n上面我们讲到数组长度是固定，增加和删除的还需要考虑内存问题。有没有办法让我们不考虑内存，只进行数组操作。这种数组叫做动态数组。但其本质上并改变数组性质，只能自动帮住我们解决了内存问题。是的，你想的没有错，javascript里的数组就是动态数组。\n\n\n# 总结\n\n数组是一块连续的内存空间，在创建的时候就确定了大小。\n\n数组的优点是读取效率高，时间复杂度为 o(1)。\n\n缺点是新增、修改、删除的效率低，时间复杂度为 o(n)。",charsets:{cjk:!0},lastUpdated:"2022/06/22, 12:18:14",lastUpdatedTimestamp:1655871494e3},{title:"数据结构导论",frontmatter:{title:"数据结构导论",date:"2022-06-23T11:44:55.000Z",permalink:"/pages/5eb93d/",categories:["算法","数据结构笔记"],tags:["算法","数据结构"]},regularPath:"/03.%E7%AE%97%E6%B3%95/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/5.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E8%AE%BA.html",relativePath:"03.算法/7.数据结构笔记/5.数据结构导论.md",key:"v-f9d0d0b6",path:"/pages/5eb93d/",headers:[{level:2,title:"计算",slug:"计算",normalizedTitle:"计算",charIndex:9},{level:3,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:5},{level:2,title:"计算模型",slug:"计算模型",normalizedTitle:"计算模型",charIndex:304}],headersStr:"计算 算法 计算模型",content:"数据结构和算法作为计算机的基石，而自己是自学计算机的，对于计算机缺乏系统的知识。 因此为了让自己在计算机行业走的更远，系统化学习数据结构这门课程。\n\n课程资料来源：邓俊辉\n\n\n# 计算\n\n我们研究计算，研究对象是规律、技巧，研究目标是高效、低耗。\n\n计算可以看作整个计算机科学的研究对象内容和目的。\n\n计算例子：\n\n 1. 绳索计算机\n\n\n\n 2. 尺规计算机\n\n\n\n计算：借助某种工具，遵照一定规则，以明确而机械的形式进行。\n\n\n# 算法\n\n\n\n有穷性示例：Hailstone序列\n\n什么是好的算法？\n\n站在计算机角度来说就看效率，也就是速度尽可能快，存储空间尽可能少，正好和研究计算的目标吻合。\n\n\n# 计算模型\n\n计算模型 = 计算机 = 信息处理工具",normalizedContent:"数据结构和算法作为计算机的基石，而自己是自学计算机的，对于计算机缺乏系统的知识。 因此为了让自己在计算机行业走的更远，系统化学习数据结构这门课程。\n\n课程资料来源：邓俊辉\n\n\n# 计算\n\n我们研究计算，研究对象是规律、技巧，研究目标是高效、低耗。\n\n计算可以看作整个计算机科学的研究对象内容和目的。\n\n计算例子：\n\n 1. 绳索计算机\n\n\n\n 2. 尺规计算机\n\n\n\n计算：借助某种工具，遵照一定规则，以明确而机械的形式进行。\n\n\n# 算法\n\n\n\n有穷性示例：hailstone序列\n\n什么是好的算法？\n\n站在计算机角度来说就看效率，也就是速度尽可能快，存储空间尽可能少，正好和研究计算的目标吻合。\n\n\n# 计算模型\n\n计算模型 = 计算机 = 信息处理工具",charsets:{cjk:!0},lastUpdated:"2022/06/23, 21:18:38",lastUpdatedTimestamp:1655990318e3},{title:"🦉观察者与发布订阅模式",frontmatter:{title:"🦉观察者与发布订阅模式",date:"2022-03-07T20:54:07.000Z",permalink:"/pages/73d23b/",categories:["设计模式","行为型模式"],tags:["设计模式","行为型模式"]},regularPath:"/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06.%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/10.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"04.设计模式/06.行为型模式/10.观察者模式.md",key:"v-64b2788e",path:"/pages/73d23b/",headers:[{level:2,title:"😂观察者模式",slug:"😂观察者模式",normalizedTitle:"😂观察者模式",charIndex:24},{level:3,title:"😀定义",slug:"😀定义",normalizedTitle:"😀定义",charIndex:36},{level:3,title:"😁JS模拟实现",slug:"😁js模拟实现",normalizedTitle:"😁js模拟实现",charIndex:368},{level:2,title:"🤣发布订阅",slug:"🤣发布订阅",normalizedTitle:"🤣发布订阅",charIndex:822},{level:3,title:"😃JS代码模拟实现",slug:"😃js代码模拟实现",normalizedTitle:"😃js代码模拟实现",charIndex:1025},{level:2,title:"😅区别",slug:"😅区别",normalizedTitle:"😅区别",charIndex:1873},{level:3,title:"😶理解解耦",slug:"😶理解解耦",normalizedTitle:"😶理解解耦",charIndex:1954}],headersStr:"😂观察者模式 😀定义 😁JS模拟实现 🤣发布订阅 😃JS代码模拟实现 😅区别 😶理解解耦",content:"设计模式就像武功一样，无他，惟手熟尔。\n\n\n# 😂观察者模式\n\n\n# 😀定义\n\n观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n\n对象间存在一对多关系。\n\n * 观察者(订阅者) –Watcher\n   \n   * updata()当事件发生时,具体要做的事情\n\n * 发布者 –Dep\n   \n   * subs数组存储所有的观察者\n   \n   * addSub()添加观察者\n   \n   * notify当事件发生,循环所有subs中的观察者的updata方法\n\n * 没有事件中心(没有按事件分类,全部存储在一级数组中)\n   \n   * 没有事件中心(没有按事件分类,全部存储在一级数组中)\n   \n   * 发布者和订阅者，则完全不存在耦合\n\n\n# 😁JS模拟实现\n\n//发布者\nclass Dep {\n  constructor () {\n    this.subs = []\n  }\n  addSub = (sub) => {\n    if(sub && sub.updata){\n      this.subs.push(sub)\n    }\n  }\n  notify = () => {\n    this.subs.forEach((element)=>{\n      element.updata()\n    })\n  }\n}\n\n//观察者\nclass watch {\n  updata = () => {\n    console.log('观察者')\n  }\n}\n\nconst dep = new Dep()\ndep.addSub (new watch())\ndep.notify()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 🤣发布订阅\n\n> 在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。\n\n完成订阅发布整个流程需要三个角色：\n\n * 发布者\n * 事件中心\n * 订阅者\n\n\n# 😃JS代码模拟实现\n\nclass Event {\n  constructor() {\n    // 所有 eventType 监听器回调函数（数组）\n    this.listeners = {}\n  }\n  /**\n   * 订阅事件\n   * @param {String} eventType 事件类型\n   * @param {Function} listener 订阅后发布动作触发的回调函数，参数为发布的数据\n   */\n  on(eventType, listener) {\n    if (!this.listeners[eventType]) {\n      this.listeners[eventType] = []\n    }\n    this.listeners[eventType].push(listener)\n  }\n  /**\n   * 发布事件\n   * @param {String} eventType 事件类型\n   * @param {Any} data 发布的内容\n   */\n  emit(eventType, data) {\n    const callbacks = this.listeners[eventType]\n    if (callbacks) {\n      callbacks.forEach((c) => {\n        c(data)\n      })\n    }\n  }\n}\n\nconst event = new Event()\nevent.on('open', (data) => {\n  console.log(data)\n})\nevent.emit('open', { open: true })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 😅区别\n\n一图总结:\n\n这两者模式，本质并还是一样的，都是对象间存在一对多关系。但发布订阅引入了事件中心，正是这个改进，解决了观察者模式的解解耦问题。\n\n\n# 😶理解解耦\n\n观察者模式 在添加观察者之前，需要 new watch，也就是说需要知道观察者对象。\n\n而发布订阅者不需要，只需要订阅事件即可。",normalizedContent:"设计模式就像武功一样，无他，惟手熟尔。\n\n\n# 😂观察者模式\n\n\n# 😀定义\n\n观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n\n对象间存在一对多关系。\n\n * 观察者(订阅者) –watcher\n   \n   * updata()当事件发生时,具体要做的事情\n\n * 发布者 –dep\n   \n   * subs数组存储所有的观察者\n   \n   * addsub()添加观察者\n   \n   * notify当事件发生,循环所有subs中的观察者的updata方法\n\n * 没有事件中心(没有按事件分类,全部存储在一级数组中)\n   \n   * 没有事件中心(没有按事件分类,全部存储在一级数组中)\n   \n   * 发布者和订阅者，则完全不存在耦合\n\n\n# 😁js模拟实现\n\n//发布者\nclass dep {\n  constructor () {\n    this.subs = []\n  }\n  addsub = (sub) => {\n    if(sub && sub.updata){\n      this.subs.push(sub)\n    }\n  }\n  notify = () => {\n    this.subs.foreach((element)=>{\n      element.updata()\n    })\n  }\n}\n\n//观察者\nclass watch {\n  updata = () => {\n    console.log('观察者')\n  }\n}\n\nconst dep = new dep()\ndep.addsub (new watch())\ndep.notify()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 🤣发布订阅\n\n> 在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。\n\n完成订阅发布整个流程需要三个角色：\n\n * 发布者\n * 事件中心\n * 订阅者\n\n\n# 😃js代码模拟实现\n\nclass event {\n  constructor() {\n    // 所有 eventtype 监听器回调函数（数组）\n    this.listeners = {}\n  }\n  /**\n   * 订阅事件\n   * @param {string} eventtype 事件类型\n   * @param {function} listener 订阅后发布动作触发的回调函数，参数为发布的数据\n   */\n  on(eventtype, listener) {\n    if (!this.listeners[eventtype]) {\n      this.listeners[eventtype] = []\n    }\n    this.listeners[eventtype].push(listener)\n  }\n  /**\n   * 发布事件\n   * @param {string} eventtype 事件类型\n   * @param {any} data 发布的内容\n   */\n  emit(eventtype, data) {\n    const callbacks = this.listeners[eventtype]\n    if (callbacks) {\n      callbacks.foreach((c) => {\n        c(data)\n      })\n    }\n  }\n}\n\nconst event = new event()\nevent.on('open', (data) => {\n  console.log(data)\n})\nevent.emit('open', { open: true })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 😅区别\n\n一图总结:\n\n这两者模式，本质并还是一样的，都是对象间存在一对多关系。但发布订阅引入了事件中心，正是这个改进，解决了观察者模式的解解耦问题。\n\n\n# 😶理解解耦\n\n观察者模式 在添加观察者之前，需要 new watch，也就是说需要知道观察者对象。\n\n而发布订阅者不需要，只需要订阅事件即可。",charsets:{cjk:!0},lastUpdated:"2022/03/07, 23:12:50",lastUpdatedTimestamp:164666597e4},{title:"Array",frontmatter:{title:"Array",date:"2022-03-31T08:16:01.000Z",permalink:"/pages/978afe/",categories:["npm","awesome-micro-npm-packages"],tags:["npm","数组"]},regularPath:"/05.npm/10.awesome-micro/10.Array.html",relativePath:"05.npm/10.awesome-micro/10.Array.md",key:"v-228b074f",path:"/pages/978afe/",headers:[{level:2,title:"is-sorted",slug:"is-sorted",normalizedTitle:"is-sorted",charIndex:2},{level:3,title:"检查数组是否有排序",slug:"检查数组是否有排序",normalizedTitle:"检查数组是否有排序",charIndex:16},{level:2,title:"array-first",slug:"array-first",normalizedTitle:"array-first",charIndex:539},{level:3,title:"获取数组的第一个元素或开始的第n个元素",slug:"获取数组的第一个元素或开始的第n个元素",normalizedTitle:"获取数组的第一个元素或开始的第n个元素",charIndex:555},{level:2,title:"array-last",slug:"array-last",normalizedTitle:"array-last",charIndex:1358},{level:3,title:"获取数组的最后一个元素或最后 n 个元素",slug:"获取数组的最后一个元素或最后-n-个元素",normalizedTitle:"获取数组的最后一个元素或最后 n 个元素",charIndex:1373},{level:2,title:"arr-flatten",slug:"arr-flatten",normalizedTitle:"arr-flatten",charIndex:2169},{level:3,title:"递归扁平化数组",slug:"递归扁平化数组",normalizedTitle:"递归扁平化数组",charIndex:2185},{level:2,title:"dedupe",slug:"dedupe",normalizedTitle:"dedupe",charIndex:2608},{level:3,title:"数组去重",slug:"数组去重",normalizedTitle:"数组去重",charIndex:2619},{level:2,title:"array-range",slug:"array-range",normalizedTitle:"array-range",charIndex:3221},{level:3,title:"创建具有给定范围的新数组.",slug:"创建具有给定范围的新数组",normalizedTitle:"创建具有给定范围的新数组.",charIndex:3237},{level:2,title:"array-differ",slug:"array-differ",normalizedTitle:"array-differ",charIndex:4010},{level:3,title:"取第一个数组的差集",slug:"取第一个数组的差集",normalizedTitle:"取第一个数组的差集",charIndex:4027},{level:2,title:"filled-array",slug:"filled-array",normalizedTitle:"filled-array",charIndex:4303},{level:3,title:"返回填充了指定输入的数组",slug:"返回填充了指定输入的数组",normalizedTitle:"返回填充了指定输入的数组",charIndex:4320},{level:2,title:"map-array",slug:"map-array",normalizedTitle:"map-array",charIndex:5185},{level:3,title:"将对象键和值映射到数组中",slug:"将对象键和值映射到数组中",normalizedTitle:"将对象键和值映射到数组中",charIndex:5199},{level:2,title:"in-array",slug:"in-array",normalizedTitle:"in-array",charIndex:5720},{level:3,title:"判断数组中是否存在元素",slug:"判断数组中是否存在元素",normalizedTitle:"判断数组中是否存在元素",charIndex:5733},{level:2,title:"unordered-array-remove",slug:"unordered-array-remove",normalizedTitle:"unordered-array-remove",charIndex:6077},{level:3,title:"删除数组指定位置的元素",slug:"删除数组指定位置的元素",normalizedTitle:"删除数组指定位置的元素",charIndex:6104},{level:2,title:"array-swap",slug:"array-swap",normalizedTitle:"array-swap",charIndex:6455},{level:3,title:"在数组中交换两个值的位置",slug:"在数组中交换两个值的位置",normalizedTitle:"在数组中交换两个值的位置",charIndex:6470},{level:2,title:"mirrarray",slug:"mirrarray",normalizedTitle:"mirrarray",charIndex:7067},{level:3,title:"从有效key数组创建相同key的对象",slug:"从有效key数组创建相同key的对象",normalizedTitle:"从有效key数组创建相同key的对象",charIndex:7081},{level:2,title:"group-array",slug:"group-array",normalizedTitle:"group-array",charIndex:9060},{level:3,title:"将数组按照某种属性分类成对象",slug:"将数组按照某种属性分类成对象",normalizedTitle:"将数组按照某种属性分类成对象",charIndex:9076},{level:2,title:"array.chunk",slug:"array-chunk",normalizedTitle:"array.chunk",charIndex:12319}],headersStr:"is-sorted 检查数组是否有排序 array-first 获取数组的第一个元素或开始的第n个元素 array-last 获取数组的最后一个元素或最后 n 个元素 arr-flatten 递归扁平化数组 dedupe 数组去重 array-range 创建具有给定范围的新数组. array-differ 取第一个数组的差集 filled-array 返回填充了指定输入的数组 map-array 将对象键和值映射到数组中 in-array 判断数组中是否存在元素 unordered-array-remove 删除数组指定位置的元素 array-swap 在数组中交换两个值的位置 mirrarray 从有效key数组创建相同key的对象 group-array 将数组按照某种属性分类成对象 array.chunk",content:"# is-sorted\n\n\n# 检查数组是否有排序\n\n来自 github\n\n// 默认排序操作函数\nfunction defaultComparator (a, b) {\n  return a - b\n}\n\nmodule.exports = function checksort (array, comparator) {\n  // 判断第一个参数是否为数组\n  if (!Array.isArray(array)) throw new TypeError('Expected Array, got ' + (typeof array))\n  // 处理排序函数\n  comparator = comparator || defaultComparator\n\n  // 遍历数组，进行比对\n  for (var i = 1, length = array.length; i < length; ++i) {\n    if (comparator(array[i - 1], array[i]) > 0) return false\n  }\n\n  return true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# array-first\n\n\n# 获取数组的第一个元素或开始的第n个元素\n\n来自 github\n\narray-first 依赖两个包：is-number、array-slice\n\nvar isNumber = require('is-number');\nvar slice = require('array-slice');\n\nmodule.exports = function arrayFirst(arr, num) {\n  // 判断第一个参数是否为数组\n  if (!Array.isArray(arr)) {\n    throw new Error('array-first expects an array as the first argument.');\n  }\n  // 如果数组为空，直接返回null\n  if (arr.length === 0) {\n    return null;\n  }\n  // 这里 作者引入 is-number包是2.1.0版本，截至目前为止（2022/3/31）是7.0.0\n  // 所以这里 处理会存在一些判断 ，目前来看是没有必要的，但当时情景与现在是不一样的\n\n  // 如果 num 是number，则 取 +md，反之取 1\n  // 然后 通过 slice 截取arr数组\n  var first = slice(arr, 0, isNumber(num) ? +num : 1);\n  // +num === 1, 则返回 first[0],否则返回截取的结果\n  if (+num === 1 || num == null) {\n    return first[0];\n  }\n  \n  return first;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# array-last\n\n\n# 获取数组的最后一个元素或最后 n 个元素\n\n来自 github\n\nvar isNumber = require('is-number');\n\nmodule.exports = function last(arr, n) {\n  // 判断第一个参数是否为数组\n  if (!Array.isArray(arr)) {\n    throw new Error('expected the first argument to be an array');\n  }\n\n  // 如果数组为空，直接返回null\n  var len = arr.length;\n  if (len === 0) {\n    return null;\n  }\n\n  // 处理第二个可选参数\n  // 如果number，则取 +n，否则取1\n  n = isNumber(n) ? +n : 1;\n  if (n === 1) {\n    // 当n为1，表示只取最后一个元素\n    return arr[len - 1];\n  }\n\n  // 作者这里巧妙利用n来获取数组最后n个元素\n  // 先是 声明一个长度为n的数组，此时数组里每个元素为undefined\n  // 然后 利用 while循环，每次循环n就减少一次，然后把arr索引n位置的元素复制给res索引n，直到n为结束循环。\n\n  // 此处换成for循环也是一样可以实现的。\n  var res = new Array(n);\n  while (n--) {\n    res[n] = arr[--len];\n  }\n  return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# arr-flatten\n\n\n# 递归扁平化数组\n\n来自 github\n\narr-flatten 实现了 ES6 flat 功能\n\n// 采用递归思路实现\nmodule.exports = function (arr) {\n  // 传入空数组，缓存结果\n  return flat(arr, []);\n};\n\nfunction flat(arr, res) {\n  var i = 0, cur;\n  var len = arr.length;\n  for (; i < len; i++) {\n    cur = arr[i];\n    // 如果是数组，就递归调用自己，否则就push到res数组。\n    Array.isArray(cur) ? flat(cur, res) : res.push(cur);\n  }\n  // 扁平化数组\n  return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# dedupe\n\n\n# 数组去重\n\n来自 github\n\nfunction dedupe (client, hasher) {\n  // 处理选填参数：默认JSON.stringify，系列化之后，就可以比对数组，对象。\n  hasher = hasher || JSON.stringify\n\n  const clone = []\n  const lookup = {} \n\n  for (let i = 0; i < client.length; i++) {\n      let elem = client[i]\n      let hashed = hasher(elem)\n\n      // 如果 lookup 没有，则push到clone里，并往lookup添加这个记录\n      if (!lookup[hashed]) {\n          clone.push(elem)\n          lookup[hashed] = true\n      }\n  }\n\n  return clone\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如果只是简单去重基本数据类型，用Set数据结构，就很容易实现。但如果要去重对象，Set就不行了。因为即使对象里的内容是一致的，但是引用地址不一样，Set就会当作是两个不一样的元素来处理。\n\n\n# array-range\n\n\n# 创建具有给定范围的新数组.\n\n来自 github\n\narrary-range 与实现了 slice 大部分功能。\n\nfunction newArray(start, end) {\n  // 这里很巧妙，只关注参数是否为number类型\n  var n0 = typeof start === 'number',\n      n1 = typeof end === 'number'\n\n  // 只接受了一个参数\n  if (n0 && !n1) {\n      end = start\n      start = 0\n  } else if (!n0 && !n1) {\n    // 两个参数都没有，或者两个参数都不是number类型\n      start = 0\n      end = 0\n  }\n  // 再次进行异常处理 start|0 表示，如果start 为false，则取0，否则取start\n  start = start|0\n  end = end|0\n  \n  // 处理end 小于 start 的情况\n  var len = end-start\n  if (len<0)\n      throw new Error('array length must be positive')\n  \n  // 从start 遍历到 end，把数组里的元素复制到数组a中\n  var a = new Array(len)\n  for (var i=0, c=start; i<len; i++, c++)\n      a[i] = c\n  return a\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# array-differ\n\n\n# 取第一个数组的差集\n\n(返回一个数组,该数组只存在来自第一个数组,通过严格相等进行比较的方式,来排除来自其他数组的所有值)\n\n来自 github\n\nexport default function arrayDiffer(array, ...values) {\n\tconst rest = new Set(values.flat());\n\treturn array.filter(element => !rest.has(element));\n}\n\n\n1\n2\n3\n4\n\n\n先扁平化剩余参数数组,然后转换成Set数据结构，最后过滤第一个参数数组。\n\n\n# filled-array\n\n\n# 返回填充了指定输入的数组\n\n来自 github\n\nexport default function filledArray(fillValue, count) {\n  // 判断输入的count是否为安全整数\n  // 安全整数范围为 -(2^53 - 1)到 2^53 - 1 之间的整数，包含 -(2^53 - 1)和 2^53 - 1\n\tif (!(Number.isSafeInteger(count) && count >= 0)) {\n\t\tthrow new TypeError(`Expected \\`count\\` to be a non-negative integer, got \\`${count}\\`.`);\n\t}\n\n  // 利用 伪数组对象 来创建一个 长度为 count 的数组\n\tconst returnValue = Array.from({length: count});\n\tconst isFunction = typeof fillValue === 'function';\n\n\tif (!isFunction) {\n    // 如果第一个参数 不是函数，数组里的每一项都填充为fillValue，并且返回该数组\n\t\treturn returnValue.fill(fillValue);\n\t}\n\n\tfor (let index = 0; index < count; index++) {\n    // 如果第一个参数是函数，则执行该函数，并把执行结果存储到数组\n\t\treturnValue[index] = fillValue(index, count, returnValue);\n\t}\n\n\treturn returnValue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n安全整数: isSafeInteger\n\n相对比 fill ,filled-array 扩展了自定义填充内容。\n\n\n# map-array\n\n\n# 将对象键和值映射到数组中\n\n来自 github\n\nmap-array 的依赖包：map-obj\n\nconst map = require('map-obj');\n\nfunction mapToArray(obj, fn) {\n  // 自增id，生成伪数组\n\tlet idx = 0;\n  // map 返回一个对象，键是 idex,值是 fn(key, value)\n  // eg: result = {0: value0, 1: value1, 2: value2}\n\tconst result = map(obj, (key, value) =>\n\t\t[idx++, fn(key, value)]\n\t);\n\tresult.length = idx;\n  // 把伪数组 转换成 数组\n\treturn Array.from(result);\n}\n\nmodule.exports = mapToArray;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nmap-array 处理与 filled-array 相似之处，先生成一个伪数组，然后通过 Array.from 把伪数组转换数组。\n\n\n# in-array\n\n\n# 判断数组中是否存在元素\n\n来自 github\n\nmodule.exports = function inArray (arr, val) {\n  // 处理 第一个参数\n  arr = arr || [];\n  var len = arr.length;\n  var i;\n\n  // 遍历数组\n  for (i = 0; i < len; i++) {\n    if (arr[i] === val) {\n      // 满足条件 直接返回 true\n      return true;\n    }\n  }\n  return false;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nin-array 模拟实现了 includes\n\n\n# unordered-array-remove\n\n\n# 删除数组指定位置的元素\n\n(删除元素的索引会被数组最后一个元素代替)\n\n来自 github\n\nfunction remove (arr, i) {\n  // 判断 索引是否在数组范围内\n  if (i >= arr.length || i < 0) return\n  // 删除数组最后一个元素\n  var last = arr.pop()\n  // 处理 数组只有一个元素的特殊情况\n  if (i < arr.length) {\n    var tmp = arr[i]\n    arr[i] = last\n    return tmp\n  }\n  return last\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n相对于 splice 时间复杂度伪O(1)\n\n\n# array-swap\n\n\n# 在数组中交换两个值的位置\n\n(不会更改元数组)\n\n来自 github\n\nexport default (Arr, Caller, Target) => {\n  let Instance = Arr.constructor();\n  let Stash = Arr;\n\n  let InstanceType = Array.isArray(Instance) ? 'array' : typeof Instance;\n\n  // 判断第一个参数类型，如果不是数组，就抛出异常 \n  if(InstanceType !== 'array') throw '[ERR] SwapArray expects a array as first param';\n\n  // 浅拷贝数组，这样就不会更改元素数组了。\n  Stash.map((s, i) => Instance[i] = s);\n\n  // 替换位置\n  // 此处应可以优化，splice 这个api时间复杂度伪O(n),O(1) 就可以实现这个功能\n  Instance[Caller] = Instance.splice(Target, 1, Instance[Caller])[0];\n\n  return Instance;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# mirrarray\n\n\n# 从有效key数组创建相同key的对象\n\n来自 github\n\nfunction MirrarrayError() {}\nMirrarrayError.prototype = Object.create(Error.prototype);\n\n// 判断 key 是否有效\n// typeof null 为 object,与对象结果相同，所以null需要单独处理\n// 有效类型key：string、number、boolean、undefined、null\nconst isValidKey = element => {\n  const isNull = element === null;\n  return ['string', 'number', 'boolean', 'undefined'].includes(typeof element) || isNull;\n}\n\nconst nonOverlappingKey = element => {\n  /**\n   * Ensure we don't have distinct elements that coerce to the same key, leading to unexpected results.\n   * For example, input of [true, 'true'] would return a keymirror of {true: 'true'} despite containing two distinct elements\n   * if we didn't make this check.\n   */\n  const isNull = element === null;\n  const typeSeenBefore = keysSeen['' + element];\n  // 获取 当前元素的类型\n  const thisType = isNull ? 'null' : typeof element;\n  if (typeSeenBefore) {\n    // 当 false 的时候，说明 他们 转换成 string是相同的，但他们原本是不同类型的值\n    return typeSeenBefore === thisType;\n  } else {\n    // 缓存当前元素\n    keysSeen['' + element] = thisType;\n    return true;\n  }\n}\n\nlet keysSeen;\n\nconst arrayToKeyMirror = arr => {\n  // keysSeen 赋值为空对象（作用域）\n  keysSeen = {};\n  // 判断参数类型，如果不是数组，就抛出异常\n  if (!Array.isArray(arr)) {\n    throw new MirrarrayError('Input to mirrarray must be an array!');\n  }\n  return arr.reduce((acc, key) => {\n    // 判断 key 是否为有效类型\n    if (!isValidKey(key)) {\n      throw new MirrarrayError('Invalid element contained within input array; each element must be either a string or number!');\n    }\n    // 处理 不同类型的值，但转为string后值相同特殊情况。例如：输入 [true, 'true']\n    if (!nonOverlappingKey(key)) {\n      throw new MirrarrayError('Distinct elements in the input array are coercing to the same string!');\n    }\n    acc[key] = key;\n    return acc;\n  }, {});\n};\n\nexport default arrayToKeyMirror;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n这里处理错误异常情况，不管命名还是代码实现都值得借鉴\n\n\n# group-array\n\n\n# 将数组按照某种属性分类成对象\n\n来自 github\n\n依赖包：\n\n * split-string\n * arr-flatten\n * union-value\n * for-own\n * kind-of\n * get-value\n\n入口函数：groupFn\n\nfunction groupFn(arr, props) {\n  // 如果 arr 是null，直接返回空数组\n  if (arr == null) {\n    return [];\n  }\n\n  // 确实 arr 是不是数组类型\n  if (!Array.isArray(arr)) {\n    throw new TypeError('group-array expects an array.');\n  }\n\n  // 数组长度为1，无需分类\n  if (arguments.length === 1) {\n    return arr;\n  }\n\n  // 边际情况处理完后，接下来就是处理参数\n  // 这里 可以es6 的剩余参数，\n  let args = flatten([].slice.call(arguments, 1));\n  // 处理 第二参数，通过 groupBy 进行分类\n  let groups = groupBy(arr, args[0]);\n\n  // 如果 参数个数超过了2个，就通过 toGroup 继续处理\n  // 这里有个技巧：为 i 是从 1开始，因为需要把处理后的 groups 返回，而groups是在处理第二个参数结束后赋值的。\n  // 处理 后面的参数，利用 指针，每次处理参数的结果继续存储 到 groups 中\n  for (let i = 1; i < args.length; i++) {\n    toGroup(groups, args[i]);\n  }\n  return groups;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\ntoGroup\n\nfunction toGroup(groups, prop) {\n  // 遍历对象上自身属性\n  forOwn(groups, (val, key) => {\n    // 如果不是 数组 类型，则继续调用自身，反之 通过 groupBy 进行分类\n    if (!Array.isArray(val)) {\n      groups[key] = toGroup(val, prop, key);\n    } else {\n      groups[key] = groupBy(val, prop, key);\n    }\n  });\n  return groups;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\ngroupBy\n\nfunction groupBy(arr, prop, key) {\n  let groups = {};\n\n  for (let i = 0; i < arr.length; i++) {\n    let obj = arr[i];\n    let val;\n\n    // allow a function to modify the object\n    // and/or return a val to use\n    if (typeof prop === 'function') {\n      val = prop.call(groups, obj, key);\n    } else {\n      val = get(obj, prop);\n    }\n\n    switch (typeOf(val)) {\n      case 'undefined':\n        break;\n      case 'string':\n      case 'number':\n      case 'boolean':\n        union(groups, escape(String(val)), obj);\n        break;\n      case 'object':\n      case 'array':\n        eachValue(groups, obj, val);\n        break;\n      case 'function':\n        throw new Error('invalid argument type: ' + key);\n    }\n  }\n  return groups;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n'use strict';\n\nconst split = require('split-string');\nconst flatten = require('arr-flatten');\nconst union = require('union-value');\nconst forOwn = require('for-own');\nconst typeOf = require('kind-of');\nconst get = require('get-value');\n\n// 入口函数\n\n\n\n\nfunction eachValue(groups, obj, val) {\n  if (Array.isArray(val)) {\n    val.forEach(key => {\n      union(groups, escape(key), obj);\n    });\n  } else {\n    forOwn(val, (v, key) => {\n      union(groups, escape(key), obj);\n    });\n  }\n}\n\nfunction toGroup(groups, prop) {\n  forOwn(groups, (val, key) => {\n    if (!Array.isArray(val)) {\n      groups[key] = toGroup(val, prop, key);\n    } else {\n      groups[key] = groupBy(val, prop, key);\n    }\n  });\n  return groups;\n}\n\nfunction escape(str) {\n  var opts = {\n    strict: false,\n    keepEscaping: true,\n    keepDoubleQuotes: true,\n    keepSingleQuotes: true\n  };\n\n  try {\n    return split(str, opts).join('\\\\.');\n  } catch (err) {\n    return str;\n  }\n}\n\n/**\n * Expose `groupArray`\n */\n\nmodule.exports = groupFn;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# array.chunk",normalizedContent:"# is-sorted\n\n\n# 检查数组是否有排序\n\n来自 github\n\n// 默认排序操作函数\nfunction defaultcomparator (a, b) {\n  return a - b\n}\n\nmodule.exports = function checksort (array, comparator) {\n  // 判断第一个参数是否为数组\n  if (!array.isarray(array)) throw new typeerror('expected array, got ' + (typeof array))\n  // 处理排序函数\n  comparator = comparator || defaultcomparator\n\n  // 遍历数组，进行比对\n  for (var i = 1, length = array.length; i < length; ++i) {\n    if (comparator(array[i - 1], array[i]) > 0) return false\n  }\n\n  return true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# array-first\n\n\n# 获取数组的第一个元素或开始的第n个元素\n\n来自 github\n\narray-first 依赖两个包：is-number、array-slice\n\nvar isnumber = require('is-number');\nvar slice = require('array-slice');\n\nmodule.exports = function arrayfirst(arr, num) {\n  // 判断第一个参数是否为数组\n  if (!array.isarray(arr)) {\n    throw new error('array-first expects an array as the first argument.');\n  }\n  // 如果数组为空，直接返回null\n  if (arr.length === 0) {\n    return null;\n  }\n  // 这里 作者引入 is-number包是2.1.0版本，截至目前为止（2022/3/31）是7.0.0\n  // 所以这里 处理会存在一些判断 ，目前来看是没有必要的，但当时情景与现在是不一样的\n\n  // 如果 num 是number，则 取 +md，反之取 1\n  // 然后 通过 slice 截取arr数组\n  var first = slice(arr, 0, isnumber(num) ? +num : 1);\n  // +num === 1, 则返回 first[0],否则返回截取的结果\n  if (+num === 1 || num == null) {\n    return first[0];\n  }\n  \n  return first;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# array-last\n\n\n# 获取数组的最后一个元素或最后 n 个元素\n\n来自 github\n\nvar isnumber = require('is-number');\n\nmodule.exports = function last(arr, n) {\n  // 判断第一个参数是否为数组\n  if (!array.isarray(arr)) {\n    throw new error('expected the first argument to be an array');\n  }\n\n  // 如果数组为空，直接返回null\n  var len = arr.length;\n  if (len === 0) {\n    return null;\n  }\n\n  // 处理第二个可选参数\n  // 如果number，则取 +n，否则取1\n  n = isnumber(n) ? +n : 1;\n  if (n === 1) {\n    // 当n为1，表示只取最后一个元素\n    return arr[len - 1];\n  }\n\n  // 作者这里巧妙利用n来获取数组最后n个元素\n  // 先是 声明一个长度为n的数组，此时数组里每个元素为undefined\n  // 然后 利用 while循环，每次循环n就减少一次，然后把arr索引n位置的元素复制给res索引n，直到n为结束循环。\n\n  // 此处换成for循环也是一样可以实现的。\n  var res = new array(n);\n  while (n--) {\n    res[n] = arr[--len];\n  }\n  return res;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# arr-flatten\n\n\n# 递归扁平化数组\n\n来自 github\n\narr-flatten 实现了 es6 flat 功能\n\n// 采用递归思路实现\nmodule.exports = function (arr) {\n  // 传入空数组，缓存结果\n  return flat(arr, []);\n};\n\nfunction flat(arr, res) {\n  var i = 0, cur;\n  var len = arr.length;\n  for (; i < len; i++) {\n    cur = arr[i];\n    // 如果是数组，就递归调用自己，否则就push到res数组。\n    array.isarray(cur) ? flat(cur, res) : res.push(cur);\n  }\n  // 扁平化数组\n  return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# dedupe\n\n\n# 数组去重\n\n来自 github\n\nfunction dedupe (client, hasher) {\n  // 处理选填参数：默认json.stringify，系列化之后，就可以比对数组，对象。\n  hasher = hasher || json.stringify\n\n  const clone = []\n  const lookup = {} \n\n  for (let i = 0; i < client.length; i++) {\n      let elem = client[i]\n      let hashed = hasher(elem)\n\n      // 如果 lookup 没有，则push到clone里，并往lookup添加这个记录\n      if (!lookup[hashed]) {\n          clone.push(elem)\n          lookup[hashed] = true\n      }\n  }\n\n  return clone\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如果只是简单去重基本数据类型，用set数据结构，就很容易实现。但如果要去重对象，set就不行了。因为即使对象里的内容是一致的，但是引用地址不一样，set就会当作是两个不一样的元素来处理。\n\n\n# array-range\n\n\n# 创建具有给定范围的新数组.\n\n来自 github\n\narrary-range 与实现了 slice 大部分功能。\n\nfunction newarray(start, end) {\n  // 这里很巧妙，只关注参数是否为number类型\n  var n0 = typeof start === 'number',\n      n1 = typeof end === 'number'\n\n  // 只接受了一个参数\n  if (n0 && !n1) {\n      end = start\n      start = 0\n  } else if (!n0 && !n1) {\n    // 两个参数都没有，或者两个参数都不是number类型\n      start = 0\n      end = 0\n  }\n  // 再次进行异常处理 start|0 表示，如果start 为false，则取0，否则取start\n  start = start|0\n  end = end|0\n  \n  // 处理end 小于 start 的情况\n  var len = end-start\n  if (len<0)\n      throw new error('array length must be positive')\n  \n  // 从start 遍历到 end，把数组里的元素复制到数组a中\n  var a = new array(len)\n  for (var i=0, c=start; i<len; i++, c++)\n      a[i] = c\n  return a\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# array-differ\n\n\n# 取第一个数组的差集\n\n(返回一个数组,该数组只存在来自第一个数组,通过严格相等进行比较的方式,来排除来自其他数组的所有值)\n\n来自 github\n\nexport default function arraydiffer(array, ...values) {\n\tconst rest = new set(values.flat());\n\treturn array.filter(element => !rest.has(element));\n}\n\n\n1\n2\n3\n4\n\n\n先扁平化剩余参数数组,然后转换成set数据结构，最后过滤第一个参数数组。\n\n\n# filled-array\n\n\n# 返回填充了指定输入的数组\n\n来自 github\n\nexport default function filledarray(fillvalue, count) {\n  // 判断输入的count是否为安全整数\n  // 安全整数范围为 -(2^53 - 1)到 2^53 - 1 之间的整数，包含 -(2^53 - 1)和 2^53 - 1\n\tif (!(number.issafeinteger(count) && count >= 0)) {\n\t\tthrow new typeerror(`expected \\`count\\` to be a non-negative integer, got \\`${count}\\`.`);\n\t}\n\n  // 利用 伪数组对象 来创建一个 长度为 count 的数组\n\tconst returnvalue = array.from({length: count});\n\tconst isfunction = typeof fillvalue === 'function';\n\n\tif (!isfunction) {\n    // 如果第一个参数 不是函数，数组里的每一项都填充为fillvalue，并且返回该数组\n\t\treturn returnvalue.fill(fillvalue);\n\t}\n\n\tfor (let index = 0; index < count; index++) {\n    // 如果第一个参数是函数，则执行该函数，并把执行结果存储到数组\n\t\treturnvalue[index] = fillvalue(index, count, returnvalue);\n\t}\n\n\treturn returnvalue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n安全整数: issafeinteger\n\n相对比 fill ,filled-array 扩展了自定义填充内容。\n\n\n# map-array\n\n\n# 将对象键和值映射到数组中\n\n来自 github\n\nmap-array 的依赖包：map-obj\n\nconst map = require('map-obj');\n\nfunction maptoarray(obj, fn) {\n  // 自增id，生成伪数组\n\tlet idx = 0;\n  // map 返回一个对象，键是 idex,值是 fn(key, value)\n  // eg: result = {0: value0, 1: value1, 2: value2}\n\tconst result = map(obj, (key, value) =>\n\t\t[idx++, fn(key, value)]\n\t);\n\tresult.length = idx;\n  // 把伪数组 转换成 数组\n\treturn array.from(result);\n}\n\nmodule.exports = maptoarray;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nmap-array 处理与 filled-array 相似之处，先生成一个伪数组，然后通过 array.from 把伪数组转换数组。\n\n\n# in-array\n\n\n# 判断数组中是否存在元素\n\n来自 github\n\nmodule.exports = function inarray (arr, val) {\n  // 处理 第一个参数\n  arr = arr || [];\n  var len = arr.length;\n  var i;\n\n  // 遍历数组\n  for (i = 0; i < len; i++) {\n    if (arr[i] === val) {\n      // 满足条件 直接返回 true\n      return true;\n    }\n  }\n  return false;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nin-array 模拟实现了 includes\n\n\n# unordered-array-remove\n\n\n# 删除数组指定位置的元素\n\n(删除元素的索引会被数组最后一个元素代替)\n\n来自 github\n\nfunction remove (arr, i) {\n  // 判断 索引是否在数组范围内\n  if (i >= arr.length || i < 0) return\n  // 删除数组最后一个元素\n  var last = arr.pop()\n  // 处理 数组只有一个元素的特殊情况\n  if (i < arr.length) {\n    var tmp = arr[i]\n    arr[i] = last\n    return tmp\n  }\n  return last\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n相对于 splice 时间复杂度伪o(1)\n\n\n# array-swap\n\n\n# 在数组中交换两个值的位置\n\n(不会更改元数组)\n\n来自 github\n\nexport default (arr, caller, target) => {\n  let instance = arr.constructor();\n  let stash = arr;\n\n  let instancetype = array.isarray(instance) ? 'array' : typeof instance;\n\n  // 判断第一个参数类型，如果不是数组，就抛出异常 \n  if(instancetype !== 'array') throw '[err] swaparray expects a array as first param';\n\n  // 浅拷贝数组，这样就不会更改元素数组了。\n  stash.map((s, i) => instance[i] = s);\n\n  // 替换位置\n  // 此处应可以优化，splice 这个api时间复杂度伪o(n),o(1) 就可以实现这个功能\n  instance[caller] = instance.splice(target, 1, instance[caller])[0];\n\n  return instance;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# mirrarray\n\n\n# 从有效key数组创建相同key的对象\n\n来自 github\n\nfunction mirrarrayerror() {}\nmirrarrayerror.prototype = object.create(error.prototype);\n\n// 判断 key 是否有效\n// typeof null 为 object,与对象结果相同，所以null需要单独处理\n// 有效类型key：string、number、boolean、undefined、null\nconst isvalidkey = element => {\n  const isnull = element === null;\n  return ['string', 'number', 'boolean', 'undefined'].includes(typeof element) || isnull;\n}\n\nconst nonoverlappingkey = element => {\n  /**\n   * ensure we don't have distinct elements that coerce to the same key, leading to unexpected results.\n   * for example, input of [true, 'true'] would return a keymirror of {true: 'true'} despite containing two distinct elements\n   * if we didn't make this check.\n   */\n  const isnull = element === null;\n  const typeseenbefore = keysseen['' + element];\n  // 获取 当前元素的类型\n  const thistype = isnull ? 'null' : typeof element;\n  if (typeseenbefore) {\n    // 当 false 的时候，说明 他们 转换成 string是相同的，但他们原本是不同类型的值\n    return typeseenbefore === thistype;\n  } else {\n    // 缓存当前元素\n    keysseen['' + element] = thistype;\n    return true;\n  }\n}\n\nlet keysseen;\n\nconst arraytokeymirror = arr => {\n  // keysseen 赋值为空对象（作用域）\n  keysseen = {};\n  // 判断参数类型，如果不是数组，就抛出异常\n  if (!array.isarray(arr)) {\n    throw new mirrarrayerror('input to mirrarray must be an array!');\n  }\n  return arr.reduce((acc, key) => {\n    // 判断 key 是否为有效类型\n    if (!isvalidkey(key)) {\n      throw new mirrarrayerror('invalid element contained within input array; each element must be either a string or number!');\n    }\n    // 处理 不同类型的值，但转为string后值相同特殊情况。例如：输入 [true, 'true']\n    if (!nonoverlappingkey(key)) {\n      throw new mirrarrayerror('distinct elements in the input array are coercing to the same string!');\n    }\n    acc[key] = key;\n    return acc;\n  }, {});\n};\n\nexport default arraytokeymirror;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n这里处理错误异常情况，不管命名还是代码实现都值得借鉴\n\n\n# group-array\n\n\n# 将数组按照某种属性分类成对象\n\n来自 github\n\n依赖包：\n\n * split-string\n * arr-flatten\n * union-value\n * for-own\n * kind-of\n * get-value\n\n入口函数：groupfn\n\nfunction groupfn(arr, props) {\n  // 如果 arr 是null，直接返回空数组\n  if (arr == null) {\n    return [];\n  }\n\n  // 确实 arr 是不是数组类型\n  if (!array.isarray(arr)) {\n    throw new typeerror('group-array expects an array.');\n  }\n\n  // 数组长度为1，无需分类\n  if (arguments.length === 1) {\n    return arr;\n  }\n\n  // 边际情况处理完后，接下来就是处理参数\n  // 这里 可以es6 的剩余参数，\n  let args = flatten([].slice.call(arguments, 1));\n  // 处理 第二参数，通过 groupby 进行分类\n  let groups = groupby(arr, args[0]);\n\n  // 如果 参数个数超过了2个，就通过 togroup 继续处理\n  // 这里有个技巧：为 i 是从 1开始，因为需要把处理后的 groups 返回，而groups是在处理第二个参数结束后赋值的。\n  // 处理 后面的参数，利用 指针，每次处理参数的结果继续存储 到 groups 中\n  for (let i = 1; i < args.length; i++) {\n    togroup(groups, args[i]);\n  }\n  return groups;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\ntogroup\n\nfunction togroup(groups, prop) {\n  // 遍历对象上自身属性\n  forown(groups, (val, key) => {\n    // 如果不是 数组 类型，则继续调用自身，反之 通过 groupby 进行分类\n    if (!array.isarray(val)) {\n      groups[key] = togroup(val, prop, key);\n    } else {\n      groups[key] = groupby(val, prop, key);\n    }\n  });\n  return groups;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\ngroupby\n\nfunction groupby(arr, prop, key) {\n  let groups = {};\n\n  for (let i = 0; i < arr.length; i++) {\n    let obj = arr[i];\n    let val;\n\n    // allow a function to modify the object\n    // and/or return a val to use\n    if (typeof prop === 'function') {\n      val = prop.call(groups, obj, key);\n    } else {\n      val = get(obj, prop);\n    }\n\n    switch (typeof(val)) {\n      case 'undefined':\n        break;\n      case 'string':\n      case 'number':\n      case 'boolean':\n        union(groups, escape(string(val)), obj);\n        break;\n      case 'object':\n      case 'array':\n        eachvalue(groups, obj, val);\n        break;\n      case 'function':\n        throw new error('invalid argument type: ' + key);\n    }\n  }\n  return groups;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n'use strict';\n\nconst split = require('split-string');\nconst flatten = require('arr-flatten');\nconst union = require('union-value');\nconst forown = require('for-own');\nconst typeof = require('kind-of');\nconst get = require('get-value');\n\n// 入口函数\n\n\n\n\nfunction eachvalue(groups, obj, val) {\n  if (array.isarray(val)) {\n    val.foreach(key => {\n      union(groups, escape(key), obj);\n    });\n  } else {\n    forown(val, (v, key) => {\n      union(groups, escape(key), obj);\n    });\n  }\n}\n\nfunction togroup(groups, prop) {\n  forown(groups, (val, key) => {\n    if (!array.isarray(val)) {\n      groups[key] = togroup(val, prop, key);\n    } else {\n      groups[key] = groupby(val, prop, key);\n    }\n  });\n  return groups;\n}\n\nfunction escape(str) {\n  var opts = {\n    strict: false,\n    keepescaping: true,\n    keepdoublequotes: true,\n    keepsinglequotes: true\n  };\n\n  try {\n    return split(str, opts).join('\\\\.');\n  } catch (err) {\n    return str;\n  }\n}\n\n/**\n * expose `grouparray`\n */\n\nmodule.exports = groupfn;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# array.chunk",charsets:{cjk:!0},lastUpdated:"2022/04/05, 12:30:49",lastUpdatedTimestamp:1649133049e3},{title:"is-number",frontmatter:{title:"is-number",date:"2022-03-24T14:31:37.000Z",permalink:"/pages/e82928/",categories:["npm","数学"],tags:[null]},regularPath:"/05.npm/60.%E6%95%B0%E5%AD%A6/5.is-number.html",relativePath:"05.npm/60.数学/5.is-number.md",key:"v-9671cbb4",path:"/pages/e82928/",headersStr:null,content:"is-number\n\n判断值是否为数字\n\n来自 github",normalizedContent:"is-number\n\n判断值是否为数字\n\n来自 github",charsets:{cjk:!0},lastUpdated:"2022/03/24, 14:39:32",lastUpdatedTimestamp:1648103972e3},{title:"网站",frontmatter:{title:"网站",date:"2022-05-10T16:32:15.000Z",permalink:"/pages/d021d1/",categories:["更多","藏品"],tags:[null]},regularPath:"/06.%E6%94%B6%E8%97%8F%E5%A4%B9/05.%E7%BD%91%E7%AB%99.html",relativePath:"06.收藏夹/05.网站.md",key:"v-71f69e9c",path:"/pages/d021d1/",headers:[{level:2,title:"Hosts",slug:"hosts",normalizedTitle:"hosts",charIndex:2}],headersStr:"Hosts",content:"# Hosts\n\n * lasted-hosts: 实时更新hosts的资源",normalizedContent:"# hosts\n\n * lasted-hosts: 实时更新hosts的资源",charsets:{cjk:!0},lastUpdated:"2022/05/10, 17:00:46",lastUpdatedTimestamp:1652173246e3},{title:"计算机系统漫游",frontmatter:{title:"计算机系统漫游",date:"2022-07-05T12:22:26.000Z",permalink:"/pages/8a9936/",categories:["深入理解计算机系统"],tags:["读书笔记","计算机系统"]},regularPath:"/08.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/05.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8.html",relativePath:"08.计算机系统/05.深入理解计算机系统/01.计算机系统漫游.md",key:"v-6a00f8d1",path:"/pages/8a9936/",headers:[{level:2,title:"1.1 信息就是位 + 上下文",slug:"_1-1-信息就是位-上下文",normalizedTitle:"1.1 信息就是位 + 上下文",charIndex:324},{level:2,title:"1.2 程序的翻译",slug:"_1-2-程序的翻译",normalizedTitle:"1.2 程序的翻译",charIndex:512},{level:2,title:"1.3 了解编译系统如何工作的益处",slug:"_1-3-了解编译系统如何工作的益处",normalizedTitle:"1.3 了解编译系统如何工作的益处",charIndex:1231},{level:2,title:"1.4 程序的执行",slug:"_1-4-程序的执行",normalizedTitle:"1.4 程序的执行",charIndex:1288},{level:3,title:"1.4.1 系统的硬件组成",slug:"_1-4-1-系统的硬件组成",normalizedTitle:"1.4.1 系统的硬件组成",charIndex:1541}],headersStr:"1.1 信息就是位 + 上下文 1.2 程序的翻译 1.3 了解编译系统如何工作的益处 1.4 程序的执行 1.4.1 系统的硬件组成",content:'这是深入理解计算机系统的第一章，这一章是对计算机系统知识的概括，这其中会引入一些专业术语，但并不会深入解释这些术语。书本就是我们学习知识的引入路，先让读者窥探整片森林，以防迷失在某一知识细节中。所以这一章很重要，应该好好读一读。\n\n另外关于这本书籍，B站有 UP 主专门讲解视频 B站up 九曲阑干: 【合集】CSAPP-深入理解计算机系统\n\n这一章以打印“hello world”为例，讲述程序在计算机系统的生命周期，并介绍计算机系统的主要概念和主题。\n\n#include <stdio.h>\n\nint main() {\n  printf("hello, world!\\n");\n  return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 1.1 信息就是位 + 上下文\n\n位是计算机最小单位，其值由 0 和 1 组成，又称为比特。8 位被组织成一组，称为字节。\n\n程序最终执行的时候，最终都会转为二进制，而转换的依据就是上下文。\n\n在大部分操作系统中使用 ASCII来表示文本字符，以 ASCII 作为上下文，那么 ‘#’ 字符对应的字节整数值为35，‘i’ 字符对应的字节整数值为105........\n\n\n# 1.2 程序的翻译\n\n执行 hello.c 的命令\n\ngcc -o hello hello.c\n\n\n1\n\n\n这条命令通过编译器驱动程序，把源文件转化成可执行目标文件，这个过程一共分为四个阶段。\n\n\n\n * 预处理\n   \n   读取系统头文件的内容，并插入到程序文本，得到另外一个程序。\n   \n   例如 读取 hello.c 中的第一行 #include <stdio.h>头文件的内容，插入到程序文本，得到一个 hello.i 文件\n\n * 编译器\n   \n   把文本文件的内容翻译成汇编语言\n   \n   把 hello.i 翻译成 hello.s\n   \n   main: \n     2 subq $8, \n     %rsp 3 movl $.LCO, \n     %edi 4 call puts 5 movl $0, \n     %eax 6 addq $8, \n     %rsp 7 ret\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 汇编\n   \n   把汇编语言翻译成机器指令，把这些指令会被打包成*可重定位目标程序（relocatable object program）*的格式，得到 hello.o，这是一个二进制文件。\n\n * 链接器\n   \n   合并程序内部调用的函数，得到一个可执行目标文件的内容。\n   \n   在 hello 程序内部调用了 printf 函数，这个函数是 C 编译器提供的标准库函数。它会被预编译成 printf.o 文件。链接要做的事情，就是把 hello.o 和 printf.o 合并成 hello 可执行文件。\n\n\n# 1.3 了解编译系统如何工作的益处\n\n * 优化程序性能\n * 理解链接时出现的错误\n * 避免安全漏洞\n\n\n# 1.4 程序的执行\n\n如何运行 hello 可执行程序，以 Unix 系统为例子：\n\n 1. 打开 shell 程序\n 2. 在 shell 中输入相应可执行程序的文件名\n\nlinux> \n  ./hello \n  hello, world \nlinux>\n\n\n1\n2\n3\n4\n\n\nshell 程序是一个命令解释器，它输出一个提示符，等待输入命令行，然后执行这个命令 如果该命令的第一个单词不是内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。\n\n\n# 1.4.1 系统的硬件组成\n\n',normalizedContent:'这是深入理解计算机系统的第一章，这一章是对计算机系统知识的概括，这其中会引入一些专业术语，但并不会深入解释这些术语。书本就是我们学习知识的引入路，先让读者窥探整片森林，以防迷失在某一知识细节中。所以这一章很重要，应该好好读一读。\n\n另外关于这本书籍，b站有 up 主专门讲解视频 b站up 九曲阑干: 【合集】csapp-深入理解计算机系统\n\n这一章以打印“hello world”为例，讲述程序在计算机系统的生命周期，并介绍计算机系统的主要概念和主题。\n\n#include <stdio.h>\n\nint main() {\n  printf("hello, world!\\n");\n  return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 1.1 信息就是位 + 上下文\n\n位是计算机最小单位，其值由 0 和 1 组成，又称为比特。8 位被组织成一组，称为字节。\n\n程序最终执行的时候，最终都会转为二进制，而转换的依据就是上下文。\n\n在大部分操作系统中使用 ascii来表示文本字符，以 ascii 作为上下文，那么 ‘#’ 字符对应的字节整数值为35，‘i’ 字符对应的字节整数值为105........\n\n\n# 1.2 程序的翻译\n\n执行 hello.c 的命令\n\ngcc -o hello hello.c\n\n\n1\n\n\n这条命令通过编译器驱动程序，把源文件转化成可执行目标文件，这个过程一共分为四个阶段。\n\n\n\n * 预处理\n   \n   读取系统头文件的内容，并插入到程序文本，得到另外一个程序。\n   \n   例如 读取 hello.c 中的第一行 #include <stdio.h>头文件的内容，插入到程序文本，得到一个 hello.i 文件\n\n * 编译器\n   \n   把文本文件的内容翻译成汇编语言\n   \n   把 hello.i 翻译成 hello.s\n   \n   main: \n     2 subq $8, \n     %rsp 3 movl $.lco, \n     %edi 4 call puts 5 movl $0, \n     %eax 6 addq $8, \n     %rsp 7 ret\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 汇编\n   \n   把汇编语言翻译成机器指令，把这些指令会被打包成*可重定位目标程序（relocatable object program）*的格式，得到 hello.o，这是一个二进制文件。\n\n * 链接器\n   \n   合并程序内部调用的函数，得到一个可执行目标文件的内容。\n   \n   在 hello 程序内部调用了 printf 函数，这个函数是 c 编译器提供的标准库函数。它会被预编译成 printf.o 文件。链接要做的事情，就是把 hello.o 和 printf.o 合并成 hello 可执行文件。\n\n\n# 1.3 了解编译系统如何工作的益处\n\n * 优化程序性能\n * 理解链接时出现的错误\n * 避免安全漏洞\n\n\n# 1.4 程序的执行\n\n如何运行 hello 可执行程序，以 unix 系统为例子：\n\n 1. 打开 shell 程序\n 2. 在 shell 中输入相应可执行程序的文件名\n\nlinux> \n  ./hello \n  hello, world \nlinux>\n\n\n1\n2\n3\n4\n\n\nshell 程序是一个命令解释器，它输出一个提示符，等待输入命令行，然后执行这个命令 如果该命令的第一个单词不是内置的 shell 命令，那么 shell 就会假设这是一个可执行文件的名字，它将加载并运行这个文件。\n\n\n# 1.4.1 系统的硬件组成\n\n',charsets:{cjk:!0},lastUpdated:"2022/07/09, 23:42:13",lastUpdatedTimestamp:1657381333e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-53104ef6",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/03, 19:24:28",lastUpdatedTimestamp:1646306668e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-1a9d53e5",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/03, 19:24:28",lastUpdatedTimestamp:1646306668e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-150b83f6",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/03, 19:24:28",lastUpdatedTimestamp:1646306668e3},{title:"你知道的越多，不知道的也就越多",frontmatter:{title:"你知道的越多，不知道的也就越多",date:"2020-05-06T15:52:40.000Z",permalink:"/pages/f2e63f",sidebar:"auto",categories:["随笔"],tags:["学习","知识","鸡汤"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%B6%8A%E5%A4%9A%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B9%9F%E5%B0%B1%E8%B6%8A%E5%A4%9A.html",relativePath:"_posts/随笔/你知道的越多，不知道的也就越多.md",key:"v-95c08fd2",path:"/pages/f2e63f/",excerpt:"<p>不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。</p>\n",headersStr:null,content:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",normalizedContent:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",charsets:{cjk:!0},lastUpdated:"2022/03/03, 19:24:28",lastUpdatedTimestamp:1646306668e3},{title:"拥抱生活，拥抱快乐",frontmatter:{title:"拥抱生活，拥抱快乐",date:"2020-06-26T20:40:38.000Z",permalink:"/pages/cd8bde/",sidebar:"auto",categories:["随笔"],tags:["鸡汤"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E6%8B%A5%E6%8A%B1%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8B%A5%E6%8A%B1%E5%BF%AB%E4%B9%90.html",relativePath:"_posts/随笔/拥抱生活，拥抱快乐.md",key:"v-77761d97",path:"/pages/cd8bde/",excerpt:"<p>生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。</p>\n",headersStr:null,content:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:B站视频《罗翔说刑法》，链接https://b23.tv/K8ulrE",normalizedContent:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:b站视频《罗翔说刑法》，链接https://b23.tv/k8ulre",charsets:{cjk:!0},lastUpdated:"2022/03/03, 19:24:28",lastUpdatedTimestamp:1646306668e3},{title:"项目",frontmatter:{title:"项目",date:"2022-03-21T08:52:35.000Z",permalink:"/pages/c2c415/",sidebar:"auto",categories:["随笔"],tags:[null]},regularPath:"/_posts/%E9%A1%B9%E7%9B%AE.html",relativePath:"_posts/项目.md",key:"v-821f1cb0",path:"/pages/c2c415/",headers:[{level:2,title:"登录流程的优化",slug:"登录流程的优化",normalizedTitle:"登录流程的优化",charIndex:221},{level:2,title:"确实刷新的时候，以及拿到了依赖数据",slug:"确实刷新的时候-以及拿到了依赖数据",normalizedTitle:"确实刷新的时候，以及拿到了依赖数据",charIndex:463},{level:2,title:"封装表格通用逻辑",slug:"封装表格通用逻辑",normalizedTitle:"封装表格通用逻辑",charIndex:1892},{level:2,title:"行情按需订阅",slug:"行情按需订阅",normalizedTitle:"行情按需订阅",charIndex:2368},{level:2,title:"主题色",slug:"主题色",normalizedTitle:"主题色",charIndex:2785},{level:2,title:"封装protobuf请求方法",slug:"封装protobuf请求方法",normalizedTitle:"封装protobuf请求方法",charIndex:2889}],headersStr:"登录流程的优化 确实刷新的时候，以及拿到了依赖数据 封装表格通用逻辑 行情按需订阅 主题色 封装protobuf请求方法",content:"技术点学习：在学习每一个技术点的时候，都要注意一些问题：是什么？为了解决什么问题？如何实现的，有没有更深的原理？如何使用？使用的时候需要注意什么？有哪些应用的场景？有什么不足？这些不足能否避免？\n\n项目准备：理清项目中用到的技术、遇到的难点有哪些、又是怎么解决的、对项目做过哪些性能优化、做过的亮点有哪些。\n\n着重准备 项目中遇到的难点有哪些、又是怎么解决的、对项目做过哪些性能优化、做过的亮点有哪些、把一个项目的关键模块回顾并吃透\n\n\n# 登录流程的优化\n\n项目中存在登录时长太久问题。项目在登录的时候，就需要获取到依赖数据，比如菜单配置，商品信息等等。因为要确保已经从服务获取到数据，所以用上了async,await。在没有优化之前，采用的做法是一个方法，一个await，然后一个日志，总共有十来个接口。这样如果其中一个接口卡住了，就会导致登录时长很久。优化的方案是利用把接口错误日志放在具体接口里，然后用Promise.all来替换一个个await。这里还有一个难点，就是对业务很熟，因为接口之前存在依赖问题。\n\n\n# 确实刷新的时候，以及拿到了依赖数据\n\n背景：项目中用到了websocket，刷新的时候，会重写链接，那么如何确保在获取数据之前，已经获取相关的依赖。\n\n方案：刷新的时候是需要获取依赖数据，再请求页面对应的数据，而路由跳转页面，则是直接请求接口数据。在具体页面的时候，我们不应该你是刷新，还是路由跳转，只关系，请求数据即可。所以，处理方法是定义initData公共函数，这个函数接受一个回调函数，在这个回调函数内部请求数据。接下来就是处理回调函数的执行顺序，这里会定义一个变量isLoadComplete，来控制是否加载完成，默认是false。\n\n处理页面刷新，监听load事件和EventBus来解决，initData内容会订阅事件，订阅的时候的回调函数内容，当isLoadComplete为true的时候，执行callback回调。触发更新，监听load事件，先把isLoadComplete设置为false，当依赖数据请求完成的时候，把isLoadComplete设置为true，并且发布事件，触发callback执行。\n\n如果是第一次启动，则是利用路由钩子，登录之前设置为false，登录成功设置为true，initData函数内部，如果isLoadComplete为true的时候，就会触发callback执行。\n\n最好在组件卸载的时候，取消订阅事件。\n\nlet isLoadComplete = false;\n\n// 未缓存页初始化数据\nexport const initData = (callback: Function): void => {\n    // 刷新整个页面时候，需要等数据加载数据\n    const cb = () => {\n        if (isLoadComplete) {\n            callback && callback();\n        }\n    };\n    Bus.$on('loadComplete', cb);\n    if (isLoadComplete) {\n        callback && callback();\n    }\n    onUnmounted(() => {\n        Bus.$off('loadComplete', cb);\n    });\n};\n\n// 页面刷新\nwindow.addEventListener('load', () => {\n  setLoadComplete(false);\n  globalDataRefresh().then(() => {\n    setLoadComplete(true);\n    eventBus.$emit('loadComplete');\n  })\n})\n\n// 路由钩子\nrouter.beforeEach(() => {\n  if(getLoadIsComplete()) {\n    setLoadComplete(false)\n    login().then(() => {\n      setLoadComplete(true)\n    })\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 封装表格通用逻辑\n\n背景：项目中有很多需要表格来展示数据的页面，例如报表。\n\n封装各个逻辑\n\n * 获取列表数据：\n   \n   * 控制loading\n   * 浮动失真问题。默认2位，超过6为小数就自动截取。\n\n * 右键逻辑\n   \n   * 右键组件要包裹表格组件，\n     * 简化逻辑，只需要传入按钮数据即可。\n     * 解决bug，元素点击错误。\n   * 过滤表头，内容会定位右键位置\n\n * 控制弹出组件逻辑\n   \n   * 组件id，与动态组件名对用\n   * 弹窗组件统一emite一个cancel事件，并接受一个参数，关闭的时候，表示是否刷新数据\n   * 遇到问题：打开的页面数据是旧的，控制\n\n * 表格事件\n   \n   * 定义一个变量，接受表示选中的那条数据\n   * 点击事件，接受选择数据，缓存key，打开折叠面板，如果有回调，则会执行回调函数\n   * 右键事件，接受选中数据，如果有回调，则会执行回调函数\n\n结果：引入相关组件，只需按照参数传递就可以快速实现表格页面功能，这样就提高开发效率。\n\n\n# 行情按需订阅\n\n * 订阅池子Map，只暴露出添加订阅和删除订阅方法。\n   * 添加订阅\n     * 每次添加订阅的时候，就先去主动连接行情，主动连接行情内部已经处理好了，如果已经链接上了，不会再去重新连接。\n     * 然后订阅池子里添加数据，添加完后把池子里的数据都拿出来，在去重后就开始商品订阅\n   * 删除订阅\n     * 先判断是否存在uuid，删除后如果还有数据，则合并去重池子map里的数据，重新订阅商品。如果没有数据，就断开行情链路的连接\n\n实现行情按需订阅\n\n * 接受一个必填参数，列表数据，和三个可选参数，codeKey，行高，selector\n * 第一次启动的是利用watchEffect这个api，自动执行行情订阅。并且监听scroll事件，内部加入防抖，然后判断滚动方向，根据行高，计算出可视区域的行数，为了更好的体验，会在加两条数据，然后计算出，滚动条位置与表格数据对应的索引位置。\n\n\n# 主题色\n\n方案：css 变量， 切换主题： document.documentElement.setAttribute('theme', value) 持久化：localStorage 缓存当前主题\n\n\n# 封装protobuf请求方法\n\n背景：需要自己组装数据，手动调用长连接发送方法。\n\n封装好后，安装模板填入数据即可。\n\n * 组装数据\n   * 需要传入funcode，protobufName，接口对应的参数，可选的protoHead参数\n   * proto有两条链路，统一查询和单独某一条数据查询。\n     * 单独查询\n       * 先构建header，然后再构建具体内容。\n       * 先把proto报文转换成Map键值对，然后变量接口对应的参数，往报文里填充数据。\n       * 好处，不需要手动构建报文了，另外组装的时候处理好了id大小写混乱的问题\n     * 统一查询\n       * 存在加密信息处理的情况\n       * 存在坑：组装报文的时候，accountid取名不一样，需要枚举处理。\n   * 解析报文\n     * 管理端错误：RetCode -1\n     * 银行业务错误：RetCode null",normalizedContent:"技术点学习：在学习每一个技术点的时候，都要注意一些问题：是什么？为了解决什么问题？如何实现的，有没有更深的原理？如何使用？使用的时候需要注意什么？有哪些应用的场景？有什么不足？这些不足能否避免？\n\n项目准备：理清项目中用到的技术、遇到的难点有哪些、又是怎么解决的、对项目做过哪些性能优化、做过的亮点有哪些。\n\n着重准备 项目中遇到的难点有哪些、又是怎么解决的、对项目做过哪些性能优化、做过的亮点有哪些、把一个项目的关键模块回顾并吃透\n\n\n# 登录流程的优化\n\n项目中存在登录时长太久问题。项目在登录的时候，就需要获取到依赖数据，比如菜单配置，商品信息等等。因为要确保已经从服务获取到数据，所以用上了async,await。在没有优化之前，采用的做法是一个方法，一个await，然后一个日志，总共有十来个接口。这样如果其中一个接口卡住了，就会导致登录时长很久。优化的方案是利用把接口错误日志放在具体接口里，然后用promise.all来替换一个个await。这里还有一个难点，就是对业务很熟，因为接口之前存在依赖问题。\n\n\n# 确实刷新的时候，以及拿到了依赖数据\n\n背景：项目中用到了websocket，刷新的时候，会重写链接，那么如何确保在获取数据之前，已经获取相关的依赖。\n\n方案：刷新的时候是需要获取依赖数据，再请求页面对应的数据，而路由跳转页面，则是直接请求接口数据。在具体页面的时候，我们不应该你是刷新，还是路由跳转，只关系，请求数据即可。所以，处理方法是定义initdata公共函数，这个函数接受一个回调函数，在这个回调函数内部请求数据。接下来就是处理回调函数的执行顺序，这里会定义一个变量isloadcomplete，来控制是否加载完成，默认是false。\n\n处理页面刷新，监听load事件和eventbus来解决，initdata内容会订阅事件，订阅的时候的回调函数内容，当isloadcomplete为true的时候，执行callback回调。触发更新，监听load事件，先把isloadcomplete设置为false，当依赖数据请求完成的时候，把isloadcomplete设置为true，并且发布事件，触发callback执行。\n\n如果是第一次启动，则是利用路由钩子，登录之前设置为false，登录成功设置为true，initdata函数内部，如果isloadcomplete为true的时候，就会触发callback执行。\n\n最好在组件卸载的时候，取消订阅事件。\n\nlet isloadcomplete = false;\n\n// 未缓存页初始化数据\nexport const initdata = (callback: function): void => {\n    // 刷新整个页面时候，需要等数据加载数据\n    const cb = () => {\n        if (isloadcomplete) {\n            callback && callback();\n        }\n    };\n    bus.$on('loadcomplete', cb);\n    if (isloadcomplete) {\n        callback && callback();\n    }\n    onunmounted(() => {\n        bus.$off('loadcomplete', cb);\n    });\n};\n\n// 页面刷新\nwindow.addeventlistener('load', () => {\n  setloadcomplete(false);\n  globaldatarefresh().then(() => {\n    setloadcomplete(true);\n    eventbus.$emit('loadcomplete');\n  })\n})\n\n// 路由钩子\nrouter.beforeeach(() => {\n  if(getloadiscomplete()) {\n    setloadcomplete(false)\n    login().then(() => {\n      setloadcomplete(true)\n    })\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 封装表格通用逻辑\n\n背景：项目中有很多需要表格来展示数据的页面，例如报表。\n\n封装各个逻辑\n\n * 获取列表数据：\n   \n   * 控制loading\n   * 浮动失真问题。默认2位，超过6为小数就自动截取。\n\n * 右键逻辑\n   \n   * 右键组件要包裹表格组件，\n     * 简化逻辑，只需要传入按钮数据即可。\n     * 解决bug，元素点击错误。\n   * 过滤表头，内容会定位右键位置\n\n * 控制弹出组件逻辑\n   \n   * 组件id，与动态组件名对用\n   * 弹窗组件统一emite一个cancel事件，并接受一个参数，关闭的时候，表示是否刷新数据\n   * 遇到问题：打开的页面数据是旧的，控制\n\n * 表格事件\n   \n   * 定义一个变量，接受表示选中的那条数据\n   * 点击事件，接受选择数据，缓存key，打开折叠面板，如果有回调，则会执行回调函数\n   * 右键事件，接受选中数据，如果有回调，则会执行回调函数\n\n结果：引入相关组件，只需按照参数传递就可以快速实现表格页面功能，这样就提高开发效率。\n\n\n# 行情按需订阅\n\n * 订阅池子map，只暴露出添加订阅和删除订阅方法。\n   * 添加订阅\n     * 每次添加订阅的时候，就先去主动连接行情，主动连接行情内部已经处理好了，如果已经链接上了，不会再去重新连接。\n     * 然后订阅池子里添加数据，添加完后把池子里的数据都拿出来，在去重后就开始商品订阅\n   * 删除订阅\n     * 先判断是否存在uuid，删除后如果还有数据，则合并去重池子map里的数据，重新订阅商品。如果没有数据，就断开行情链路的连接\n\n实现行情按需订阅\n\n * 接受一个必填参数，列表数据，和三个可选参数，codekey，行高，selector\n * 第一次启动的是利用watcheffect这个api，自动执行行情订阅。并且监听scroll事件，内部加入防抖，然后判断滚动方向，根据行高，计算出可视区域的行数，为了更好的体验，会在加两条数据，然后计算出，滚动条位置与表格数据对应的索引位置。\n\n\n# 主题色\n\n方案：css 变量， 切换主题： document.documentelement.setattribute('theme', value) 持久化：localstorage 缓存当前主题\n\n\n# 封装protobuf请求方法\n\n背景：需要自己组装数据，手动调用长连接发送方法。\n\n封装好后，安装模板填入数据即可。\n\n * 组装数据\n   * 需要传入funcode，protobufname，接口对应的参数，可选的protohead参数\n   * proto有两条链路，统一查询和单独某一条数据查询。\n     * 单独查询\n       * 先构建header，然后再构建具体内容。\n       * 先把proto报文转换成map键值对，然后变量接口对应的参数，往报文里填充数据。\n       * 好处，不需要手动构建报文了，另外组装的时候处理好了id大小写混乱的问题\n     * 统一查询\n       * 存在加密信息处理的情况\n       * 存在坑：组装报文的时候，accountid取名不一样，需要枚举处理。\n   * 解析报文\n     * 管理端错误：retcode -1\n     * 银行业务错误：retcode null",charsets:{cjk:!0},lastUpdated:"2022/03/24, 10:44:26",lastUpdatedTimestamp:1648089866e3},{title:"Home",frontmatter:{home:!0,heroText:"积跬步以至千里，致敬每个爱学习的你",tagline:"一步一个脚印，脚踏实地。",features:[{title:"前端",details:"JavaScript、ES6、Vue框架等前端技术",link:"/web/",imgUrl:"/img/web.png"},{title:"算法",details:"数据结构与算法",link:"/leetcode/",imgUrl:"/img/ui.png"},{title:"技术",details:"设计模式",link:"/design-patterns/",imgUrl:"/img/other.png"}]},regularPath:"/",relativePath:"index.md",key:"v-a113e2c4",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/07, 23:19:12",lastUpdatedTimestamp:1646666352e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"前端",link:"/web/",items:[]},{text:"npm包",link:"/npm/",items:[]},{text:"网络",link:"/network/",items:[]},{text:"算法",link:"/leetcode/",items:[]},{text:"设计模式",link:"/design-patterns/",items:[]},{text:"收藏",link:"/collection/",items:[]},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]}],sidebarDepth:2,logo:"/img/logo.png",repo:"Buzhifanji/blog",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",sidebar:{"/00.目录页/":[["01.前端.md","前端","/web"],["02.网络.md","网络","/network"],["03.算法.md","算法","/leetcode"],["04.设计模式.md","🏛设计模式","/design-patterns"],["05.npm.md","🏛npm包","/npm"],["06.收藏夹.md","收藏","/collection"]],catalogue:{"前端":"/web","网络":"/network","算法":"/leetcode","设计模式":"/design-patterns",npm:"/npm","收藏夹":"/collection"},"/01.前端/":[{title:"思维导图",collapsable:!0,children:[["10.思维导图/5.前端知识体系.md","前端知识体系","/pages/837e03/"]]},{title:"Javascript",collapsable:!0,children:[["20.Javascript/6.手写promise.md","手写promise","/pages/3bb12a/"],["20.Javascript/8.事件.md","事件流","/pages/bddf14/"]]},{title:"Typescript",collapsable:!0,children:[["30.Typescript/01.test.md","test","/pages/7153e7/"]]},{title:"工程化",collapsable:!0,children:[["40.工程化/5.webpack.md","webpack","/pages/e8939e/"],["40.工程化/10.vite.md","vite","/pages/c7216e/"]]},{title:"vue",collapsable:!0,children:[["50.vue/2.Vue 生命周期.md","Vue 生命周期","/pages/a4bbd1/"],["50.vue/4.响应式原理.md","响应式原理","/pages/c51d69/"],["50.vue/6.Mixin混入原理.md","Mixin混入原理","/pages/329c47/"],["50.vue/8.模板编译原理.md","模板编译原理","/pages/c009df/"],["50.vue/10.vue3进阶笔记之effect.md","vue3进阶笔记之effect","/pages/dac852/"],["50.vue/12.vue3进阶笔记之reactive.md","vue3进阶笔记之reactive","/pages/1c753e/"],["50.vue/14.vue3进阶笔记之ref.md","vue3进阶笔记之ref","/pages/ecd654/"],["50.vue/16.vue3进阶笔记之provide、inject.md","vue3进阶笔记之provide、inject","/pages/3c450a/"],["50.vue/18.vue3进阶笔记之vuex.md","vue3进阶笔记之vuex","/pages/18eeef/"],["50.vue/20.vue3进阶笔记之pinia.md","vue3进阶笔记之pinia","/pages/a72a65/"]]},{title:"30-seconds-of-code",collapsable:!0,children:[["70.30-seconds-of-code/5.30SecondsArray.md","30SecondsArray","/pages/14d237/"],["70.30-seconds-of-code/10.30SecondsString.md","30SecondsString","/pages/2e07e0/"],["70.30-seconds-of-code/15.30SecondsMath.md","30SecondsMath","/pages/908120/"],["70.30-seconds-of-code/20.30SecondsNode.md","30SecondsNode","/pages/28a623/"],["70.30-seconds-of-code/25.30SecondsBrower.md","30SecondsBrower","/pages/8fb9cb/"],["70.30-seconds-of-code/30.30SecondsDate.md","30SecondsDate","/pages/ee2d60/"]]},{title:"浏览器",collapsable:!0,children:[{title:"宏观视角上的浏览器",collapsable:!0,children:[["80.浏览器/10.宏观视角上的浏览器/4.Chrome架构.md","Chrome架构：仅仅打开了1个页面，为什么有4个进程","/pages/4555d4/"]]}]}],"/02.网络/":[{title:"HTTP",collapsable:!0,children:[["20.HTTP/01.test.md","test","/pages/c78068/"],["20.HTTP/10.http缓存.md","http缓存","/pages/fef14d/"]]}],"/03.算法/":[{title:"序言",collapsable:!0,children:[["0.序言/0.index.md","index","/pages/87eaf1/"]]},{title:"数据结构",collapsable:!0,children:[["5.数据结构/5.Array.md","Array | 数组","/pages/8f6f25/"]]},{title:"数据结构笔记",collapsable:!0,children:[["7.数据结构笔记/5.数据结构导论.md","数据结构导论","/pages/5eb93d/"]]},{title:"栈",collapsable:!0,children:[["10.栈/1.判断字符串括号是否合法.md","判断字符串括号是否合法","/pages/7796ac/"],["10.栈/2.大鱼吃小鱼.md","大鱼吃小鱼","/pages/0255ab/"],["10.栈/3.找出数组中右边比我小的元素.md","找出数组中右边比我小的元素","/pages/26a51f/"],["10.栈/20.有效的括号.md","有效的括号","/pages/c8d9ba/"],["10.栈/94. 二叉树的中序遍历.md","二叉树的中序遍历","/pages/12f998/"],["10.栈/144. 二叉树的前序遍历.md","二叉树的前序遍历","/pages/f79bac/"],["10.栈/145. 二叉树的后序遍历.md","二叉树的后序遍历","/pages/cc00cd/"]]},{title:"队列",collapsable:!0,children:[]}],"/04.设计模式/":[{title:"行为型模式",collapsable:!0,children:[["06.行为型模式/10.观察者模式.md","🦉观察者与发布订阅模式","/pages/73d23b/"]]}],"/05.npm/":[{title:"awesome-micro",collapsable:!0,children:[["10.awesome-micro/10.Array.md","Array","/pages/978afe/"]]},{title:"数学",collapsable:!0,children:[["60.数学/5.is-number.md","is-number","/pages/e82928/"]]}],"/06.收藏夹/":[["05.网站.md","网站","/pages/d021d1/"]],"/08.计算机系统/":[{title:"深入理解计算机系统",collapsable:!0,children:[["05.深入理解计算机系统/01.计算机系统漫游.md","计算机系统漫游","/pages/8a9936/"]]}]},author:{name:"buzhifanji",link:"https://github.com/Buzhifanji"},blogger:{avatar:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg",name:"buzhifanji",slogan:"前端界的小学生"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:buzhifanji@16.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/Buzhifanji"}]},footer:{createYear:2021,copyrightInfo:'buzhifanji | <a href="https://github.com/Buzhifanji/blog/master/LICENSE" target="_blank">MIT License</a>'},htmlModules:{homeSidebarB:""}},locales:{"/":{lang:"zh-CN",title:"Buzhifanji blog",description:"web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。",path:"/"}}};var yl=t(94),bl=t(95),xl=t(11);var kl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(xl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(xl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(xl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,a=n.length;r<a;r++){const{frontmatter:{categories:a,tags:o}}=n[r];"array"===Object(xl.n)(a)&&a.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(xl.n)(o)&&o.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Vt.component(yl.default),Vt.component(bl.default);function _l(n){return n.toString().padStart(2,"0")}t(237);Vt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,385))),Vt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,94))),Vt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,95)));t(238),t(239);var wl=t(93),El=t.n(wl),jl=t(25);let Cl,Tl;var Sl;"valine"===(Sl="gitalk")?t.e(60).then(t.t.bind(null,327,7)).then(n=>Tl=n.default):"gitalk"===Sl&&Promise.all([t.e(0),t.e(59)]).then(t.t.bind(null,328,7)).then(()=>t.e(58).then(t.t.bind(null,329,7))).then(n=>Cl=n.default);function Al(n,e){const t={};return Reflect.ownKeys(n).forEach(r=>{if("string"==typeof n[r])try{t[r]=El.a.render(n[r],e)}catch(e){console.warn(`Comment config option error at key named "${r}"`),console.warn("More info: "+e.message),t[r]=n[r]}else t[r]=n[r]}),t}console.log(`How to use "gitalk" in ${jl.name}@v${jl.version}:`,jl.homepage);const Il={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new Cl(Al({clientID:"d75cd7af2586e379aba0",clientSecret:"cd2f47c272e5d7173e09b73113c5b12ccbca0716",repo:"blog-comment",owner:"Buzhifanji",admin:["Buzhifanji"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Tl({...Al({clientID:"d75cd7af2586e379aba0",clientSecret:"cd2f47c272e5d7173e09b73113c5b12ccbca0716",repo:"blog-comment",owner:"Buzhifanji",admin:["Buzhifanji"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},Pl="vuepress-plugin-comment";let Ol=null;function Bl(n){return Il.gitalk.clear(Pl)}function zl(n){return!1!==n.comment&&!1!==n.comments}function Dl(n){clearTimeout(Ol);if(document.querySelector("main.page"))return Il.gitalk.render(n,Pl);Ol=setTimeout(()=>Dl(n),200)}var $l={mounted(){Ol=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Bl()&&zl(n)&&Dl(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Bl()&&zl(t)&&Dl(t)})}},Ll=Object(hl.a)($l,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Ml=[({Vue:n,options:e,router:t,siteData:r})=>{},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${_l(n.getUTCMonth()+1)}-${_l(n.getUTCDate())} ${_l(n.getUTCHours())}:${_l(n.getUTCMinutes())}:${_l(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(kl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{n.component("Comment",Ll)}],Rl=["Comment"];class Ul extends class{constructor(){this.store=new Vt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Vt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Ul.prototype,{getPageAsyncComponent:rs,getLayoutAsyncComponent:as,getAsyncComponent:os,getVueComponent:is});var Nl={install(n){const e=new Ul;n.$vuepress=e,n.prototype.$vuepress=e}};function Fl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Vl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ls("pageKey",e),Vt.component(e)||Vt.component(e,rs(e)),Vt.component(e)?n(e):n("")}},ql={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Gl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Jl=(t(245),t(246),Object(hl.a)(Gl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Hl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Vt.config.productionTip=!1,Vt.use(Fi),Vt.use(Nl),Vt.mixin(function(n,e,t=Vt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),o={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},gl)),Vt.component("Content",Vl),Vt.component("ContentSlotsDistributor",ql),Vt.component("OutboundLink",Jl),Vt.component("ClientOnly",Hl),Vt.component("Layout",as("Layout")),Vt.component("NotFound",as("NotFound")),Vt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"3c94737"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:gl.routerBase||gl.base,t=new Fi({base:e,mode:"history",fallback:!1,routes:ml,scrollBehavior:(n,e,t)=>t||(n.hash?!Vt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Fl(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Fl(n,t)?r(t):r()}else r();else{const t=e.path+"/",a=e.path+".html";Fl(n,a)?r(a):Fl(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(Ml.filter(n=>"function"==typeof n).map(e=>e({Vue:Vt,options:r,router:t,siteData:gl,isServer:n})))}catch(n){console.error(n)}return{app:new Vt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Rl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);