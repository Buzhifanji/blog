import{_ as n,X as i,Y as d,Z as e,$ as h,a0 as t,a1 as a,E as s}from"./framework-7f72c1b4.js";const o={},l=a('<p>整理前端体系知识，一方面可以体系化自己的知识，另一方面做好时刻面试的准备。</p><h2 id="基础知识" tabindex="-1"><a class="header-anchor" href="#基础知识" aria-hidden="true">#</a> 基础知识</h2><h3 id="原型与继承" tabindex="-1"><a class="header-anchor" href="#原型与继承" aria-hidden="true">#</a> 原型与继承</h3><p>JS规范里描述了所有对象，都有一个隐式引用，它就会称为这个对象的<strong>原型</strong>。<strong>原型</strong>就是给其它对象提供共享属性的对象。</p><p>原型对象也有自己的隐式引用，有自己的原型对象，如此就会构成对象的原型的原型的原型的链条，直到某个对象的隐式引用为 null，整个链条终止。这个链条就是<strong>原型链</strong></p><p>从数据结构来理解原型链，JS 原型其实是一个隐式的<strong>单向链表</strong>。</p><ul><li><em>谈谈你对 JS 原型和原型链的理解？</em></li></ul><p><strong>JS 原型</strong>是指为其它对象提供<strong>共享属性</strong>访问的对象。在创建对象时，每个对象都包含一个隐式引用指向它的原型对象或者 null。 原型也是对象，因此它也有自己的原型。这样构成一个<strong>原型链</strong>。</p><ul><li><em>原型链有什么作用？</em></li></ul><p>在访问一个对象的属性时，实际上是在查询原型链。这个对象是原型链的第一个元素，先检查它是否包含属性名，如果包含则返回属性值，否则检查原型链上的第二个元素，以此类推。</p><ul><li><em>如何实现原型继承呢</em></li></ul><p>有两种方式：</p><p>一种是通过 Object.create 或者 Object.setPrototypeOf 显式继承另一个对象，将它设置为原型。</p><p>另一种是通过 constructor 构造函数，使用 new 关键字实例化时，会自动继承 constructor 的 prototype 对象，作为实例的原型。</p><p>那么 constructorA 如何继承 constructorB呢？</p><p>在js里的继承，是对象跟对象之间的继承。constructor 的主要用途是初始化对象的属性。</p><p>所以两个对象之间的继承，需要分开两个步骤</p><p>第一步：编写一个新的 constructor,将两个 constructor 通过 call/apply 的方式合并它们的初始化。合并是按照超类优先的顺序进行。（这里需要注意一点，es6 class 的继承，继承的是方式，而属性会挂载到原型对象上） 第二步：取出超类和子类的原型对象，通过 Object.create/Object.setPrototypeOf 显示原型继承的方式，设置子类的原型为超类原型。</p><p>这中风格与 ES6 的class风格的背后 constructor 工作方式是一样的，上述实现起来比较繁琐，因此建议 ES6 提供的 class 和 extends 关键字去实现继承。</p><h4 id="原型深度好文" tabindex="-1"><a class="header-anchor" href="#原型深度好文" aria-hidden="true">#</a> 原型深度好文</h4>',20),c={href:"https://juejin.cn/post/6901494216074100750",target:"_blank",rel:"noopener noreferrer"},p=a('<h3 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h3><h4 id="是什么" tabindex="-1"><a class="header-anchor" href="#是什么" aria-hidden="true">#</a> 是什么</h4><p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</p><p>从代码层面上来说，当一个函数内部返回另外一个函数的时候，就会创建闭包。</p><h4 id="有什么用" tabindex="-1"><a class="header-anchor" href="#有什么用" aria-hidden="true">#</a> 有什么用</h4><p>闭包主要有两个作用：</p><p>一个是保护，比如创私有变量，定义只要函数内部才能访问的变量；</p><p>另一个是保存，正常来说，当一个函数执行完毕后，函数的词法环境会被销毁，也就是说变量会被清楚掉，但闭包，会保存对创建所在的词法环境，这个时候执行的上下文就不好被销毁。变量的生命周期得以延长。</p><h3 id="异步" tabindex="-1"><a class="header-anchor" href="#异步" aria-hidden="true">#</a> 异步</h3><h4 id="回调函数" tabindex="-1"><a class="header-anchor" href="#回调函数" aria-hidden="true">#</a> 回调函数</h4><h4 id="promsie" tabindex="-1"><a class="header-anchor" href="#promsie" aria-hidden="true">#</a> promsie</h4><h4 id="generate" tabindex="-1"><a class="header-anchor" href="#generate" aria-hidden="true">#</a> generate</h4><h4 id="async-await" tabindex="-1"><a class="header-anchor" href="#async-await" aria-hidden="true">#</a> async await</h4><h3 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h3><h3 id="事件循环机制" tabindex="-1"><a class="header-anchor" href="#事件循环机制" aria-hidden="true">#</a> 事件循环机制</h3><h4 id="原型深度好文-1" tabindex="-1"><a class="header-anchor" href="#原型深度好文-1" aria-hidden="true">#</a> 原型深度好文</h4><p>js是一门单线程语言，所以同一个时间只能执行一个任务。如果某个任务执行时间太久，就会阻塞后面的任务。为了解决这种任务阻塞问题，js引入了<strong>事件循环机制</strong>。</p><p>js脚步执行的时候，遇到同步代码，会将这些同步代码按照执行顺序加入到执行栈中，遇到异步代码，并不是等待执行结果，而是加入任务队列里。</p><p>当执行中的同步都执行完毕后，这个时候主线程是空闲状态，主线程会去任务队列里查看是否有任务，如果有，那么主线程会从中取出排在第一位的任务，并将这个任务的对应的回调放入执行中，然后执行其中的同步代码，如何反复，这样就形成了一个无限的循环。上述这个过程就是“js事件循环”</p><p>需要注意的是，异步任务是有分类，不同的任务对应着不同的队列:</p><ul><li>微队列，优先级最高，比如：Promise、MutaionObserver</li><li>事件队列，优先级其次，js的事件交互</li><li>延时队列，优先级最低，比如定时器，延时器</li></ul><p>这些队列的执行顺序：主线程会查看微队列是有任务，如果没有，则继续查看事件队列，如果也没有，就查看延时队列。</p>',22),u={href:"https://zhuanlan.zhihu.com/p/33058983",target:"_blank",rel:"noopener noreferrer"},f=a('<h3 id="dom-事件" tabindex="-1"><a class="header-anchor" href="#dom-事件" aria-hidden="true">#</a> DOM 事件</h3><ul><li><p><strong>事件流(三个阶段)</strong></p><ul><li>捕获阶段 目标阶段 冒泡阶段</li></ul></li><li><p><strong>Dom事件的捕获过程和冒泡过程</strong></p><ul><li>捕获过程 : window-&gt;document-&gt;html-&gt;body-&gt;…-&gt;目标元素</li><li>冒泡过程 : window&lt;-document&lt;-html&lt;-body&lt;-…&lt;-目标元素(事件代理)</li></ul></li><li><p><strong>Event对象的常见应用</strong></p><ul><li>阻止默认事件 : event.preventDefault()</li><li>阻止冒泡时间 : event.stopPropagation()</li><li>指定绑定事件 : event.currentTarget()</li><li>获取目标 : event.target</li></ul></li></ul><h3 id="前端安全" tabindex="-1"><a class="header-anchor" href="#前端安全" aria-hidden="true">#</a> 前端安全</h3><h3 id="js垃圾回收" tabindex="-1"><a class="header-anchor" href="#js垃圾回收" aria-hidden="true">#</a> JS垃圾回收</h3><h2 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> vue</h2><h3 id="响应式原理" tabindex="-1"><a class="header-anchor" href="#响应式原理" aria-hidden="true">#</a> 响应式原理</h3><h3 id="虚拟dom" tabindex="-1"><a class="header-anchor" href="#虚拟dom" aria-hidden="true">#</a> 虚拟DOM</h3><h3 id="声明周期" tabindex="-1"><a class="header-anchor" href="#声明周期" aria-hidden="true">#</a> 声明周期</h3><h2 id="浏览器" tabindex="-1"><a class="header-anchor" href="#浏览器" aria-hidden="true">#</a> 浏览器</h2><h3 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环" aria-hidden="true">#</a> 事件循环</h3><h3 id="渲染原理" tabindex="-1"><a class="header-anchor" href="#渲染原理" aria-hidden="true">#</a> 渲染原理</h3><h2 id="网络" tabindex="-1"><a class="header-anchor" href="#网络" aria-hidden="true">#</a> 网络</h2><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2><h3 id="vite-原理" tabindex="-1"><a class="header-anchor" href="#vite-原理" aria-hidden="true">#</a> vite 原理</h3><h3 id="pnpm" tabindex="-1"><a class="header-anchor" href="#pnpm" aria-hidden="true">#</a> pnpm</h3><h3 id="微前端" tabindex="-1"><a class="header-anchor" href="#微前端" aria-hidden="true">#</a> 微前端</h3><h3 id="v8工作流程" tabindex="-1"><a class="header-anchor" href="#v8工作流程" aria-hidden="true">#</a> V8工作流程</h3><h3 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化" aria-hidden="true">#</a> 性能优化</h3><h2 id="说一下前端从请求到响应都经历了什么" tabindex="-1"><a class="header-anchor" href="#说一下前端从请求到响应都经历了什么" aria-hidden="true">#</a> 说一下前端从请求到响应都经历了什么?</h2>',19);function b(x,g){const r=s("ExternalLinkIcon");return i(),d("div",null,[l,e("ul",null,[e("li",null,[e("a",c,[h("进阶必读：深入理解 JavaScript 原型 "),t(r)])])]),p,e("ul",null,[e("li",null,[e("a",u,[h("详解JavaScript中的Event Loop（事件循环）机制"),t(r)])])]),f])}const _=n(o,[["render",b],["__file","knowledge.html.vue"]]);export{_ as default};
