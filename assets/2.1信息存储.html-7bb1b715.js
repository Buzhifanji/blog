import{_ as n,X as a,Y as s,a1 as p}from"./framework-2bee7a6e.js";const t={},e=p(`<p>计算机最小单位为位，8 位被组织成一组，称为<strong>字节</strong>。<strong>大多数计算机使用8位的块，或者字节(byte)，作为最小的可寻址的内存单位</strong>，而不是单独访问内存中单独的位。</p><p>机器级程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存(virtual memory)</strong>。</p><p>内存的每个字节都由一个唯一的数字来标识，称为它的<strong>地址</strong>。</p><p>所有可能地址的集合称为<strong>虚拟地址空间(virtual address space)</strong>。</p><h2 id="_2-1-1-十六进制表示法" tabindex="-1"><a class="header-anchor" href="#_2-1-1-十六进制表示法" aria-hidden="true">#</a> 2.1.1 十六进制表示法</h2><p>对于描述位模式来说，二进制表示法太冗长，十进制表示法与位模式的互相转换很麻烦。</p><p>而一个字节由8位组成，用十六进制(hexadecimal)来表示位模式，正合适。</p><p><strong>十六进制(hex)，使用数字‘0’ ~ ‘9’以及字符‘A’ ~ ‘F’来表示16个可能的值</strong>。</p><p>在 C 语言中，以 0x 或者 0x 开头的数字常量被认为是十六进制的值。</p><h2 id="_2-1-2-字节数据大小" tabindex="-1"><a class="header-anchor" href="#_2-1-2-字节数据大小" aria-hidden="true">#</a> 2.1.2 字节数据大小</h2><p>每台计算机都有一个<strong>字长</strong>(word size)，指明指针数据的标称大小(normal size)。</p><p>因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。</p><p>一个字长为 w 位的机器，虚拟地址的范围为 0 ~ 2^w - 1，程序最多访问 2^w 个字节</p><p>在这个特定电脑中，字是其用来一次性处理事务的一个固定长度的位（bit）组。</p><p>::: theorem 字和字节换算 32位计算机：1字 = 32位 = 4字节</p><p>64位计算机：1字 = 64位 = 8字节 :::</p><p>对于32位还是64位程序的区别在于该程序是如何编译的，而不是其运行的机器类型。</p><p><img src="https://cdn.jsdelivr.net/gh/Buzhifanji/imgs-store/blog/20220713220853.png" alt="C数据类型"></p><h2 id="_2-1-3-寻址和字节顺序" tabindex="-1"><a class="header-anchor" href="#_2-1-3-寻址和字节顺序" aria-hidden="true">#</a> 2.1.3 寻址和字节顺序</h2><p>对于存储的数据，我们需要清楚该数据的<strong>地址是什么？以及在内存中如何排列</strong>的？</p><h3 id="高位字节" tabindex="-1"><a class="header-anchor" href="#高位字节" aria-hidden="true">#</a> 高位字节</h3><p>在字节 0x01234567 中，高位字节的十六进制值位 0x01</p><h3 id="低位字节" tabindex="-1"><a class="header-anchor" href="#低位字节" aria-hidden="true">#</a> 低位字节</h3><p>在字节 0x01234567 中，低位字节的十六进制值位 0x67</p><h3 id="大小端法" tabindex="-1"><a class="header-anchor" href="#大小端法" aria-hidden="true">#</a> 大小端法</h3><p>例子：假设变量<code>x</code>的类型位<code>int</code>,位于地址<code>0x100</code>处，它的十六进制值为 0x01234567。</p><p>假设计算机为32位，<code>int</code>类型占用4个字节，这四个字节被存储的内存地址是<code>0x100</code>、<code>0x101</code>、<code>0x102</code>、<code>0x103</code>。</p><p><strong>大端法(big endian)</strong>(最高有效字节在最前面的方式)</p><p><img src="https://cdn.jsdelivr.net/gh/Buzhifanji/imgs-store/blog/20220713221919.png" alt="大端法"></p><p><strong>小端法(little endian)</strong>(最低有效字节在最前面的方式)</p><p><img src="https://cdn.jsdelivr.net/gh/Buzhifanji/imgs-store/blog/20220713222047.png" alt="小端法"></p><p>强制类型转换，并打印字节排列数据。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token comment">// 强制转换成字节系列</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>byte_pointer<span class="token punctuation">;</span>


<span class="token keyword">void</span> <span class="token function">show_types</span><span class="token punctuation">(</span>byte_pointer start<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  size_t i<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot; %.2x&quot;</span><span class="token punctuation">,</span> start<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 打印 int 类型</span>
<span class="token keyword">void</span> <span class="token function">show_int</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">show_types</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 打印 float 类型</span>
<span class="token keyword">void</span> <span class="token function">show_float</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">show_types</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 打印 指针 类型</span>
<span class="token keyword">void</span> <span class="token function">show_pointer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">show_types</span><span class="token punctuation">(</span><span class="token punctuation">(</span>byte_pointer<span class="token punctuation">)</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">test_show_bytes</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 类型 转换</span>
  <span class="token keyword">int</span> ival <span class="token operator">=</span> val<span class="token punctuation">;</span>
  <span class="token keyword">float</span> fval <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> ival<span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>pval <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span>
  <span class="token function">show_int</span><span class="token punctuation">(</span>ival<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">show_float</span><span class="token punctuation">(</span>fval<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">show_pointer</span><span class="token punctuation">(</span>pval<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0x00003039</span><span class="token punctuation">;</span>
  <span class="token function">test_show_bytes</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">test_show_bytes</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">test_show_bytes</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-1-4-表示字符串" tabindex="-1"><a class="header-anchor" href="#_2-1-4-表示字符串" aria-hidden="true">#</a> 2.1.4 表示字符串</h2><p>c 语言中字符串被编码为一个null（其值为0）字符结尾的字符数组。</p><h2 id="_2-1-6-布尔代数" tabindex="-1"><a class="header-anchor" href="#_2-1-6-布尔代数" aria-hidden="true">#</a> 2.1.6 布尔代数</h2><h3 id="简单的布尔代数" tabindex="-1"><a class="header-anchor" href="#简单的布尔代数" aria-hidden="true">#</a> 简单的布尔代数</h3><ul><li><p>NOT(非;取反) $$ \\boxed{ \\def\\arraystretch{1.5} \\begin{array}{c | c} \\text{\\textasciitilde} &amp; \\ \\hline 0 &amp; 1 \\newline 1 &amp; 0 \\end{array} } $$</p></li><li><p>AND(与) $$ \\boxed{ \\def\\arraystretch{1.5} \\begin{array}{c | c} &amp;&amp; 0 &amp; 1 \\ \\hline 0 &amp; 0 &amp; 0 \\newline 1 &amp; 0 &amp; 1 \\end{array} } $$</p></li><li><p>OR(或) $$ \\boxed{ \\def\\arraystretch{1.5} \\begin{array}{c | c} \\text{\\textbar}&amp; 0 &amp; 1 \\ \\hline 0 &amp; 0 &amp; 1 \\newline 1 &amp; 1 &amp; 1 \\end{array} } $$</p></li><li><p>XOR(异或) $$ \\boxed{ \\def\\arraystretch{1.5} \\begin{array}{c | c} \\text{\\textasciicircum}&amp; 0 &amp; 1 \\ \\hline 0 &amp; 0 &amp; 1 \\newline 1 &amp; 1 &amp; 0 \\end{array} } $$</p></li></ul><h3 id="位向量运算" tabindex="-1"><a class="header-anchor" href="#位向量运算" aria-hidden="true">#</a> 位向量运算</h3><p>将布尔运算扩展到位向量运算</p><ul><li><p>NOT(非;取反) $$ \\def\\arraystretch{1.2} \\begin{array}{c c} 1100 \\ \\hline 0011 \\end{array} $$</p></li><li><p>AND(与) $$ \\def\\arraystretch{1.2} \\begin{array}{c c} 0110 \\newline 1100 \\ \\hline 0100 \\end{array} $$</p></li><li><p>OR(或) $$ \\def\\arraystretch{1.2} \\begin{array}{c c} 0110 \\newline 1100 \\ \\hline 1110 \\end{array} $$</p></li><li><p>XOR(异或) $$ \\def\\arraystretch{1.2} \\begin{array}{c c} 0110 \\newline 1100 \\ \\hline 1010 \\end{array} $$</p></li></ul><h2 id="_2-1-7-c-语言中的位级运算" tabindex="-1"><a class="header-anchor" href="#_2-1-7-c-语言中的位级运算" aria-hidden="true">#</a> 2.1.7 C 语言中的位级运算</h2><p>C 语言中的按位布尔运算，正是上文中的提到四种运算：| OR(或)、&amp; AND(与)、~ NOT(非;取反)、^ XOR(异或)。</p><p>计算机系统是采用<a href="#_2-1-1-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95">十六进制表示法</a>，所以位级运算需要将十六进制转换成二进制，然后将处理的结果转换成十六进制。</p><p>位级运算的常见用法：<strong>掩码运算</strong>，掩码指的是一个位模式，表示从一个字中选出的位集合。</p><div class="hint-container tip"><p class="hint-container-title">例子</p><p>位级运算 <code>x &amp; 0xFF</code>，假设计算机位 8 位，对于 <code>x = 0x89ABCDEF</code>，其结果为 <code>0x000000FF</code>。</p><p>推算逻辑，先把<strong>最低有效字节</strong>转换成二进制，然后进行位向量运算</p></div><h2 id="_2-1-8-c-语言中的逻辑运算" tabindex="-1"><a class="header-anchor" href="#_2-1-8-c-语言中的逻辑运算" aria-hidden="true">#</a> 2.1.8 C 语言中的逻辑运算</h2><p>逻辑运算符：<code>||</code>、<code>&amp;&amp;</code>、<code>!</code></p><p>返回 1 表示 TRUE，返回 0 表示 FALSE。</p><h2 id="_2-1-8-c-语言中的移位运算" tabindex="-1"><a class="header-anchor" href="#_2-1-8-c-语言中的移位运算" aria-hidden="true">#</a> 2.1.8 C 语言中的移位运算</h2><p>左移运算：从最高位向左移动 K 位，丢弃最高的 K 位，并在右端补齐 K 个 0。</p><div class="hint-container tip"><p class="hint-container-title">例子</p><p>x = [01100011]</p><p>x &lt;&lt; 4</p><p>结果：[00110000]</p><p>解释：丢弃 <code>0110</code>，保留 <code>0011</code>，补<code>0000</code></p></div><p>机器支持两种形式的右移</p><ul><li>逻辑右移</li></ul><p>从最低位向右移动 K 位，只保留移动的 K 位，在左端补 K 个 0。</p><div class="hint-container tip"><p class="hint-container-title">例子</p><p>x = [01100011]</p><p>x &gt;&gt; 4 (逻辑右移)</p><p>结果：[00000011]</p><p>解释：保留移动的 <code>0011</code>，补<code>0000</code></p></div><ul><li>算术右移</li></ul><p>与逻辑右移的区别在补位，高位操作数是 <code>1</code> 就补 <code>1</code> ，反之 <code>0</code> 就补 <code>0</code> 。</p><div class="hint-container tip"><p class="hint-container-title">例子1</p><p>x = [01100011]</p><p>x &gt;&gt; 4 (算术右移)</p><p>结果：[00000011]</p><p>解释：保留移动的 <code>0011</code>，最高为 0，所以补 0。</p></div><div class="hint-container tip"><p class="hint-container-title">例子2</p><p>x = [10010101]</p><p>x &gt;&gt; 4 (算术右移)</p><p>结果：[11110101]</p><p>解释：保留移动的 <code>0101</code>，最高为 1，所以补 1。</p></div>`,60),o=[e];function c(i,l){return a(),s("div",null,o)}const d=n(t,[["render",c],["__file","2.1信息存储.html.vue"]]);export{d as default};
